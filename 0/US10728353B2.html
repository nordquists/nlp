
    <html>
        <body>
            <search-app>
                <article class="result" itemscope="" itemtype="http://schema.org/ScholarlyArticle">
    <h1 itemprop="pageTitle">US10728353B2 - Adaptive data streaming method with push messages control 
        - Google Patents</h1><section itemprop="abstract" itemscope="">
<h2>Abstract</h2>
<div html="" itemprop="content"><abstract lang="EN" load-source="patent-office" mxw-id="PA405759018">
<div class="abstract" id="p-0001" num="0000">There is provided methods for managing streaming over communication networks. Server and client devices share a push policy so that the client device may anticipate data pushes by the server. Anticipation makes it possible to cancel early the sending of some pushed data, therefore reducing bandwidth consumption. The shared push policy may be implicit to both server and client. In embodiments, it is explicitly specified by the server to the client, for example embedded in the Media Presentation Description file or included in a specific HTTP header. The client may also request an update of the shared push policy to meet its own requirements.</div>
</abstract>
</div>
</section><section itemprop="description" itemscope="">
<h2>Description</h2>
<div html="" itemprop="content"><div class="description" lang="EN" load-source="patent-office" mxw-id="PDES270481312">
<heading id="h-0001">CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
<div class="description-paragraph" id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 14/903,989, filed on Jan. 8, 2016, that is a national phase application of international patent application PCT/EP2014/064949 filed on Jul. 11, 2014, and claims the benefit of, and priority to, GB patent applications: No. 1312547.1 and No. 1312561.2, both of Jul. 12, 2013, and No. 1410540.7 of Jun. 12, 2014, which are all incorporated herein by reference.</div>
<heading id="h-0002">FIELD OF THE INVENTION</heading>
<div class="description-paragraph" id="p-0003" num="0002">The present invention relates to data streaming over HTTP communication networks.</div>
<div class="description-paragraph" id="p-0004" num="0003">More particularly, the present invention relates to adaptive data streaming for satisfying network constraints. The invention may have applications in DASH networks.</div>
<div class="description-paragraph" id="p-0005" num="0004">DASH (acronym for Dynamic Adaptive Streaming over HTTP) is a communication standard allowing media content streaming (typically audio/video content) over HTTP. According to DASH, media presentations are described as XML files, called “media presentation description” files (MPD in what follows). MPD files provide client devices with information allowing them to request and control the delivery of media contents.</div>
<heading id="h-0003">BACKGROUND OF THE INVENTION</heading>
<div class="description-paragraph" id="p-0006" num="0005">The general principle of Media streaming over HTTP is illustrated in <figref idrefs="DRAWINGS">FIG. 3</figref>. Most of the new protocols and standards for adaptive media streaming over HTTP are based on this principle.</div>
<div class="description-paragraph" id="p-0007" num="0006">A media server <b>300</b> streams data to a client <b>310</b>. The media server stores media presentations. For example, media presentation <b>301</b> contains audio and video data. Audio and video may be interleaved in a same file. The way the media presentation is built is described in what follows with reference to <figref idrefs="DRAWINGS">FIG. 4<i>a</i> </figref>. The media presentation is temporally split into small independent and consecutive temporal segments <b>302</b> <i>a</i>, <b>302</b> <i>b </i>and <b>302</b> <i>c</i>, such as MP4 segments, that can be addressed and downloaded independently. The downloading addresses (HTTP URLs) of the media content for each of these temporal segments are set by the server to the client. Each temporal segment of the audio/video media content is associated with one HTTP address.</div>
<div class="description-paragraph" id="p-0008" num="0007">The media server also stores a manifest file document <b>304</b> (described in what follows with reference to <figref idrefs="DRAWINGS">FIG. 5</figref>) that describes the content of the media presentation including the media content characteristics (e.g. the type of media: audio, video, audio-video, text etc.), the encoding format (e.g. the bitrate, the timing information etc.), the list of temporal media segments and associated URLs. Alternatively, the document contains template information that makes it possible to rebuild the explicit list of the temporal media segments and associated URLs. This document may be written using the eXtensible Markup Language (XML).</div>
<div class="description-paragraph" id="p-0009" num="0008">The manifest file is sent to the client. Upon receipt of the manifest file during a step <b>305</b>, the client is informed of the association between temporal segments of the media contents and HTTP addresses. Also, the manifest file provides the client with the information concerning the content of the media presentation (interleaved audio/video in the present example). The information may include the resolution, the bit-rate etc.</div>
<div class="description-paragraph" id="p-0010" num="0009">Based on the information received, the HTTP client module <b>311</b> of client can emit HTTP requests <b>306</b> for downloading temporal segments of the media content described in the manifest file. The server's HTTP responses <b>307</b> convey the requested temporal segments. The HTTP client module <b>311</b> extracts from the responses the temporal media segments and provides them to the input buffer <b>307</b> of the media engine <b>312</b>. Finally, the media segments can be decoded and displayed during respective steps <b>308</b> and <b>309</b>.</div>
<div class="description-paragraph" id="p-0011" num="0010">The media engine <b>312</b> interacts with the DASH control engine <b>313</b> in order to have the requests for next temporal segments to be issued at the appropriate time. The next segment is identified from the manifest file. The time at which the request is issued depends on whether or not the reception buffer <b>307</b> is full. The DASH control engine <b>313</b> controls the buffer in order to prevent it from being overloaded or completely empty.</div>
<div class="description-paragraph" id="p-0012" num="0011">The generation of the media presentation and the manifest file is described with reference to <figref idrefs="DRAWINGS">FIG. 4<i>a</i> </figref>. During steps <b>400</b> and <b>401</b>, audio and video data are acquired. Next, the audio data are compressed during 402. For example, the MP3 standard can be used. Also, the video data are compressed in parallel during step <b>403</b>. Video compression algorithms such as MPEG4, MPEG/AVC, SVC, HEVC or scalable HEVC can be used. Once compression of audio and video data has been performed, audio and video elementary streams <b>404</b>, <b>405</b> are available. The elementary streams are encapsulated during a step <b>406</b> into a global media presentation. For example, the ISO BMFF standard (or the extension of the ISO BMFF standard to AVC, SVC, HEVC, scalable extension of HEVC etc.) can be used for describing the content of the encoded audio and video elementary streams as a global media presentation. The encapsulated media presentation <b>407</b> thereby obtained is used for generating, during step <b>408</b>, an XML manifest file <b>409</b>. Several representations of video data <b>401</b> and audio data <b>400</b> can be acquired, compressed, encapsulated and described in the media presentation <b>407</b>.</div>
<div class="description-paragraph" id="p-0013" num="0012">For the specific case of MPEG/DASH streaming protocol illustrated in <figref idrefs="DRAWINGS">FIG. 4<i>b</i> </figref>, the manifest file is called “Media Presentation Description” (or “MPD” file). The root element of the file is the MPD element that contains attributes applying to all the presentation plus DASH information like profile or schema. The media presentation is split into temporal periods represented by a Period element. The MPD file <b>410</b> contains all the data related to each temporal period. By receiving this information, the client is aware of the content for each period of time. For each Period <b>411</b>, AdaptationSet elements are defined.</div>
<div class="description-paragraph" id="p-0014" num="0013">A possible organization is to have one or more AdaptationSet per media type contained in the presentation. An AdaptationSet <b>412</b> related to video contains information about the different possible representations of the encoded videos available at the server. Each representation is described in a Representation element. For example, a first representation can be a video encoded with a spatial resolution of 640×480 and compressed with a bit rate of 500 kbits/s. A second representation can be the same video but compressed with a bit rate of 250 kbits/s.</div>
<div class="description-paragraph" id="p-0015" num="0014">Each video can then be downloaded by HTTP requests if the client knows the HTTP addresses related to the video. The association between the content of each representation and the HTTP addresses is done by using an additional level of description: the temporal segments. Each video representation is split into temporal segments <b>413</b> (typically few seconds). Each temporal segment comprises content stored at the server that is accessible via an HTTP address (URL or URL with one byte range). Several elements can be used for describing the temporal segments in the MPD file: SegmentList, SegmentBase or Segment Template.</div>
<div class="description-paragraph" id="p-0016" num="0015">In addition, a specific segment is available: the initialization segment. The initialization segment contains MP4 initialization information (if the video has been encapsulated using the ISO BMFF or extensions thereof) that describes the encapsulated video stream. For example, it helps the client to instantiate the decoding algorithms related to the video.</div>
<div class="description-paragraph" id="p-0017" num="0016">The HTTP addresses of the initialization segment and the media segments are indicated in the MPD file.</div>
<div class="description-paragraph" id="p-0018" num="0017">In <figref idrefs="DRAWINGS">FIG. 5</figref>, there is shown an exemplary MPD file. Two media are described in the MPD file shown. The first one is an English audio stream and the second one is a video stream. The English audio stream is introduced using the AdaptationSet tag <b>500</b>. Two alternative representations are available for this audio stream:
</div> <ul> <li id="ul0001-0001" num="0000"> <ul> <li id="ul0002-0001" num="0018">the first representation <b>501</b> is an MP4 encapsulated elementary audio stream with a bit-rate of 64000 bits/sec. The codec to be used for handling this elementary stream (after MP4 parsing) is defined in the standard by the attribute codecs having the value: ‘mp4a.0x40’. It is accessible via a request at the address formed by the concatenation of the BaseURL elements in the segment hierarchy: &lt;BaseURL&gt;7657412348.mp4&lt;/BaseURL&gt;, which is a relative URI. The &lt;BaseURL&gt; being defined at the top level in the MPD element by ‘http://cdn1.example.com/’ or by ‘http://cdn2.example.com/’ (two servers are available for streaming the same content) is the absolute URI. The client can then request the English audio stream from the request to the address ‘http://cdn1.example.com/7657412348.mp4’ or to the address ‘http://cdn2.example.com/7657412348.mp4’.</li> <li id="ul0002-0002" num="0019">the second representation <b>502</b> is an MP4 encapsulated elementary audio stream with a bit-rate of 32000 bits/sec. The same explanations as for the first representation <b>501</b> can be made and the client device can thus request this second representation <b>502</b> by a request at either one of the following addresses:</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0019" num="0020">‘http://cdn1.example.com/3463646346.mp4’ or</div>
<div class="description-paragraph" id="p-0020" num="0021">‘http://cdn2.example.com/3463646346.mp4’.</div>
<div class="description-paragraph" id="p-0021" num="0022">The adaptation set <b>503</b> related to the video contains six representations. These representations contain videos with different spatial resolutions (320×240, 640×480, 1280×720) and with different bit rates (from 256000 to 2048000 bits per second). For each of these representations, a respective URL is associated through a BaseURL element. The client can therefore choose between these alternative representations of the same video according to different criteria like estimated bandwidth, screen resolution etc. (Note that, in <figref idrefs="DRAWINGS">FIG. 5</figref>, the decomposition of the Representation into temporal segments is not illustrated, for the sake of clarity.)</div>
<div class="description-paragraph" id="p-0022" num="0023"> <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>shows the standard behavior of a DASH client. <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>shows a tree representation of an exemplary manifest file (description file or MPD) used in the method shown in <figref idrefs="DRAWINGS">FIG. 4</figref> <i>a. </i> </div>
<div class="description-paragraph" id="p-0023" num="0024">When starting a streaming session, a DASH client starts by requesting the manifest file (step <b>550</b>). After waiting for the server's response and receiving the manifest file (step <b>551</b>), the client analyzes the manifest file (step <b>552</b>), selects a set AS<sub>ij </sub>of AdaptationSets suitable for its environment (step <b>553</b>), then selects, within each AdaptationSet AS<sub>ij</sub>, a Representation in the MPD suitable for example for its bandwidth, decoding and rendering capabilities (step <b>554</b>).</div>
<div class="description-paragraph" id="p-0024" num="0025">The DASH client can then build in advance the list of segments to request, starting with initialization information for the media decoders. This initialization segment has to be identified in the MPD (step <b>555</b>) since it can be common to multiple representations, adaptation sets and periods or specific to each Representation or even contained in the first media segment.</div>
<div class="description-paragraph" id="p-0025" num="0026">The client then requests the initialization segment (step <b>556</b>). Once the initialization segment is received (step <b>557</b>), the decoders get initiated (step <b>558</b>).</div>
<div class="description-paragraph" id="p-0026" num="0027">The client then requests first media data on a segment basis (step <b>560</b>) and buffers a minimum data amount (thanks to the condition at step <b>559</b>) before actually starting decoding and displaying (step <b>563</b>). These multiple requests/responses between the MPD download and the first displayed frames introduce a startup delay in the streaming session. After these initial steps, the DASH streaming session continues in a standard way, i.e. the DASH client adapts and requests the media segments one after the other.</div>
<div class="description-paragraph" id="p-0027" num="0028">The current DASH version does not provide description of Region-Of-Interest within the manifest files. Several approaches have been proposed for such description.</div>
<div class="description-paragraph" id="p-0028" num="0029">In particular, components of media contents can be described using SubRepresentation elements. These elements describe the properties of one or several components that are embedded in a Representation. In <figref idrefs="DRAWINGS">FIG. 6</figref>, there is shown an example of a DASH manifest file describing tile tracks as components of a video. For the sake of conciseness and clarity, only one Period <b>600</b> is represented. However, subsequent period elements would be organized in a same fashion. In part <b>601</b>, a first adaptation set element is used for describing a base layer of the scalable video. For example, the video is encoded according to SVC or HEVC scalable. In part <b>602</b>, a second adaptation set is used for describing the highest resolution layer of the scalable video. For non-scalable video, only the second adaptation set <b>602</b> would be present, without dependency to the base layer, i.e. the dependencyId attribute. In this second adaptation set <b>602</b>, a single representation <b>603</b> is described, namely the one that corresponds to the displayable video. The representation is described as a list of segments <b>610</b> with respective URLs for client requests.</div>
<div class="description-paragraph" id="p-0029" num="0030">Thus, the representation depends on another representation identified by ‘R<b>1</b>’ (dependencyId attribute), actually the base layer representation from the first adaptation set <b>601</b>. The dependency forces the streaming client to first request the current segment for base layer before getting the current segment for the enhancement layer. This cannot be used to express dependencies with respect to tile tracks because the tracks that would be referenced this way would be automatically loaded by the client. This is something to be avoided, since it is up to the user to select the tiles of interest for him anytime during the media presentation. Therefore, in order to indicate the dependencies between the composite track and the tile tracks the SubRepresentation element is used. The displayable video is described as a list of sub-representations <b>604</b> to <b>608</b>. Each sub representation actually represents a track in the encapsulated MP4 file. Thus, there is one sub-representation per tile (four tiles in the present example) plus one sub-representation for the composite track <b>608</b>. Each sub-representation is described by a content component element <b>614</b> to <b>618</b> in order to indicate whether it corresponds to a tile track <b>614</b>, <b>615</b>, <b>616</b> and <b>617</b> or to the composite track <b>618</b>. The Role descriptor type available in DASH/MPD is used with a specific scheme for tiling. The Role descriptor also indicates the position of the tile in the full-frame video. For example the component <b>614</b> describes the tile located at the top left of the video (1:1 for first in row and first in column). The dimensions of the tiles, width and height, are specified as attributes of the sub representation as made possible by MPD. Bandwidth information can also be put here for helping the DASH client in the determination of the number of tiles and the selection of the tiles, according to its bandwidth. Concerning the composite track, it has to be signalled in a different way than the tile tracks since it is mandatory to be able, at the end of the download, to build a video stream that can be decoded. To that purpose, two elements are added into the description. Firstly, the descriptor in the related content component <b>618</b> indicates that it is the main component among all the components. Secondly, in the sub representation, a new attribute ‘required’ is added in order to indicate to the client that the corresponding data have to be requested. All requests for the composite track or for one or more of the tile tracks are computed from the URL provided in the segment list <b>610</b> (one per time interval). In the example, “URL_X” combined with “BaseURL” at the beginning of the MPD provides a complete URL which the client can use for performing an HTTP GET request. With this request, the client would get the data for the composite track and all the data for all the tile tracks. In order to optimize the transmission, instead of the request, the client can first request the segment index information (typically the “ssix” and/or “sidx” information in ISO BMFF well known by the man skilled in the art), using the data available from the index_range attribute <b>620</b>. This index information makes it possible to determine the byte ranges for each of the component. The DASH client can then send as many HTTP GET requests with appropriate byte range as selected tracks (including the required composite track).</div>
<div class="description-paragraph" id="p-0030" num="0031">When starting a streaming session, a DASH client requests the manifest file. Once received, the client analyzes the manifest file, selects a set of AdaptationSets suitable for its environment. Next, the client selects in the MPD, within each AdaptationSet, a Representation compatible with its bandwidth, decoding and rendering capabilities. Next, it builds in advance the list of segments to be requested, starting with initialization information for the media decoders. When initialization information is received by the decoders, they are initialized and the client requests first media data and buffers a minimum data amount before actually starting the display.</div>
<div class="description-paragraph" id="p-0031" num="0032">These multiple requests/responses may introduce delay in the startup of the streaming session. The risk is for service providers to see their clients leaving the service without starting to watch the video. It is common to name this time between the initial HTTP request for the first media data chunk, performed by the client, and the time when the media data chunk actually starts playing as the start-up delay. It depends on the network round-trip time but also on the size of the media segments.</div>
<div class="description-paragraph" id="p-0032" num="0033">Server Push is a useful feature for decreasing web resource loading time. Such servers are discussed with reference to <figref idrefs="DRAWINGS">FIGS. 1<i>a </i> </figref>to <b>1</b> <i>e. </i> </div>
<div class="description-paragraph" id="p-0033" num="0034">In <figref idrefs="DRAWINGS">FIG. 1<i>b</i> </figref>, there is shown that in HTTP/2 exchanges, a request must be sent for every resource needed: resources R<b>1</b> to R<b>4</b> and sub-resources A to I (as shown in <figref idrefs="DRAWINGS">FIG. 1<i>a</i> </figref>). However, when using the push feature by servers, as illustrated in <figref idrefs="DRAWINGS">FIG. 1<i>c</i> </figref>, the number of requests is limited to elements R<b>1</b> to R<b>4</b>. Elements A to I are “pushed” by the server to the client based on the dependencies shown in <figref idrefs="DRAWINGS">FIG. 1<i>a</i> </figref>, thereby making the associated requests unnecessary.</div>
<div class="description-paragraph" id="p-0034" num="0035">Thus, as illustrated in <figref idrefs="DRAWINGS">FIGS. 1<i>b </i>and 1<i>c</i> </figref>, when servers use the push feature, the number of HTTP round-trips (request+response) necessary for loading a resource with its sub-resources is reduced. This is particularly interesting for high-latency networks such as mobile networks.</div>
<div class="description-paragraph" id="p-0035" num="0036">HTTP is the protocol used for sending web resources, typically web pages. HTTP implies a client and a server:
</div> <ul> <li id="ul0003-0001" num="0000"> <ul> <li id="ul0004-0001" num="0037">The client sends a request to the server;</li> <li id="ul0004-0002" num="0038">The server replies to the client's request with a response that contains a representation of the web resource.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0036" num="0039">Requests and responses are messages comprising various parts, notably the HTTP headers. An HTTP header comprises a name along with a value. For instance, “Host: en.wikipedia.org” is the “Host” header, and its value is “en.wikipedia.org”. It is used for indicating the host of the resource queried (for instance, the Wikipedia page describing HTTP is available at http://en.wikipedia.org/wiki/HTTP). HTTP headers appear on client requests and server responses.</div>
<div class="description-paragraph" id="p-0037" num="0040">HTTP/2 makes it possible to exchange requests/responses through streams. A stream is created inside an HTTP/2 connection for every HTTP request and response. Frames are exchanged within a stream in order to convey the content and headers of the requests and responses.</div>
<div class="description-paragraph" id="p-0038" num="0041">HTTP/2 defines a limited set of frames with different meanings, such as:
</div> <ul> <li id="ul0005-0001" num="0000"> <ul> <li id="ul0006-0001" num="0042">HEADERS: which is provided for transmission of HTTP headers</li> <li id="ul0006-0002" num="0043">DATA: which is provided for transmission of HTTP message content</li> <li id="ul0006-0003" num="0044">PUSH_PROMISE: which is provided for announcing pushed content</li> <li id="ul0006-0004" num="0045">PRIORITY: which is provided for setting the priority of a stream</li> <li id="ul0006-0005" num="0046">WINDOW_UPDATE: which is provided for updating the value of the control flow window</li> <li id="ul0006-0006" num="0047">SETTINGS: which is provided for conveying configuration parameters</li> <li id="ul0006-0007" num="0048">CONTINUATION: which is provided for continuing a sequence of header block fragments</li> <li id="ul0006-0008" num="0049">RST_STREAM: which is provided for terminating or cancelling a stream.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0039" num="0050">Push by servers has been introduced in HTTP/2 for allowing servers to send unsolicited web resource representations to clients. Web resources such as web pages generally contain links to other resources, which themselves may contain links to other resources. To fully display a web page, all the linked and sub-linked resources generally need to be retrieved by a client. This incremental discovery may lead to a slow display of a web page, especially on high latency networks such as mobile networks.</div>
<div class="description-paragraph" id="p-0040" num="0051">When receiving a request for a given web page, the server may know which other resources are needed for the full processing of the requested resource. By sending the requested resource and the linked resources at the same time, the server allows reducing the load time of the web page. Thus, using the push feature, a server may send additional resource representations at the time it is requested a given resource.</div>
<div class="description-paragraph" id="p-0041" num="0052">With reference to the flowchart of <figref idrefs="DRAWINGS">FIG. 1<i>e</i> </figref>, an exemplary mode of operation of a server implementing the push feature is described.</div>
<div class="description-paragraph" id="p-0042" num="0053">During step <b>100</b>, the server receives an initial request. Next, the server identifies during step <b>101</b> the resources to push as part of the response and starts sending the content response during step <b>102</b>. In parallel, the server sends push promise messages to the client during step <b>103</b>. These messages identify the other resources that the server is planning to push, for instance based on the dependencies shown in <figref idrefs="DRAWINGS">FIG. 1<i>a</i> </figref>. These messages are sent in order to let the client know in advance which pushed resources will be sent. In particular, this reduces the risk that a client sends a request for a resource that is being pushed at the same time or about to be pushed. In order to further reduce this risk, a server should send a push promise message before sending any part of the response referring to the resource described in the push promise. This also allows clients to request cancellation of the push of the promised resources if clients do not want those resources. Next, the server sends the response and all promised resources during step <b>104</b>. The process ends during a step <b>105</b>.</div>
<div class="description-paragraph" id="p-0043" num="0054">The flowchart of <figref idrefs="DRAWINGS">FIG. 1<i>d </i> </figref>illustrates the process on the client side.</div>
<div class="description-paragraph" id="p-0044" num="0055">When the client has identified a resource to retrieve from the server, it first checks during a step <b>106</b> whether or not the corresponding data is already in its cache memory. In case the resource is already in the cache memory (Yes), it is retrieved from it during a step <b>107</b>. Cached data may be either data retrieved from previous requests or data that were pushed by the server previously. In case it is not in the cache memory (No), the client sends a request during step <b>108</b> and waits for the server's response. Upon receipt of a frame from the server, the client checks during step <b>109</b> whether or not the frame corresponds to a PUSH promise. If the data frame corresponds to the PUSH promise (Yes), during step <b>110</b>, the client processes the push promise. The client identifies the resource to be pushed. If the client does not wish to receive the resource, the client may send an error message to the server so the server does not push that resource. Otherwise, the client stores the push promise until receiving the corresponding push content. The push promise is used so that the client does not request the promised resource while the server is pushing it. In case the data frame does not correspond to the PUSH promise (No), it is checked, during step <b>111</b>, whether or not, the frame is a data frame related to push data. In case it is related to push data (Yes), the client processes the pushed data during step <b>112</b>. The pushed data is stored within the client cache. In case the frame is not a data frame related to push data (No), it is checked, during step <b>113</b>, whether it corresponds to a response received from the server. In case the frame corresponds to a response from the server (Yes), the response is processed during step <b>114</b> (e.g. sent to the application). Otherwise (No), it is checked during step <b>115</b> whether or not the frame identifies the end of a response (Yes). In this case, the process is terminated during step <b>116</b>. Otherwise, the process goes back to step <b>109</b>.</div>
<div class="description-paragraph" id="p-0045" num="0056">Thus, it appears that the client receives the response and the promised resources. The promised resources are therefore generally stored in the client cache while the response is used by the application such as a browser displaying a retrieved web page. When a client application requests one of the resources that were pushed, the resource is immediately retrieved from the client cache, without incurring any network delay.</div>
<div class="description-paragraph" id="p-0046" num="0057">The storage of pushed resources in the cache is controlled using the cache control directives. The cache control directives are also used for controlling of the responses. These directives are in particular applicable to proxies: any resource pushed or not, may be stored by proxies or by the client only.</div>
<div class="description-paragraph" id="p-0047" num="0058"> <figref idrefs="DRAWINGS">FIG. 1<i>a </i> </figref>is a graph of a set of resources owned by a server with their relationships. The set of resources is intertwined: R<sub>1</sub>, R<sub>2</sub>, R<sub>3</sub>, and R<sub>4 </sub>are resources that need to be downloaded together to be properly processed by a client. In addition, sub-resources A to H are defined. These sub-resources are related to 1, 2 or 3 resources. For instance, A is linked to R<sub>1 </sub>and C is linked to R<sub>1</sub>, R<sub>2 </sub>and R<sub>4</sub>.</div>
<div class="description-paragraph" id="p-0048" num="0059"> <figref idrefs="DRAWINGS">FIG. 1<i>b</i> </figref>, already discussed hereinabove, shows an HTTP exchange without using the server PUSH feature: the client requests R<sub>1</sub>, next it discovers R<sub>2</sub>, A, B, C and D and request them. After receiving them, the client requests R<sub>3</sub>, R<sub>4</sub>, F and G. Finally the client requests H and I sub-resources. This requires four round-trips to retrieve the whole set of resources.</div>
<div class="description-paragraph" id="p-0049" num="0060"> <figref idrefs="DRAWINGS">FIG. 1<i>c</i> </figref>, already discussed hereinabove, illustrates the HTTP exchange using the feature of pushing directly connected sub-resources by the server. After requesting R<sub>1</sub>, the server sends R<sub>1 </sub>and pushes A, B, C and D. The client identifies R<sub>2 </sub>and requests it. The server sends R<sub>2 </sub>and pushes F and G. Finally the client identifies R<sub>3</sub>, R<sub>4 </sub>and requests these resources. The server sends R<sub>3</sub>, R<sub>4 </sub>and pushes H and I. This process requires three round-trips to retrieve the whole set of resources.</div>
<div class="description-paragraph" id="p-0050" num="0061">In order to decrease the loading time of a set of resources, typically a web page and its sub-resources, HTTP/2 allows exchanging multiple request and response priorities in parallel. As illustrated in <figref idrefs="DRAWINGS">FIG. 2</figref>, a web page may require the download of several resources, like JavaScript, images etc. During an initial HTTP exchange <b>200</b>, the client retrieves an HTML file. This HTML file contains links to two JavaScript files (JS1, JS2), two images (IMG1, IMG2), one CSS file and one HTML file. During an exchange <b>201</b>, the client sends a request for each file. The order given in the exchange <b>201</b> of <figref idrefs="DRAWINGS">FIG. 2</figref> is based on the web page order: the client sends a request as soon as a link is found. The server then receives requests for JS1, CSS, IMG1, HTML, IMG2 and JS2 and processes these requests according that order. The client then retrieves these resources in that order.</div>
<div class="description-paragraph" id="p-0051" num="0062">HTTP priorities make it possible for the client to state which requests are more important and should be treated sooner than other requests. A particular use of priorities is illustrated in exchange <b>202</b>. JavaScript files are assigned the highest priority. CSS and HTML files are assigned medium priority and images are assigned low priority. This approach allows receiving blocking files or files that may contain references to other resources sooner than other files. In response, the server is expected to try sending sooner the JavaScript files, the CSS and HTML files afterwards and the images at the end, as described in exchange <b>202</b>. Servers are not mandated to follow client priorities.</div>
<div class="description-paragraph" id="p-0052" num="0063">In addition to priorities, HTTP/2 provides that the amount of data being exchanged simultaneously can be controlled. Client and server can specify which amount of data they can buffer on a per connection basis and a per stream basis. This is similar to TCP congestion control: a window size, which specifies an available buffer size, is initialized to a given value; each time the emitter sends data, the window size is decremented; the emitter must stop sending data so that the window size never goes below zero. The receiver receives the data and sends messages to acknowledge that the data was received and removed from the buffer; the message contains the amount of data that was removed from the buffer; the window size is then increased from the given value and the emitter can restart sending data.</div>
<div class="description-paragraph" id="p-0053" num="0064">In view of the above, it appears that DASH is based on the assumption that the client leads the streaming since the client can generally select the best representation of the content for the purpose of the application it is performing. For instance, a client may know whether to request High-Definition or Small-Definition content based on its form-factor and screen resolution.</div>
<div class="description-paragraph" id="p-0054" num="0065">Server-based streaming is typically done using RTP. Contrary to DASH, RTP does not use HTTP and cannot directly benefit from the web infrastructures, in particular proxies and caches. Web socket based media streaming has the same drawbacks. With HTTP/1.1, server-based streaming cannot be easily implemented since the server can generally only answer to client requests. With HTTP/2, in particular with the introduction of the push feature, DASH-based servers can lead the streaming. Thus, servers can use their knowledge of the characteristics of the content they are streaming for optimizing the user experience. For instance, a server may push a film as SD (due to limited bandwidth) but advertisements as HD since advertisements take an additional limited amount of bandwidth. Another example is the case of a server that starts to do fast start with a low-resolution video and switches to the best possible representation once bandwidth is well estimated.</div>
<div class="description-paragraph" id="p-0055" num="0066">In order to enable a server to lead the streaming, one approach is to let the server push data (in particular DASH data) as preferred. The client then uses whatever data is available to display the video. The server typically announces the push of several segments at once. The server then sends the segments in parallel or successively.</div>
<div class="description-paragraph" id="p-0056" num="0067">A problem that occurs is that client and server may not know if the promised data will be transmitted and received at the desired time: the client may not know when and in which order the video segments will be sent.</div>
<div class="description-paragraph" id="p-0057" num="0068">Also, the promised data pushed or announced by the server may mismatch the client needs, thus leading to resource wasting in particular at the server end.</div>
<div class="description-paragraph" id="p-0058" num="0069">Thus, there is a need for enhancing data streaming especially in the context of DASH-based communications.</div>
<heading id="h-0004">SUMMARY OF THE INVENTION</heading>
<div class="description-paragraph" id="p-0059" num="0070">The present invention lies within this context.</div>
<div class="description-paragraph" id="p-0060" num="0071">According to a first aspect of the invention corresponding to the server's perspective, a method of streaming media data by a server device to a client device, comprises the following steps:
</div> <ul> <li id="ul0007-0001" num="0000"> <ul> <li id="ul0008-0001" num="0072">receiving, from the client device, a request relating to first media data,</li> <li id="ul0008-0002" num="0073">identifying second media data to be sent to the client device without having been requested, and</li> <li id="ul0008-0003" num="0074">in response to said request, transmitting to said client device, data relating to said first media data, and preparing at least one announcement message respectively identifying said second media data with a view to transmit the announcement message or messages to the client device, and</li> <li id="ul0008-0004" num="0075">wherein the method further comprises the step of using a push policy shared with the client device for the server device to drive the identification or the transmission of the second non-requested media data to the client device.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0061" num="0076">According to a second aspect of the invention corresponding to the client's perspective, a method of accessing by a client device, media data streamed by a server device, the method comprises the following steps:
</div> <ul> <li id="ul0009-0001" num="0000"> <ul> <li id="ul0010-0001" num="0077">transmitting, to the server device, a request relating to first media data,</li> <li id="ul0010-0002" num="0078">receiving from said server device, in response to said request, data relating to said first media data,</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0062" num="0079">wherein the method further comprises the step of using a push policy shared with the server device for the client device to determine second media data to be sent by the server device without having been requested by the client device or to determine an order of transmission thereof by the server device.</div>
<div class="description-paragraph" id="p-0063" num="0080">In particular, the shared push policy may define how to determine second media data, for the devices to determine the second non-requested media data to be sent by the server device to the client device.</div>
<div class="description-paragraph" id="p-0064" num="0081">Thanks to this approach, the mismatch between the server's decision regarding the media data to be pushed and the client's needs can be decreased and thus resources can be saved.</div>
<div class="description-paragraph" id="p-0065" num="0082">This is achieved by using a shared push policy that makes it possible for the client to anticipate the server's behaviour, and thus the second media data that are about to be pushed. Thanks to the shared push policy than may be used for several client's subsequent requests, the client can anticipate the server's behaviour even before the requests are sent to the server.</div>
<div class="description-paragraph" id="p-0066" num="0083">As a consequence of the anticipation, the client can prepare and request the cancellation of such second media data that are not needed, in an anticipated fashion with respect to the announcement by the server.</div>
<div class="description-paragraph" id="p-0067" num="0084">The request relating to first media data may concern first media data and/or other data related to this first media data.</div>
<div class="description-paragraph" id="p-0068" num="0085">The second media data may be associated with said first media data, for example by the server device.</div>
<div class="description-paragraph" id="p-0069" num="0086">Embodiments of the invention provide a lightweight mechanism for server-guided streaming. Embodiments may be implemented in the context of DASH networks.</div>
<div class="description-paragraph" id="p-0070" num="0087">Server devices can make content recommendations to the client devices. Also, they can optimize the network usage.</div>
<div class="description-paragraph" id="p-0071" num="0088">Embodiments of the invention are compatible with existing HTTP/2 features. These features can advantageously be used for implementing embodiments of the invention.</div>
<div class="description-paragraph" id="p-0072" num="0089">Network performances are generally increased.</div>
<div class="description-paragraph" id="p-0073" num="0090">Correspondingly, the invention also regards a server device for streaming media data to a client device, the device comprising:
</div> <ul> <li id="ul0011-0001" num="0000"> <ul> <li id="ul0012-0001" num="0091">a receiver configured for receiving, from the client device, a request relating to first media data,</li> <li id="ul0012-0002" num="0092">a control unit configured for identifying second media data to be sent to the client device without having been requested, and</li> <li id="ul0012-0003" num="0093">a transmitter configured for, in response to said request, transmitting to said client device, data relating to said first media data, and preparing at least one announcement message respectively identifying said second media data with a view to transmit the announcement message or messages to the client device, and</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0074" num="0094">wherein the control unit is further configured for using a push policy shared with the client device in order to drive the identification or the transmission of the second non-requested media data to the client device.</div>
<div class="description-paragraph" id="p-0075" num="0095">The invention also regards a client device for accessing media data streamed by a server device, the device comprising:
</div> <ul> <li id="ul0013-0001" num="0000"> <ul> <li id="ul0014-0001" num="0096">a transmitter configured for transmitting, to the server device, a request relating to first media data, and</li> <li id="ul0014-0002" num="0097">a receiver configured for receiving from said server device, in response to said request, data relating to said first media data,</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0076" num="0098">wherein the client device is configured for using a push policy shared with the server device in order to determine second media data to be sent by the server device without having been requested by the client device or to determine an order of transmission thereof by the server device.</div>
<div class="description-paragraph" id="p-0077" num="0099">The server and client devices have the same advantages as the corresponding methods as described above.</div>
<div class="description-paragraph" id="p-0078" num="0100">Optional features of the methods and devices are defined in the dependent claims. Some of them are explained below with respect to the methods. However they can also apply to the corresponding device.</div>
<div class="description-paragraph" id="p-0079" num="0101">In some embodiments referred below as to an explicit approach, the method from the server's perspective further comprises:</div>
<div class="description-paragraph" id="p-0080" num="0102">determining by the server device a push policy, and</div>
<div class="description-paragraph" id="p-0081" num="0103">transmitting, from the server device to the client device, push policy information describing the determined push policy to share the push policy with the client device.</div>
<div class="description-paragraph" id="p-0082" num="0104">Correspondingly at the client side, the method may further comprise receiving, from the server device, push policy information describing the shared push policy.</div>
<div class="description-paragraph" id="p-0083" num="0105">As described in some examples below, the push policy information describing the shared push policy is inserted in a description file that is transmitted from the server device to the client device, the description file containing description information that concerns media data including the first media data, the method further comprising determining the second non-requested media data based on said description file using the shared push policy.</div>
<div class="description-paragraph" id="p-0084" num="0106">In a specific embodiment, the description file describes the media data using a plurality of media data attribute levels, and various shared push policies are defined at various respective levels of the description file.</div>
<div class="description-paragraph" id="p-0085" num="0107">In other examples, the push policy information describing the shared push policy is embedded in a header of an HTTP frame transmitted from the server device to the client device.</div>
<div class="description-paragraph" id="p-0086" num="0108">According to specific features, the method may further comprise, at the server device, receiving push policy update information embedded in a header of an HTTP frame from the client device, and updating accordingly the shared push policy before determining non-requested media data from other media data requested by the client device.</div>
<div class="description-paragraph" id="p-0087" num="0109">Correspondingly, the method may further comprise, at the client device, sending push policy update information embedded in a header of an HTTP frame to the server device.</div>
<div class="description-paragraph" id="p-0088" num="0110">According to a hybrid approach, the push policy information describing the shared push policy is defined by a first push policy part and a second push policy part,</div>
<div class="description-paragraph" id="p-0089" num="0111">the first push policy part being inserted in a description file that is transmitted from the server device to the client device, the description file containing description information that concerns media data including the first media data, the method further comprising determining the second non-requested media data based on said description file using the shared push policy,</div>
<div class="description-paragraph" id="p-0090" num="0112">and the second push policy part being embedded in a header of an HTTP frame transmitted from the server device to the client device.</div>
<div class="description-paragraph" id="p-0091" num="0113">For example, the second push policy part may comprise one or more values for one or more associated variables defined in the first push policy part.</div>
<div class="description-paragraph" id="p-0092" num="0114">Also, the description file may include the description of a plurality of candidate push policies, and the second push policy part may thus comprise an identifier of a candidate push policy from said plurality, which identified candidate push policy thereby forming the first push policy part.</div>
<div class="description-paragraph" id="p-0093" num="0115">In other embodiments, the push policy information includes a JavaScript program embedded in a web page transmitted from the server device to the client device.</div>
<div class="description-paragraph" id="p-0094" num="0116">In yet other embodiments, the method further comprises determining the second non-requested media data based on a structured document (such as a description file described above or an HTML page introduced in examples below), the structured document containing description information that concerns media data including the first media data, and</div>
<div class="description-paragraph" id="p-0095" num="0117">the push policy information includes an XPath expression to be evaluated on a tree representation of the structured document to identify the second non-requested media data.</div>
<div class="description-paragraph" id="p-0096" num="0118">Regarding the syntax of the push policy information, embodiments provide that the push policy information includes a first push attribute defining an amount of second non-requested media data to be identified in a description file,</div>
<div class="description-paragraph" id="p-0097" num="0119">the description file containing description information that concerns media data including the first media data, and the method further comprising determining the second non-requested media data based on said description file using the shared push policy.</div>
<div class="description-paragraph" id="p-0098" num="0120">According to specific features, the first push attribute identifies the second non-requested media data relatively to the first media data requested within the description file. This may be done using operators as described below.</div>
<div class="description-paragraph" id="p-0099" num="0121">In a variant, the first push attribute is an identifier of specific media data within the description file.</div>
<div class="description-paragraph" id="p-0100" num="0122">According to specific features, the description information in the description file describes media data according to at least one media data attribute from amongst a period attribute defining a time period to which the media data belong, an adaptation attribute defining a media type of the media data, a representation attribute defining an encoding version (e.g. bitrate, frame rate, frame resolution, timing information, etc.) of the media data and a segment attribute defining, and</div>
<div class="description-paragraph" id="p-0101" num="0123">the push policy information includes at least a second push attribute defining a constraint on the media data attribute or attributes, for identifying the second non-requested media data.</div>
<div class="description-paragraph" id="p-0102" num="0124">This makes it possible to have very selective push policies throughout the description file.</div>
<div class="description-paragraph" id="p-0103" num="0125">In particular, the push attribute or attributes may define a media data attribute or attributes of the second non-requested media data relatively to the corresponding media data attribute or attributes of the first media data within the description file.</div>
<div class="description-paragraph" id="p-0104" num="0126">Alternatively, the push attribute or attributes may identify a node in the description file in which the second non-requested media data have to be retrieved.</div>
<div class="description-paragraph" id="p-0105" num="0127">In some embodiments, the description information in the description file includes priority attributes associated with the media data, one priority attribute for each media data, and an order of transmission of the second media data is based on the associated priority attributes. This is to define an order of transmission of the push data.</div>
<div class="description-paragraph" id="p-0106" num="0128">In embodiments, the shared push policy identifies the second media data from the first media data requested.</div>
<div class="description-paragraph" id="p-0107" num="0129">In embodiments referred below as to an implicit approach, the shared push policy is implemented using the same second media data determining algorithm at both the server device and the client device, the algorithm enabling the server device and the client device to determine the same second media data from the first media data requested.</div>
<div class="description-paragraph" id="p-0108" num="0130">In some embodiments adapted to both the implicit and explicit approaches, if the identified second media data comprise a plurality of media segments, each requiring an announcement message, the method may further comprise merging the corresponding plurality of announcement messages into a single announcement message to be transmitted to the client device. This is to reduce bandwidth consumption since less announcement messages will be sent.</div>
<div class="description-paragraph" id="p-0109" num="0131">To take actual advantage of the shared push policy and consequent anticipation of pushes by the client device, the method may further comprise receiving, from the client device, a cancellation request requesting to cancel transmission of a part of the second non-requested media data so that the server device does not transmit the corresponding prepared announcement message.</div>
<div class="description-paragraph" id="p-0110" num="0132">Correspondingly at the client, the method may further comprise sending, to the server device, a cancellation request requesting to cancel transmission of a part of the second non-requested media data, in order to drive the server device not to transmit an announcement message identifying the part of the second non-requested media data.</div>
<div class="description-paragraph" id="p-0111" num="0133">In embodiments of the invention, the second non-requested media data are determined by the client device independently of at least one announcement message prepared by (and possibly received from) the server device and identifying the second non-requested media data the server device intends to send to the client device without having been requested. Here, “independently” means that the client device is able to make the determination of the second non-requested data without being aware of such announcement message (i.e. PUSH_PROMISE) which is dedicated to inform the client device of the future transmission of such non-requested data.</div>
<div class="description-paragraph" id="p-0112" num="0134">In other embodiments of the invention, the same shared push policy is used for determining respective non-requested media data from a plurality of requests relating to respective first media data. By using the same push policy over time and successive requests, the client is even more in good position to efficiently anticipate the transmission of useless data by the server, and thus in position to efficiently cancel their transmission and the transmission of corresponding announcement messages.</div>
<div class="description-paragraph" id="p-0113" num="0135">Regarding the notification of an order of transmission of the push data from the server to the client, a method of streaming media data by a server device to a client device, may comprise the following steps:
</div> <ul> <li id="ul0015-0001" num="0000"> <ul> <li id="ul0016-0001" num="0136">receiving, from the client device, a request relating to first media data,</li> <li id="ul0016-0002" num="0137">identifying second media data to be sent to the client device without having been requested,</li> <li id="ul0016-0003" num="0138">transmitting to said client device, in response to said request, data relating to said first media data, and at least one announcement message respectively identifying said second media data, and</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0114" num="0139">wherein the method further comprises the following steps:
</div> <ul> <li id="ul0017-0001" num="0000"> <ul> <li id="ul0018-0001" num="0140">defining by the server device an order of transmission of the second media data (this form all or part of the shared push policy),</li> <li id="ul0018-0002" num="0141">transmitting information related to the order of transmission with said announcement messages, said information enabling the client device to determine the order of transmission defined by the server.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0115" num="0142">For example, the order of transmission of said second media is defined according to priority values according to the client device, the media data having the highest priority value being transmitted first.</div>
<div class="description-paragraph" id="p-0116" num="0143">Said priority values may be defined according to the HTTP/2 protocol.</div>
<div class="description-paragraph" id="p-0117" num="0144">According to embodiments, at least one priority value is associated with a network bandwidth estimation mechanism, and the method further comprises the following steps:
</div> <ul> <li id="ul0019-0001" num="0000"> <ul> <li id="ul0020-0001" num="0145">transmitting to the client device second media data with a priority value associated with said mechanism,</li> <li id="ul0020-0002" num="0146">receiving from the client device, in response to said second media data, at least one control flow message, and</li> <li id="ul0020-0003" num="0147">estimating an available bandwidth based on said at least one control flow message received.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0118" num="0148">For example, the server device transmits said second media data according to a plurality of data frames having respective and different sizes.</div>
<div class="description-paragraph" id="p-0119" num="0149">The method may further comprise defining by the server device, based on said bandwidth estimation, an updated order of transmission of the second media data.</div>
<div class="description-paragraph" id="p-0120" num="0150">According to embodiments said request from the client device comprises a request for receiving a description file related to media data comprising said first media data, the description file containing description information concerning said first media data, the method further comprising determining the second non-requested media data based on said description file.</div>
<div class="description-paragraph" id="p-0121" num="0151">For example, requested first media data are video segments.</div>
<div class="description-paragraph" id="p-0122" num="0152">The streaming may be performed according to the DASH standard.</div>
<div class="description-paragraph" id="p-0123" num="0153">For example, the method further comprises the following steps:
</div> <ul> <li id="ul0021-0001" num="0000"> <ul> <li id="ul0022-0001" num="0154">receiving, from the client device, an ordering update request,</li> <li id="ul0022-0002" num="0155">defining, based on said ordering update request, a new order of transmission of the second media data and updating the information related to said new order of transmission of the second media data, and</li> <li id="ul0022-0003" num="0156">transmitting said second media data to the client according to said updated information related to the order of transmission.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0124" num="0157">The method may further comprise transmitting to the client device, an ordering update confirmation message.</div>
<div class="description-paragraph" id="p-0125" num="0158">For example, said updated order is defined for the second media data for which transmission to the client device has not been initiated at the time of receipt of said ordering update request.</div>
<div class="description-paragraph" id="p-0126" num="0159">For example, said ordering update request comprises an ordering value for at least part of second media data.</div>
<div class="description-paragraph" id="p-0127" num="0160">According to embodiments, the order of transmission of said second media is defined according to priority values, and when a priority value is updated for at least part of a first media data, the priority values for at least part of second media data to be sent to the client device without having been requested and associated with said at least part of first media data, are updated accordingly.</div>
<div class="description-paragraph" id="p-0128" num="0161">For example, said first and second media are associated according to at least one of a temporal relationship, a spatial relationship and a quality relationship.</div>
<div class="description-paragraph" id="p-0129" num="0162">According to embodiments:
</div> <ul> <li id="ul0023-0001" num="0000"> <ul> <li id="ul0024-0001" num="0163">said second media data comprises enhancement data for enhancing quality of the first media data, and</li> <li id="ul0024-0002" num="0164">when a priority value is updated for a media data of an enhancement layer, priority values are updated for all the media data of said enhancement layer.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0130" num="0165">For example, the first and second media data comprise video temporal segments, and the starting time of the enhancement media data is based on information related to a video content of the first media data.</div>
<div class="description-paragraph" id="p-0131" num="0166">For example, said information related to a video content of the first media data is stored in said description file.</div>
<div class="description-paragraph" id="p-0132" num="0167">For example, said order of transmission is based at least on decoding relationships between first a second media data.</div>
<div class="description-paragraph" id="p-0133" num="0168">For example, said order of transmission is based at least on statistical popularities of the media data.</div>
<div class="description-paragraph" id="p-0134" num="0169">For example, said order of transmission is based at least on a playing time of the media data on the client device's end.</div>
<div class="description-paragraph" id="p-0135" num="0170">For example, said order of transmission is based at least on an estimated transmission time of the media data.</div>
<div class="description-paragraph" id="p-0136" num="0171">For example, said order of transmission is based at least on user-defined interests for the media data.</div>
<div class="description-paragraph" id="p-0137" num="0172">The method may further comprise the following steps:
</div> <ul> <li id="ul0025-0001" num="0000"> <ul> <li id="ul0026-0001" num="0173">receiving, from the client device, control messages, said control messages enabling the server device to identify media data currently being played,</li> <li id="ul0026-0002" num="0174">defining by the server, based on said control messages, an updated order of transmission of the second media data, and</li> <li id="ul0026-0003" num="0175">transmitting said second media data to the client according to said updated order of transmission.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0138" num="0176">The method may further comprise a step of transmitting to the client device, an ordering update confirmation message.</div>
<div class="description-paragraph" id="p-0139" num="0177">For example, said control messages relate to a use of a buffer memory of the client device, said buffer memory storing media data for them to be played by the client.</div>
<div class="description-paragraph" id="p-0140" num="0178">For example, the server device keeps record of first requested media data sent, and identification of the second media data is performed based on said use of the buffer memory and said record.</div>
<div class="description-paragraph" id="p-0141" num="0179">For example, said order of transmission information is transmitted within said announcement messages.</div>
<div class="description-paragraph" id="p-0142" num="0180">For example, said order of transmission information is transmitted within dedicated messages after said announcement messages.</div>
<div class="description-paragraph" id="p-0143" num="0181">From the client's perspective, a method of accessing by a client device, media data streamed by a server device, may comprise the following steps:
</div> <ul> <li id="ul0027-0001" num="0000"> <ul> <li id="ul0028-0001" num="0182">transmitting, to the server device, a request relating to first media data,</li> <li id="ul0028-0002" num="0183">receiving from said server device, in response to said request, data relating to said first media data, and at least one announcement message respectively identifying second media to be sent to the client device without having been requested, wherein the method further comprises the following steps:</li> <li id="ul0028-0003" num="0184">receiving information related to an order of transmission of the second media data with said announcement messages, said information (i.e. the shared push policy) enabling the client device to determine an order of transmission of the second media data defined by the server.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0144" num="0185">The method may further comprise determining by the client device whether the order of transmission of the second media data defined by the server device satisfies streaming constraints at the client device's end, and if said constraints are not satisfied, transmitting, to the server device, an ordering update request.</div>
<div class="description-paragraph" id="p-0145" num="0186">For example, the order of transmission of said second media data is defined according to priority values according to the client device, the media data having the highest priority value being transmitted first.</div>
<div class="description-paragraph" id="p-0146" num="0187">For example, said priority values are defined according to the HTTP/2 protocol.</div>
<div class="description-paragraph" id="p-0147" num="0188">According to embodiments, at least one priority value is associated with a network bandwidth estimation mechanism, the method further comprises the following steps:
</div> <ul> <li id="ul0029-0001" num="0000"> <ul> <li id="ul0030-0001" num="0189">receiving from the server device second media data with a priority value associated with said mechanism,</li> <li id="ul0030-0002" num="0190">transmitting to said server device, in response to said second media data, at least one control flow message, thereby enabling the server device to estimate an available bandwidth based on said at least one control flow message transmitted.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0148" num="0191">For example, the client device receives said second media data according to a plurality of data frames having respective and different sizes.</div>
<div class="description-paragraph" id="p-0149" num="0192">For example, an updated order of transmission of the second media data is defined, by the server device, based on said bandwidth estimation.</div>
<div class="description-paragraph" id="p-0150" num="0193">For example, said request from the client device comprises a request for receiving a description file related to media data comprising said first media data, the description file containing description information concerning said first media data, the method further comprising determining the second non-requested media data based on said description file.</div>
<div class="description-paragraph" id="p-0151" num="0194">For example, requested first media data are video segments.</div>
<div class="description-paragraph" id="p-0152" num="0195">For example, said streaming is performed according to the DASH standard.</div>
<div class="description-paragraph" id="p-0153" num="0196">The method may further comprise receiving said second media data from the server device according to updated information related to a new order of transmission of the second media data defined by the server device.</div>
<div class="description-paragraph" id="p-0154" num="0197">The method may further comprise a step of receiving from the server device, an ordering update confirmation message.</div>
<div class="description-paragraph" id="p-0155" num="0198">According to embodiments, said updated order is defined for the second media data for which transmission from the server device has not been initiated at the time of receipt of said ordering update request by the server device.</div>
<div class="description-paragraph" id="p-0156" num="0199">According to embodiments, said ordering update request comprises an ordering value for at least part of the second media data.</div>
<div class="description-paragraph" id="p-0157" num="0200">According to embodiments, the order of transmission of said second media is defined according to priority values, and when a priority value is updated for at least part of a first media data, the priority values for at least part of second media data to be sent to the client device without having been requested and associated with said at least part of first media data, are updated accordingly.</div>
<div class="description-paragraph" id="p-0158" num="0201">For example, said first and second media data are related according to at least one of a temporal relationship, a spatial relationship and a quality relationship.</div>
<div class="description-paragraph" id="p-0159" num="0202">According to embodiments:
</div> <ul> <li id="ul0031-0001" num="0000"> <ul> <li id="ul0032-0001" num="0203">said second media data comprise enhancement data for enhancing quality of the first media data, and</li> <li id="ul0032-0002" num="0204">when a priority value is updated for at least part of first media data of an enhancement layer, priority values are updated for all the media data of said enhancement layer.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0160" num="0205">For example, the first and second media data comprise video temporal segments, and the starting time of the enhancement media data is based on information related to a video content of the first media data.</div>
<div class="description-paragraph" id="p-0161" num="0206">According to embodiments, said information related to a video content of the first media data is stored in said description file.</div>
<div class="description-paragraph" id="p-0162" num="0207">According to embodiments, said order of transmission is based at least on decoding relationships between first and second media data.</div>
<div class="description-paragraph" id="p-0163" num="0208">According to embodiments, said order of transmission is based at least on statistical popularities of the media data.</div>
<div class="description-paragraph" id="p-0164" num="0209">According to embodiments, said order of transmission is based at least on a playing time of the media data on the client device's end.</div>
<div class="description-paragraph" id="p-0165" num="0210">According to embodiments, said order of transmission is based at least on an estimated transmission time of the media data.</div>
<div class="description-paragraph" id="p-0166" num="0211">According to embodiments, said order of transmission is based at least on user-defined interests for the media data.</div>
<div class="description-paragraph" id="p-0167" num="0212">The method may comprise the following steps:
</div> <ul> <li id="ul0033-0001" num="0000"> <ul> <li id="ul0034-0001" num="0213">transmitting, to the server device, control messages, said control message enabling the server device to identify a media data currently being played, and</li> <li id="ul0034-0002" num="0214">receiving said second media data from the server device according to an updated order of transmission defined, by the server device, based on said control messages.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0168" num="0215">The method may comprise a step of receiving from the server device, an ordering update confirmation message.</div>
<div class="description-paragraph" id="p-0169" num="0216">For example, said control messages relate to a use of a buffer memory of the client device, said buffer memory storing media data for them to be played by the client device.</div>
<div class="description-paragraph" id="p-0170" num="0217">According to embodiments, the server device keeps record of first media data sent, and identification of the media being currently played is performed based on said use of the buffer memory and said record.</div>
<div class="description-paragraph" id="p-0171" num="0218">For example, said order of transmission information is received within said announcement messages.</div>
<div class="description-paragraph" id="p-0172" num="0219">For example, said order of transmission information is received within dedicated messages after said announcement messages.</div>
<div class="description-paragraph" id="p-0173" num="0220">Still referring to the order of transmission, a method of managing, by a proxy server, data exchanges between client devices and server devices, may comprise the following steps:
</div> <ul> <li id="ul0035-0001" num="0000"> <ul> <li id="ul0036-0001" num="0221">receiving, from a server implementing a method as defined above regarding the notification of an order of transmission, media data to be retransmitted to a client device,</li> <li id="ul0036-0002" num="0222">determining, based on the order of transmission of the media data, a retransmission priority for the media data, and</li> <li id="ul0036-0003" num="0223">performing retransmission of the media data received to the client device, based on said transmission priority determined.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0174" num="0224">The method may further comprise storing said media data received, based on said retransmission priority determined.</div>
<div class="description-paragraph" id="p-0175" num="0225">The method may further comprise the following steps:
</div> <ul> <li id="ul0037-0001" num="0000"> <ul> <li id="ul0038-0001" num="0226">receiving, from a client device implementing a method according to the second aspect, an ordering update request,</li> <li id="ul0038-0002" num="0227">updating said retransmission priority according to said ordering update request, if said request is related to a media data to be retransmitted, and</li> <li id="ul0038-0003" num="0228">performing retransmission of the media data according to the updated retransmission priority.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0176" num="0229">The method may further comprise the following steps:
</div> <ul> <li id="ul0039-0001" num="0000"> <ul> <li id="ul0040-0001" num="0230">receiving from a first client device, a request to a first server device, for media data, wherein said media data is stored by the proxy server for retransmission to a second client device from a second server device,</li> <li id="ul0040-0002" num="0231">determining priority values respectively associated with said media data by said first and second server devices,</li> <li id="ul0040-0003" num="0232">updating said priority values according to respective streaming constraints for the first and second client devices, and</li> <li id="ul0040-0004" num="0233">retransmitting said media data to said first and second client devices according to said updated priority values,
<br/>
wherein said first and second server devices implement a method according to the first aspect and said first and second client devices implement a method according to the second aspect.
</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0177" num="0234">The method may further comprise sending to the first and second server devices update notifications relating to the updated priority values.</div>
<div class="description-paragraph" id="p-0178" num="0235">According to another aspect of the invention there is provided a method of streaming data between a server device and a client device comprising:
</div> <ul> <li id="ul0041-0001" num="0000"> <ul> <li id="ul0042-0001" num="0236">performing a method according to the first aspect by a server device, and</li> <li id="ul0042-0002" num="0237">performing a method according to the second aspect by a client device.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0179" num="0238">According to yet another aspect of the invention there are provided computer programs and computer program products comprising instructions for implementing methods as defined above, when loaded and executed on computer means of a programmable apparatus.</div>
<div class="description-paragraph" id="p-0180" num="0239">According to yet another aspect of the invention, there is provided a server device configured for implementing methods according to the first aspect.</div>
<div class="description-paragraph" id="p-0181" num="0240">According to yet another aspect of the invention, there is provided a client device configured for implementing methods according to the second aspect.</div>
<div class="description-paragraph" id="p-0182" num="0241">Solutions for adaptive streaming of media data from a server to a client device have been proposed, in order to adapt in particular the type and quantity of data that are sent to the client device to the features of the concerned client device and to the characteristics of the networks providing the connection between the server and the client device.</div>
<div class="description-paragraph" id="p-0183" num="0242">In this context, some solutions, such as the DASH (Dynamic Adaptive Streaming over HTTP) standard, propose to store a plurality of versions of the resource (or content) to be distributed and to send to a client device requesting the resource a description file including a description of the various versions representing the resource and respective pointers (e.g. URLs) to these versions.</div>
<div class="description-paragraph" id="p-0184" num="0243">Based on the description file, the client device can then select a version of the resource that best matches its needs and request this version using the corresponding pointer.</div>
<div class="description-paragraph" id="p-0185" num="0244">This solution is advantageous in that the description file is light as it contains no media data (but only pointers to media data). It avoids the exchange of media data that would be unsuitable for the client device by letting the client select relevant versions for its usage. Moreover it fits in the current Web architecture based on HTTP and can exploit caching mechanisms already deployed.</div>
<div class="description-paragraph" id="p-0186" num="0245">In return, this solution however needs several exchanges (or roundtrips) between the client device and the server before media data is received at the client device and may then be decoded and displayed, which results in a start-up delay</div>
<div class="description-paragraph" id="p-0187" num="0246">In embodiments, the invention provides a method for providing media data representing a media item (e.g. a video) from a server storing data representing the media item, at least a temporal segment of which is represented by a plurality of versions, the method comprising the following steps implemented by the server:
</div> <ul> <li id="ul0043-0001" num="0000"> <ul> <li id="ul0044-0001" num="0247">receiving a request from a client device for a description file including a description of the versions representing the temporal segment and respective pointers to the versions representing the temporal segment;</li> <li id="ul0044-0002" num="0248">selecting data among sets of data pointed to in the description file;</li> <li id="ul0044-0003" num="0249">sending the description file to the client device;</li> <li id="ul0044-0004" num="0250">pushing the selected data to the client device.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0188" num="0251">By pushing data selected in an appropriate manner (i.e. sending data that is not solicited by the client device, but has been selected by the server as further explained below), one or several roundtrip(s) can be avoided and the decoding and display of the media data can thus start faster.</div>
<div class="description-paragraph" id="p-0189" num="0252">The media item may for instance be a video, or an audio item, such as an audio track, for instance.</div>
<div class="description-paragraph" id="p-0190" num="0253">It may be noted that the sets of data mentioned above include the versions representing the temporal segments, but may as well include other data such as initialization data, as explained below.</div>
<div class="description-paragraph" id="p-0191" num="0254">As just noted, the selected data may include initialization data for a decoder of the client device. The decoder can thus be initialized without the client device having to specifically request for the initialization data, and thus faster.</div>
<div class="description-paragraph" id="p-0192" num="0255">As noted above, the selected data may also include at least part of one of said versions representing the temporal segment.</div>
<div class="description-paragraph" id="p-0193" num="0256">The step of selecting data may include estimating a quantity of data (e.g. video data) to be pushed, which may then be used when deciding which data are to be selected. The quantity may be estimated based on a buffer time defined in the description file and/or based on a bandwidth estimation determined by the server.</div>
<div class="description-paragraph" id="p-0194" num="0257">The step of selecting data may be performed based on at least one preference included in the request and/or based on usage data derived from prior exchanges between the server and the client device and/or based on an analysis of the description file by the server and/or based on a table stored in the server and associated with the description file.</div>
<div class="description-paragraph" id="p-0195" num="0258">According to a possible embodiment, it may be provided a step of sending a push promise related to and prior to the step of pushing the selected data. The client device may thus be informed of the data to be pushed, before actually receiving these data.</div>
<div class="description-paragraph" id="p-0196" num="0259">The step of sending the push promise may be performed prior to the step of sending the description file, which makes it possible to inform the client device at an early stage.</div>
<div class="description-paragraph" id="p-0197" num="0260">The push promise includes for instance an identification of the selected data.</div>
<div class="description-paragraph" id="p-0198" num="0261">According to a proposed embodiment, the server determines a confidence level associated to the selected data and the push promise includes the determined confidence level.</div>
<div class="description-paragraph" id="p-0199" num="0262">According to a possible implantation explained in the detail description given below, the server may store a hierarchical representation of blocks of data forming the selected data. In such a case, the following steps may be provided:
</div> <ul> <li id="ul0045-0001" num="0000"> <ul> <li id="ul0046-0001" num="0263">receiving from the client device an instruction for not pushing a block of data;</li> <li id="ul0046-0002" num="0264">cancelling the pushing of said block of data and of blocks of data connected to said block of data in the hierarchical representation.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0200" num="0265">The proposed method may include a step of determining a level of confidence associated with the selected data; then:
</div> <ul> <li id="ul0047-0001" num="0000"> <ul> <li id="ul0048-0001" num="0266">if the determined level of confidence is below a predetermined threshold, pushing the selected data includes pushing only initialization data for a decoder of the client device;</li> <li id="ul0048-0002" num="0267">if the determined level of confidence is above the predetermined threshold, pushing the selected data includes pushing initialization data for a decoder of the client device and at least part of one of said versions representing the temporal segment.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0201" num="0268">Embodiments of the invention also provide a method for receiving media data representing a media item (e.g. a video) from a server storing data representing the media item, at least a temporal segment of which is represented by a plurality of versions, the method comprising the following steps implemented by a client device:
</div> <ul> <li id="ul0049-0001" num="0000"> <ul> <li id="ul0050-0001" num="0269">sending a request to the server for a description file including a description of the versions representing the temporal segment and respective pointers to the versions representing the temporal segment;</li> <li id="ul0050-0002" num="0270">receiving the description file from the server, the description file containing pointers to sets of data;</li> <li id="ul0050-0003" num="0271">receiving unsolicited data from the server, wherein said unsolicited data belong to said sets of data.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0202" num="0272">As noted above, the unsolicited data may include initialization data for a decoder of the client device (in which case a step of initializing the decoder with said unsolicited data may be provided) and/or at least part of one of said versions representing the temporal segment (in which case a step of decoding at least part of the unsolicited data may be provided).</div>
<div class="description-paragraph" id="p-0203" num="0273">The request may include at least one preference defining decoding at the client device, which may help the server in determining the media data to be pushed.</div>
<div class="description-paragraph" id="p-0204" num="0274">The request may also include an indicator that the client device accepts pushed data, based on which the server may effectively decide to push data.</div>
<div class="description-paragraph" id="p-0205" num="0275">As explained above, it may be provided a step of receiving a push promise related to and prior to the step of receiving the unsolicited data. This step of receiving the push promise may occur prior to the step of receiving the description file.</div>
<div class="description-paragraph" id="p-0206" num="0276">The push promise may include an identification of the unsolicited data and/or a level of confidence associated with the unsolicited data.</div>
<div class="description-paragraph" id="p-0207" num="0277">The following steps may be provided at the client device:
</div> <ul> <li id="ul0051-0001" num="0000"> <ul> <li id="ul0052-0001" num="0278">determining acceptance or refusal of a push promise based on data included in the push promise;</li> <li id="ul0052-0002" num="0279">sending an instruction for not pushing said unsolicited data in case of refusal.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0208" num="0280">The following steps may also be used:
</div> <ul> <li id="ul0053-0001" num="0000"> <ul> <li id="ul0054-0001" num="0281">determining acceptance or refusal of a push promise based on a level of confidence associated with the unsolicited data and included in the push promise;</li> <li id="ul0054-0002" num="0282">sending an instruction for not pushing said unsolicited data in case of refusal.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0209" num="0283">A step of buffering said unsolicited data upon receipt, before decoding these data, may be used.</div>
<div class="description-paragraph" id="p-0210" num="0284">As pushed data are meant to correspond only to initialization data and/or initial media data, the following steps may be implemented:
</div> <ul> <li id="ul0055-0001" num="0000"> <ul> <li id="ul0056-0001" num="0285">determining data (e.g. video data) to be requested (i.e. not planned to be pushed) based on the description file and on data included in the push promise;</li> <li id="ul0056-0002" num="0286">sending a request for the determined data to the server.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0211" num="0287">Embodiments of the invention also propose a method for streaming media data representing a media item (e.g. a video) from a server storing data representing the media item to a client device, at least a temporal segment of the media item being represented by a plurality of versions, the method comprising the following steps:
</div> <ul> <li id="ul0057-0001" num="0000"> <ul> <li id="ul0058-0001" num="0288">the client device sending a request to the server for a description file including a description of the versions representing the temporal segment and respective pointers to the versions representing the temporal segment;</li> <li id="ul0058-0002" num="0289">the server receiving the request from the client device;</li> <li id="ul0058-0003" num="0290">the server selecting data among sets of data pointed to in the description file;</li> <li id="ul0058-0004" num="0291">the server sending the description file to the client device;</li> <li id="ul0058-0005" num="0292">the server pushing the selected data to the client device;</li> <li id="ul0058-0006" num="0293">the client device receiving the description file from the server;</li> <li id="ul0058-0007" num="0294">the client device receiving the selected data from the server.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0212" num="0295">Embodiments of the invention also provide a device for providing media data representing a media item (e.g. a video) from a server, the server storing data representing the media item, at least a temporal segment of which is represented by a plurality of versions, and comprising:
</div> <ul> <li id="ul0059-0001" num="0000"> <ul> <li id="ul0060-0001" num="0296">a receiver configured to receive a request from a client device for a description file including a description of the versions representing the temporal segment and respective pointers to the versions representing the temporal segment;</li> <li id="ul0060-0002" num="0297">a selection module configured to select data among sets of data pointed to in the description file;</li> <li id="ul0060-0003" num="0298">a module configured to send the description file to the client device;</li> <li id="ul0060-0004" num="0299">a module configured to push the selected data to the client device.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0213" num="0300">Embodiments of the invention also provide a device for receiving media data representing a media item (e.g. a video) from a server storing data representing the media item, at least a temporal segment of which is represented by a plurality of versions, the device comprising:
</div> <ul> <li id="ul0061-0001" num="0000"> <ul> <li id="ul0062-0001" num="0301">a module configured to send a request to the server for a description file including a description of the versions representing the temporal segment and respective pointers to the versions representing the temporal segment;</li> <li id="ul0062-0002" num="0302">a module configured to receive the description file from the server, the description file containing pointers to sets of data;</li> <li id="ul0062-0003" num="0303">a module configured to receive unsolicited data from the server, wherein said unsolicited data belong to said sets of data.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0214" num="0304">Lastly, embodiments of the invention provide a system comprising a server and a client device for streaming media data representing media item (e.g. a video) from the server storing data representing the media item to the client device, at least a temporal segment of the media item being represented by a plurality of versions,
</div> <ul> <li id="ul0063-0001" num="0000"> <ul> <li id="ul0064-0001" num="0305">the client device comprising a module configured to send a request to the server for a description file including a description of the versions representing the temporal segment and respective pointers to the versions representing the temporal segment;</li> <li id="ul0064-0002" num="0306">the server comprising a module configured to receive the request from the client device, a selection module configured to select data among sets of data pointed to in the description file, a module configured to send the description file to the client device and a module configured to push the selected data to the client device;</li> <li id="ul0064-0003" num="0307">the client device comprising a module configured to receive the description file from the server and a module configured to receive the selected data from the server.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0215" num="0308">Optional features proposed above for the method for providing media data and the method for receiving media data also apply to the method for streaming media data and to the various devices and system just mentioned.</div>
<description-of-drawings>
<heading id="h-0005">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<div class="description-paragraph" id="p-0216" num="0309">Other features and advantages of the invention will become apparent from the following description of non-limiting exemplary embodiments, with reference to the appended drawings:</div>
<div class="description-paragraph" id="p-0217" num="0310"> <figref idrefs="DRAWINGS">FIG. 1<i>a </i> </figref>illustrates a graph of a set of resources owned by a server;</div>
<div class="description-paragraph" id="p-0218" num="0311"> <figref idrefs="DRAWINGS">FIG. 1<i>b </i> </figref>illustrate an HTTP exchange without using a server PUSH feature;</div>
<div class="description-paragraph" id="p-0219" num="0312"> <figref idrefs="DRAWINGS">FIG. 1<i>c </i> </figref>illustrates an HTTP exchange using a feature of pushing directly connected sub-resources by the server;</div>
<div class="description-paragraph" id="p-0220" num="0313"> <figref idrefs="DRAWINGS">FIG. 1<i>d </i> </figref>illustrates a flowchart of an exemplary mode of operation on a client side;</div>
<div class="description-paragraph" id="p-0221" num="0314"> <figref idrefs="DRAWINGS">FIG. 1<i>e </i> </figref>illustrates a flowchart of an exemplary mode of operation of a server implementing a push feature;</div>
<div class="description-paragraph" id="p-0222" num="0315"> <figref idrefs="DRAWINGS">FIG. 2</figref> illustrates exchanging multiple request and response priorities in parallel;</div>
<div class="description-paragraph" id="p-0223" num="0316"> <figref idrefs="DRAWINGS">FIG. 3</figref> is a block diagram illustrating Media streaming over HTTP;</div>
<div class="description-paragraph" id="p-0224" num="0317"> <figref idrefs="DRAWINGS">FIG. 4<i>a </i> </figref>illustrates the generation of the media presentation and the manifest file;</div>
<div class="description-paragraph" id="p-0225" num="0318"> <figref idrefs="DRAWINGS">FIG. 4<i>b </i> </figref>illustrates streaming protocol for MPEG/DASH;</div>
<div class="description-paragraph" id="p-0226" num="0319"> <figref idrefs="DRAWINGS">FIG. 5</figref> illustrates a Media Presentation Description (MPD) file;</div>
<div class="description-paragraph" id="p-0227" num="0320"> <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>illustrates a flowchart of various steps associated with a streaming session by a DASH client;</div>
<div class="description-paragraph" id="p-0228" num="0321"> <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>illustrates a tree representation of an exemplary manifest file;</div>
<div class="description-paragraph" id="p-0229" num="0322"> <figref idrefs="DRAWINGS">FIG. 6</figref> illustrates an example of a DASH manifest file;</div>
<div class="description-paragraph" id="p-0230" num="0323"> <figref idrefs="DRAWINGS">FIGS. 7<i>a </i>and 7<i>b </i> </figref>illustrate media segment reordering according to embodiments;</div>
<div class="description-paragraph" id="p-0231" num="0324"> <figref idrefs="DRAWINGS">FIG. 8</figref> is a flowchart of exemplary steps performed by servers according to embodiments;</div>
<div class="description-paragraph" id="p-0232" num="0325"> <figref idrefs="DRAWINGS">FIG. 9</figref> is a flowchart of exemplary steps performed by clients according to embodiments;</div>
<div class="description-paragraph" id="p-0233" num="0326"> <figref idrefs="DRAWINGS">FIG. 10</figref> is a flowchart of exemplary steps performed by proxies according to embodiments;</div>
<div class="description-paragraph" id="p-0234" num="0327"> <figref idrefs="DRAWINGS">FIG. 11</figref> illustrates bandwidth measurement according to embodiments;</div>
<div class="description-paragraph" id="p-0235" num="0328"> <figref idrefs="DRAWINGS">FIG. 12</figref> illustrates video playing initialization according to embodiments;</div>
<div class="description-paragraph" id="p-0236" num="0329"> <figref idrefs="DRAWINGS">FIG. 13</figref> is a schematic illustration of devices according to embodiments;</div>
<div class="description-paragraph" id="p-0237" num="0330"> <figref idrefs="DRAWINGS">FIG. 14<i>a </i> </figref>illustrates, using a flowchart, general steps of the invention at the client side;</div>
<div class="description-paragraph" id="p-0238" num="0331"> <figref idrefs="DRAWINGS">FIG. 14<i>b </i> </figref>illustrates, using a flowchart, general steps of the invention at the server side;</div>
<div class="description-paragraph" id="p-0239" num="0332"> <figref idrefs="DRAWINGS">FIG. 15<i>a </i> </figref>illustrates, using a flowchart, steps of determining the shared push policy at the client side based on the explicit approach;</div>
<div class="description-paragraph" id="p-0240" num="0333"> <figref idrefs="DRAWINGS">FIG. 15<i>b </i> </figref>illustrates, using a flowchart, steps of determining the push policy at the server side when the explicit approach is used;</div>
<div class="description-paragraph" id="p-0241" num="0334"> <figref idrefs="DRAWINGS">FIG. 16</figref> shows an MPD document in which a PushPolicy node is used to specify a push policy applied by the server;</div>
<div class="description-paragraph" id="p-0242" num="0335"> <figref idrefs="DRAWINGS">FIG. 17</figref> illustrates, using a flowchart, steps for identifying and marking some segments as ready to be pushed according to the shared push policy “Push Policy”;</div>
<div class="description-paragraph" id="p-0243" num="0336"> <figref idrefs="DRAWINGS">FIG. 18<i>a </i> </figref>illustrates an example of communication between a server and client with a push policy transmitted in a HTTP “push-policy” header;</div>
<div class="description-paragraph" id="p-0244" num="0337"> <figref idrefs="DRAWINGS">FIG. 18<i>b </i> </figref>illustrates the same example with a client's request to change the push policy;</div>
<div class="description-paragraph" id="p-0245" num="0338"> <figref idrefs="DRAWINGS">FIG. 19</figref> illustrates an MPD document with a push policy that indicates that the three segments following a requested segment will be pushed;</div>
<div class="description-paragraph" id="p-0246" num="0339"> <figref idrefs="DRAWINGS">FIG. 20</figref> illustrates, using a flowchart, steps of the process at the server side according to embodiments merging announcement messages;</div>
<div class="description-paragraph" id="p-0247" num="0340"> <figref idrefs="DRAWINGS">FIG. 21</figref> illustrates, using a flowchart, steps of the process at the server side when using HTTP headers to declare the push policy;</div>
<div class="description-paragraph" id="p-0248" num="0341"> <figref idrefs="DRAWINGS">FIG. 22</figref> illustrates, using a flowchart, steps of the process at the client side when using HTTP request to declare and share the push policy;</div>
<div class="description-paragraph" id="p-0249" num="0342"> <figref idrefs="DRAWINGS">FIG. 23</figref> shows an MPD document in which a SupplementalProperty element is used to specify a push policy applied by the server at a hierarchical level of the document;</div>
<div class="description-paragraph" id="p-0250" num="0343"> <figref idrefs="DRAWINGS">FIG. 24</figref> shows an MPD document used as example for an XPath based push policy;</div>
<div class="description-paragraph" id="p-0251" num="0344"> <figref idrefs="DRAWINGS">FIG. 25</figref> illustrates the reordering of elements in a priority tree, for example in a webpage, before applying a push policy;</div>
<div class="description-paragraph" id="p-0252" num="0345"> <figref idrefs="DRAWINGS">FIG. 26</figref> shows exemplary methods respectively implemented by a server and by a client device to obtain a DASH fast start in accordance with embodiments of the invention;</div>
<div class="description-paragraph" id="p-0253" num="0346"> <figref idrefs="DRAWINGS">FIG. 27</figref> describes an exemplary method implemented by a server for a DASH fast start; and</div>
<div class="description-paragraph" id="p-0254" num="0347"> <figref idrefs="DRAWINGS">FIG. 28</figref> describes a possible method implemented by a client device for a DASH fast start.</div>
</description-of-drawings>
<heading id="h-0006">DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION</heading>
<div class="description-paragraph" id="p-0255" num="0348">In what follows, embodiments of the invention are described in the context of DASH-based networks implementing the HTTP 2.0 protocol. The data streamed is, for example, video data. Embodiments of the invention are not limited to DASH networks.</div>
<div class="description-paragraph" id="p-0256" num="0349">A server device of a communication network that streams data to a client device implements a push feature according to which it can transmit data elements to the client without explicit requests from the client for the data elements transmitted.</div>
<div class="description-paragraph" id="p-0257" num="0350">The server and the client may share push policies that drive the server to determine the push promises and to actually transmit the corresponding data. Thanks to this sharing, the client may anticipate the push of some useless data, to cancel such push. This results in reducing the server's processing, as well as the network use since PUSH_PROMISE frames may be cancelled before being sent.</div>
<div class="description-paragraph" id="p-0258" num="0351">In specific embodiments, the server can indicate in its push promises, by which it announces transmission of the not explicitly requested data elements, ordering information concerning the order in which the server intend to transmit the data elements. The order of the data elements may be defined using priority values, for example the priority values according to HTTP/2.</div>
<div class="description-paragraph" id="p-0259" num="0352">Upon receipt of the push promises, the client device can determine in advance the order of transmission intended by the server, thereby enabling the client to react to the proposed order in case it does not match its own desired order. For example, the client device can update the priority values and send the updated priority values to the server. The server can thus change the transmission ordering based on the new priority values in order to better match the client's needs. The server can use the updated priorities into account for future data transmissions.</div>
<div class="description-paragraph" id="p-0260" num="0353">According to embodiments, the client may request a full reordering or a partial reordering of the transmission of the data elements to the server.</div>
<div class="description-paragraph" id="p-0261" num="0354">Full reordering is described with reference to <figref idrefs="DRAWINGS">FIG. 7<i>a</i> </figref>. A client requests, during a step <b>700</b>, a Media Presentation Description (MPD hereinafter) to a server. The server retrieves the MPD to send back to the client and identifies corresponding data elements to push during a step <b>701</b>. In the example of <figref idrefs="DRAWINGS">FIG. 7<i>a</i> </figref>, the server identifies “Data <b>1</b>.<b>1</b>”, “Data <b>1</b>.<b>2</b>” and “Data <b>1</b>.<b>3</b>” as data elements to push. These elements are for example data segments. Element “Data X.<b>1</b>” represents the base layer for data X, element “Data X.<b>2</b>” represents the enhancement layer for data X and “Data X.<b>3</b>” represents the additional enhancement layer for data X. The server defines a specific order of transmission for the data elements. The server associates respective priority values with the PUSH_PROMISE frames to be sent to the client for announcing the upcoming push data elements. The server then sends the PUSH_PROMISE frames “P<b>1</b>.<b>1</b>”, “P<b>1</b>.<b>2</b>” and “P<b>1</b>.<b>3</b>” with the associated priorities and the MPD during a step <b>702</b>. Next, shortly after sending the MPD and the push promise, during a step <b>703</b>, the server sends to the client a data frame corresponding to the “Data <b>1</b>.<b>1</b>” element and a PUSH_PROMISE messages “P<b>2</b>.<b>1</b>”, “P<b>2</b>.<b>2</b>” and “P<b>2</b>.<b>3</b>” respectively corresponding to the elements “Data <b>2</b>.<b>1</b>”, “Data <b>2</b>.<b>2</b>” and “Data <b>2</b>.<b>3</b>”, which are segments following “Data <b>1</b>.<b>1</b>”, “Data <b>1</b>.<b>2</b>” and “Data <b>1</b>.<b>3</b>” in the transmission order defined. In parallel to the receipt of the data frame and the push promise of step <b>703</b>, the client decides, after receipt of the MPD and the “P<b>1</b>.<b>1</b>”, “P<b>1</b>.<b>2</b>” and “P<b>1</b>.<b>3</b>” PUSH_PROMISE frames, that the enhancement layer “Data <b>1</b>.<b>2</b>” is of lower priority compared to the additional enhancement layer “Data <b>1</b>.<b>3</b>”. Thus, the client sends a priority update frame to lower “Data <b>1</b>.<b>2</b>” priority during a step <b>704</b>. Upon receipt of the priority update request, the server changes the schedule of the transmission during a step <b>705</b>. Hence, transmission of “Data <b>1</b>.<b>2</b>” is postponed after “Data <b>1</b>.<b>3</b>” is transmitted. In addition, the server uses the MPD to link the segments associated with “Data <b>1</b>.<b>2</b>”. It identifies “Data <b>2</b>.<b>2</b>” and lowers its priority as well.</div>
<div class="description-paragraph" id="p-0262" num="0355">Partial reordering is described with reference to <figref idrefs="DRAWINGS">FIG. 7<i>b</i> </figref>. Steps <b>710</b> to <b>714</b> of <figref idrefs="DRAWINGS">FIG. 7<i>b </i> </figref>are substantially the same as steps <b>700</b> to <b>704</b> of <figref idrefs="DRAWINGS">FIG. 7<i>a</i> </figref>. After receipt of the priority update frame, the server behaviour differs as compared to step <b>705</b> previously described. During step <b>715</b>, the server already started transmission of “Data <b>1</b>.<b>2</b>” and proceeds further with the transmission. For that segment, there is no change in the priority. The server nevertheless updates the priority of the connected segments, namely “Data <b>2</b>.<b>2</b>” in the present example. In order to announce the fact that the priority change has been taken into account, the server may send a priority update massage for “Data <b>2</b>.<b>2</b>”. The client can thus be informed of the change.</div>
<div class="description-paragraph" id="p-0263" num="0356">Embodiments of the invention may be implemented in use cases wherein servers can push high quality video parts well enough in advance so that the whole part of the video can be played as high quality. For instance, the video can be split into a part <b>1</b>, played as low quality, a part <b>2</b>, played as high quality and a part <b>3</b> played as low quality. The bandwidth between the client and server allows real-time streaming of low quality but not high quality. In that case, the server may interleave part <b>1</b> with the enhancement of part <b>2</b>. Once part <b>1</b> has been played, the enhanced part <b>2</b> is also available and the server sends the base layer of part <b>2</b> to be played as high quality jointly with the enhancement of the same part <b>2</b>. Thus, the server makes sure that the whole part <b>2</b> is played as high quality. Part <b>3</b> is sent thereafter. Quality flickering, which disturbs the user experience, can be alleviated and quality switching only occurs at a limited number of moments. The server is in the best position to know when to switch to a different quality level since it knows the video content.</div>
<div class="description-paragraph" id="p-0264" num="0357"> <figref idrefs="DRAWINGS">FIG. 8</figref> is a flowchart of steps performed by a server implementing a push-based DASH media streaming according to embodiments. Steps <b>800</b> to <b>812</b> describe the general principles. Steps <b>820</b> to <b>827</b> more specifically deal with the management of the priority feedback from the client.</div>
<div class="description-paragraph" id="p-0265" num="0358">During a step <b>800</b>, the server receives a request R from the client. This request identifies a specific media, typically by referring to an MPD file. Next, the server performs an iterative process comprising steps <b>801</b> to <b>810</b>. The process comprises sending data according to a defined order. The order of transmission is updated according to the client's feedback. Once the data are sent, they are received and played by the client. Next the server identifies new data to send and the process continues so on.</div>
<div class="description-paragraph" id="p-0266" num="0359">The first iteration starts with step <b>801</b>, during which the data to be sent are identified. In case of the first performance of the iterative process, a fast start approach may be used in order to enable the client to start video playing as quickly as possible. In addition, the server may also identify subdivision of the media into chapters. In case the server knows that the client generally navigates using chapters, the server may actually select not only the segments that correspond to the beginning of the media but also the segments corresponding to the start of the first chapters in the media. After the first performance of the iteration, the server may also detect that the connection may support the transmission of a higher quality representation of the media. Thus, the server may identify when the resolution or quality switch should be done.</div>
<div class="description-paragraph" id="p-0267" num="0360">Once the server identified a list of segments to push, the server defines a transmission order for these segments. The transmission order is used for computing initial priority values for each pushed segment during a step <b>802</b>. The ordering may be based on several parameters.</div>
<div class="description-paragraph" id="p-0268" num="0361">A first parameter may be the relationships between the different segments: for example some segments must be available for correctly decoding other segments. The segments that must be available are thus assigned higher priorities than said other segments.</div>
<div class="description-paragraph" id="p-0269" num="0362">A second parameter may be the popularity of video segments, which may be gathered from past statistics. As an example, with YouTube URLs specific times in a video may be addressed. When clicking on the links associated with these URLS, only the video needed to start the video playing at the specified time is retrieved. In addition, if a video is being chaptered, the beginning of each chapter is generally more often retrieved from users than segments in between chapter starts. Segments of the chapter beginning are thus assigned higher priorities than the in-between chapter segments.</div>
<div class="description-paragraph" id="p-0270" num="0363">A third parameter may be the timeline: the priority of a video segment that is closer to being played is higher than the priority of a video segment that is to be played later.</div>
<div class="description-paragraph" id="p-0271" num="0364">A fourth parameter may be the estimated time spent to actually transmit the segment. When the video segment is large, it takes a long time to be transmitted and therefore, transmission should start as soon as possible, i.e. with a high priority.</div>
<div class="description-paragraph" id="p-0272" num="0365">In case two segments have identical priorities, the corresponding data frames can be interleaved during transmission.</div>
<div class="description-paragraph" id="p-0273" num="0366">In case regions of interests are identified in the media content, if the bandwidth is not large enough for a high quality representation but is large enough for a low quality representation, the server may select an enhancement layer only for the region of interest.</div>
<div class="description-paragraph" id="p-0274" num="0367">Once the priorities are computed, the server sends PUSH_PROMISE frames containing the priority values during step <b>803</b>. Identification of all segments is not needed for starting transmission of the PUSH_PROMISE frames. In case an MPD is to be sent for the segments to be pushed (step <b>804</b>), the MPD is sent (step <b>805</b>). The segment transmission starts in parallel during step <b>806</b>.</div>
<div class="description-paragraph" id="p-0275" num="0368">Once the PUSH_PROMISE frames are received by the client, the server may receive priority update changes and then change its transmission schedule accordingly (steps <b>807</b> to <b>808</b> and steps <b>820</b> to <b>828</b>). While sending segments, the server awaits receipt of priority change messages. In case a priority change message is received (step <b>807</b>), the server reorders the segments accordingly and continue the segment transmission (step <b>808</b>). Once all segments are sent (step <b>809</b>-<b>1</b>), the server restarts an iteration process in order to continue streaming the media until the end of the media. When the end of a media is reached (step <b>809</b>-<b>2</b>), the server checks whether or not it should automatically start streaming another media (step <b>810</b>). In case another media should be streamed (Yes), the server identifies the new media to stream (step <b>811</b>) and restarts the process from step <b>801</b>. In case no new data should be streamed, the process is stopped (step <b>812</b>).</div>
<div class="description-paragraph" id="p-0276" num="0369">The management of the priority feedback from the client, i.e. of step <b>808</b>, starts with the receipt of a priority update change message during step <b>820</b>. The following steps may also be performed in case the client cancels a segment push: this case may be seen in practice as equivalent to assigning the lowest priority to that segment.</div>
<div class="description-paragraph" id="p-0277" num="0370">Upon receipt of the priority update change message, the server identifies the related segment during step <b>821</b>. The server then proceeds with the reordering of the segment transmission (steps <b>822</b>, <b>823</b>). If the segment is already transmitted, the process ends. If the segment is being transmitted, depending on the server implementation, it may refuse to change the transmission (for example because it is too complex) or it may actually reschedule the remaining data to be sent.</div>
<div class="description-paragraph" id="p-0278" num="0371">The rescheduling of the data may be performed as follows. The server stores a list of video segments to push (and/or video segments that are being pushed). This list is ordered according to the priorities set by the server. The server then sets the new priority value for the segment. The list is then reordered and the corresponding video segment transmission is made earlier or later accordingly.</div>
<div class="description-paragraph" id="p-0279" num="0372">Once the video segment is reordered, the server may actually decide to apply this priority change to other related video segments. If a client raised the priority of a video segment which is part of an enhancement layer, the server may raise the priority of all the segments of this enhancement layer. Conversely, if the client lowers the priority of a base video segment layer, the priority of all segments temporally related to this segment may be lowered. This process is described in steps <b>824</b> to <b>827</b>. Based on the MPD and the rescheduled video segment, the server identifies a list of related segments (step <b>824</b>). The relationship may be temporal, spatial, quality-based etc. The MPD may be enhanced in order to better show the potential relationships. In particular, when the priority of an initialization segment (which is necessary to play more than one video segment) is lowered or raised, all related segments may be rescheduled. This can be the case as well for base layer segments and enhancement segments. For each identified related segment, the server tests whether or not the transmission of the related segment should be changed (step <b>825</b>). In case it should be changed, the server computes the new priority value for each segment (step <b>826</b>) and reschedules the segment transmission accordingly (step <b>827</b>). The new priority value may be computed by adding to the old value the difference between the new priority value received during step <b>820</b> and the initial priority value of the segment identified during step <b>821</b>. The process stops when each related segment has been tested (step <b>828</b>).</div>
<div class="description-paragraph" id="p-0280" num="0373">The server may also receive control flow messages, such as WINDOW_SIZE frames. These messages may enable the server to identify what the client is currently playing. When some additional buffer space is available on the client's end, it may be inferred that some data have been removed from the buffer, typically the oldest data. If the server keeps a history of the data sent, the server is able to identify which data have been removed. Thus, provided the server knows the client's cache ordering, the server can have knowledge of which video segments the client is currently playing. This ordering may be based on the MPD that makes it possible to order the cached data according to the timeline. A server may then detect client time skipping for instance. The server may react by quickly sending the start of the next chapter in advance so that the client can continue skipping video chapters.</div>
<div class="description-paragraph" id="p-0281" num="0374">It should be noted that the sending of a PUSH_PROMISE frame with priorities may be done in various ways. A PUSH_PROMISE frame must relate to an opened stream which is initiated by the client. According to embodiments, the initial stream made by the client during step <b>800</b> may be always left open. According to other embodiments, a PUSH_PROMISE frame is sent within a stream opened by the server. In this case, the client considers the PUSH_PROMISE frame as it is sent by the parent client-initiated stream. Thus, it can compute the right headers of the virtual request corresponding to the particular PUSH_PROMISE frame.</div>
<div class="description-paragraph" id="p-0282" num="0375">According to other embodiments, a priority message is sent jointly with a PUSH_PROMISE. A first possibility is to send it as a header within the PUSH_PROMISE frame. Another possibility is to send a PRIORITY frame with the stream ID reserved by the corresponding PUSH_PROMISE frame. A third possibility is to send the PUSH_PROMISE frame, then the corresponding HEADERS frame (to open the stream) and then the PRIORITY frame on this newly opened stream.</div>
<div class="description-paragraph" id="p-0283" num="0376">In order to further control the client's buffer, the server may send a new representation of a segment cached by the client. Within the headers sent as part of this new representation, HTTP cache directives may be used to request the client to actually remove the segment, for instance by marking it as not cacheable. This may make it possible to recover buffer space on the client's end. HTTP/2 control flow may be used. The server can then push additional data.</div>
<div class="description-paragraph" id="p-0284" num="0377">A server may send priority values for each video segment. The server may also send priority values for specific segments. In case the server did not send a priority value for a current PUSH_PROMISE frame, the client can compute a priority value from the last priority value sent from the server. For instance, the client may increment the priority value each time a new PUSH_PROMISE frame with no priority value associated with is received. Hence, the PUSH_PROMISE frames can be grouped so that updating the priority of the specific segment will also update the priorities of all segments of the group.</div>
<div class="description-paragraph" id="p-0285" num="0378">The process on the client's side is described with reference to <figref idrefs="DRAWINGS">FIG. 9</figref>.</div>
<div class="description-paragraph" id="p-0286" num="0379">The client should be able to play the content available at a given time. However, the client has to cope with potential buffer limitations and processing time. The client has to check whether or not the transmission ordering proposed by the server matches the memory space available in the client's buffer and matches the content currently played by the client.</div>
<div class="description-paragraph" id="p-0287" num="0380">During a first step <b>900</b>, the client connects to the server and requests an MPD file. The client then retrieves the MPD file during a step <b>901</b> and waits (step <b>902</b>) for the receipt of data. When data are received, the client checks (step <b>903</b>) whether the data are a push promise. In case a push promise has been received, this means that a new video segment is being sent by the server. The client processes the push promise. In particular, the client may validate the priority values proposed by the server during step <b>904</b>. In case the client wishes to change the priority values (step <b>905</b>) for the current segment or another promised segment, the client compute a new priority value and sends it to the server (step <b>906</b>).</div>
<div class="description-paragraph" id="p-0288" num="0381">In case the client receives video data (step <b>907</b>), the client links the video segment to the MPD file (step <b>908</b>) and stores the video data (step <b>909</b>). Linking the video data to the MPD file makes it possible for the client to retrieve the video segment when it will be further used for decoding the video (step <b>911</b>). This may also provide efficient storage of the video data (step <b>909</b>), for example if contiguous video segments are grouped.</div>
<div class="description-paragraph" id="p-0289" num="0382">The buffer storage constraints may further change the priority. Thus, the client may check again whether a priority value has to be changed and may communicate with the server if needed (steps <b>905</b>, <b>906</b>).</div>
<div class="description-paragraph" id="p-0290" num="0383">Once the client is ready to start or continue playing video (step <b>910</b>), the client retrieves from its cache the next time slot video segments (step <b>911</b>) and decodes and plays the video (step <b>912</b>). As part of step <b>911</b>, the client may query its cache in order to know which video segments are available. By default, the client may use all video segments available, in particular all enhancement segments if any. The client may let the server select the content: generally speaking, all segments should be used by the client. If some segments cannot be used jointly (like audio English tracks and French tracks), the client should dismiss the unused segments in the first place. It should be noted that not all clients may get access to the cache state: web applications in particular do not usually have access to the web browser cache. In such a case, the server may directly send the list of pushed segments to the web application client. For instance, this information may be exchanged from the server to the client using a web socket connection.</div>
<div class="description-paragraph" id="p-0291" num="0384">As the video is played and decoded, the corresponding video segments may be removed from the buffer. Hence, the client updates its available buffer size using a WINDOW_SIZE frame. The client may keep video segments that have been recently played in order to enable the user to rewind the video during a limited period of time. The flow control update mechanism may also be used when the user does a fast forward/time skip. The client may remove old stored video content to make room for new content and announces this change to the server using a WINDOW_SIZE frame. When the server receives the WINDOW_SIZE frame, the server may be able to compute which video segments were removed and then identify what the client is actually playing, as discussed above.</div>
<div class="description-paragraph" id="p-0292" num="0385">In what follows, step <b>904</b> is described in more details.</div>
<div class="description-paragraph" id="p-0293" num="0386">The client holds a list of all push promised video segments. This list is ordered according to the priority information found in the push promise frames. First, it is checked for potential frozen video issues. Based on an estimation of the available bandwidth and the ordered video segment list, transmission beginning and end times of each segment can be estimated. Based on these times, it may be tested whether each video segment will be available at the time it should be used for video playing. If a promised video segment is expected to be delivered after its corresponding video playing use, its priority should be increased. Thus, the video segment is moved up in the push promised video segment list order. In order to compute the exact priority value, it is searched for the position in the video segment list that makes it possible to have the video segment delivered on time and that is the closest to the current video segment position. The priority is then set to a value between the priorities of the video segments in the list that are before and after the video segment new position.</div>
<div class="description-paragraph" id="p-0294" num="0387">Other factors may also be used by the client for changing the video segment priorities. For instance, if the client is expecting to do some chapter-switching, the client may actually increase the priority of all video segments that start the chapters, in particular the corresponding initialization segments.</div>
<div class="description-paragraph" id="p-0295" num="0388">According to embodiments, the client-side flow control comprises disabling the per-stream flow control and keeping only a per-connection flow control. The per-connection window size defines the maximum amount of video that a client may actually store at any given time. The client and the server may negotiate at initialization time and during the connection in order to decrease or increase this window size. If the server wants to push some HD content, the server may request the client to increase the window size. If the connection bandwidth is low, the server may need to anticipate well in advance the sending of HD content for a specific part of the video, in which case the buffer size should be made larger.</div>
<div class="description-paragraph" id="p-0296" num="0389">The order of transmission may be an important issue when the buffer has a single size. In particular, as the buffer is filled with data, the priority ordering becomes more and more important. An important constraint is that the video never freezes. As long as the buffer is largely empty, the server may push various video segments, like segments largely in advance in order to provide an efficient fast forward or chapter skipping. Once the buffer is almost fully filled, the video segments to push should be as close as possible to the video segments being played. This push behaviour may be done by the server if the server has accurate information concerning the client buffer. It may also be implemented by the client using the priority update mechanism.</div>
<div class="description-paragraph" id="p-0297" num="0390">In case of automated video switching, the flowchart of <figref idrefs="DRAWINGS">FIG. 9</figref> may be extended by detecting the push of a new MPD as part of the push promise check (step <b>903</b>). When an MPD push is detected, the client may start receiving segments of a new video as part of step <b>908</b>. The client must therefore identify the MPD related to the video data. Once the video playing is finished for a given MPD (step <b>902</b>), the new MPD may be used for continuing video playing. The client may actually flush all video segments linked to the previous MPD.</div>
<div class="description-paragraph" id="p-0298" num="0391">With reference to <figref idrefs="DRAWINGS">FIG. 10</figref>, the behaviour of a DASH-aware proxy is described. When receiving a segment pushed from a server, a proxy is not mandated to push it to the end-client. In case of DASH streaming though, it can be considered good practice (or default behaviour) to do so.</div>
<div class="description-paragraph" id="p-0299" num="0392">The proxy may be able to adjust the server and client behaviours, both in terms of priority processing as well as pushed data to be sent. A proxy may in fact handle independently the priorities with the client from the priorities with the server. In addition, the server may push more data than needed for a given client and the proxy may retrieve the additional pushed data to fulfil requests from other clients.</div>
<div class="description-paragraph" id="p-0300" num="0393">A server may push a video segment for several reasons. For example, a video segment may be pushed in case it is believed to be useful for the end-client. A video segment may also be pushed in case it is believed that the video segment can be used several times and that it is worth pushing it to proxies.</div>
<div class="description-paragraph" id="p-0301" num="0394">In the first case, proxies generally send the video segment to the client. Proxies may postpone its transmission in order to optimize the client or proxy network state, for instance the client radio state. An exemplary case may be the segment push for fast start video playing and bandwidth estimation, in which case data should be sent as fast as possible to the client. In case the server is interested in pushing data to proxies, proxies may not automatically send the video segment to the client, except if they have means to know that the video segment will be useful to the client. In order to make possible the identification of video segments that may not be sent to clients, a specific priority value may be used. Using a priority value makes it possible to have the proxy always check the priority value for optimizing the processing of the various frames that arrive.</div>
<div class="description-paragraph" id="p-0302" num="0395"> <figref idrefs="DRAWINGS">FIG. 10</figref> comprises three flowcharts. One flowchart relates to the process of filtering pushed segments (steps <b>1000</b> to <b>1008</b>). Another flowchart relates to the process performed when a segment is requested by a client while it is already promised to another client (steps <b>1010</b> to <b>1015</b>). Another flowchart relates to the management of priority changes (steps <b>1020</b> to <b>1026</b>).</div>
<div class="description-paragraph" id="p-0303" num="0396">The process of filtering pushed segments starts with the receipt (step <b>1000</b>) of a pushed data event, typically when receiving a PUSH_PROMISE frame or a related DATA frame. The proxy checks whether the data are of high priority or not (step <b>1001</b>). Data may be considered as of high priority if their priority value is much larger than priority values of other segments being transmitted. Data may also be considered as of high priority if its priority value has a special meaning, such as fast start or bandwidth estimation. If the data are of high priority, they are sent as quickly as possible to the client (step <b>1002</b>). The proxy then decides whether or not to store the data (steps <b>1003</b>, <b>1004</b>). This decision may be made once when receiving the corresponding PUSH_PROMISE frame or the corresponding HEADERS frame that opens the pushed data stream. This decision may also be based on the proxy cache state, the envisioned use of the video, the popularity of the video source or other criteria. The proxy stores the video segment if the segment is pushed while being requested by one or more clients at the same time. The video segments may also be stored if segments are identified as fast start.</div>
<div class="description-paragraph" id="p-0304" num="0397">If the data are not of high priority, the proxy checks whether it is of low priority (step <b>1005</b>). Data of low priority may be data for which transmission to the client may be skipped but that are considered by the server as interesting for network intermediaries like proxies. The proxy first decides whether or not to send the data to the client (step <b>1006</b>). This decision may be made once when receiving the corresponding PUSH_PROMISE frame or the corresponding HEADERS frame that opens the pushed data stream. If it is decided so, the proxy sends the corresponding frame to the client (step <b>1002</b>). The process then stops after deciding whether or not to store the data.</div>
<div class="description-paragraph" id="p-0305" num="0398">The priority value negotiated between the server and proxy may be different from the priority value negotiated between the client and proxy. Therefore, in case the data is of usual priority (i.e. not of low priority and not of high priority), the proxy checks whether the segment priority value is managed by the proxy. As illustrated in <figref idrefs="DRAWINGS">FIG. 10</figref> (steps <b>1020</b> to <b>1026</b>), the proxy uses the client-to-proxy value for scheduling the time when the data should be transmitted: the proxy holds a list of all to-be-transmitted video-related frames. These frames are ordered according to the priority values before being sent following that order.</div>
<div class="description-paragraph" id="p-0306" num="0399">In the case the proxy is receiving a priority update frame (step <b>1010</b>), the proxy identifies the related video segment (step <b>1011</b>). If its priority value is not being managed by the proxy (step <b>1012</b>) the proxy forwards the priority update frame to the server (step <b>1013</b>). Otherwise, the proxy stores this new priority value and reorders the video segment transmission (step <b>1014</b>) accordingly. In case a potential conflict appears, in particular in case the video segment delivery from the server is expected to be too late for the client needs, the proxy can then forward the priority value to the server.</div>
<div class="description-paragraph" id="p-0307" num="0400">Steps <b>1020</b> to <b>1026</b> relate to the case of a proxy that receives a request from a client to a video segment (step <b>1020</b>) that is already promised by the server to another client (step <b>1021</b>). Depending on the priority given to that request, the proxy computes the minimum proxy-to-server priority that would fulfil the client's request (step <b>1022</b>). This computation is done by computing the proxy-to-server priority value that will ensure that the server-to-proxy delivery time is earlier than the proxy-to-client expected delivery time. The priority is changed if the computed priority is below the currently set priority (step <b>1023</b>), in which case the proxy will send a priority update message to the server (step <b>1024</b>) and the proxy will mark this video segment priority as managed by the proxy so that the proxy sends the video segment to its two clients at the best time for their needs. Similarly to this process, a proxy may receive several priority updates to the same segment from several clients, in which case the proxy may actually send the lowest priority value that satisfies all clients.</div>
<div class="description-paragraph" id="p-0308" num="0401">With reference to <figref idrefs="DRAWINGS">FIG. 11</figref> there is described an embodiment according to which a client receives a pushed data event whose priority value indicates that the server wants to use it for measuring bandwidth. Measuring bandwidth may be done using TCP/IP packets through active or passive measurements for computing round trip times. Based on round trip times, the available bandwidth may be computed as found in document Saubhasik et al. “Bandwidth Estimation and Rate Control in BitVampire”. This computation may potentially take into account effects of HTTP/2 control flow. By making notification that some data frames are used for bandwidth estimation possible, the bandwidth available without HTTP/2 control flow can be estimated.</div>
<div class="description-paragraph" id="p-0309" num="0402">The process starts with step <b>1100</b> during which a pushed data frame is received from the server. Next, it is checked whether the associated priority of the stream indicates that the server is measuring bandwidth (step <b>1101</b>). In that case, the dedicated buffer is maximized (step <b>1102</b>). Alternatively the stream flow control can be disabled. If the receiving node is a proxy (step <b>1103</b>), it may forward the segment data. Otherwise, the client decides whether to store the segment (step <b>1104</b>). The client stores the pushed segment (step <b>1105</b>). In any case, the client sends an acknowledgement to the server in the form of a WINDOWS_UPDATE (step <b>1106</b>) for the per-connection window. This acknowledgment will then be used by the server for estimating the connection bandwidth. In the case the client is a proxy, it forwards the pushed data (step <b>1108</b>) as quickly as possible. When receiving an acknowledgment from the end-client, the proxy forwards it back to the server as well (steps <b>1109</b>, <b>1110</b>).</div>
<div class="description-paragraph" id="p-0310" num="0403">In order to estimate the available bandwidth, the server may use the round trip time of the sent data frame that is computed as the difference between the sending time of the data frame and the reception time of the acknowledgment message, the pairing between the two being based for instance on the data frame size which should be equal to the window size update. Round trip times can be computed from various data frames of one or more video segment. In order to increase accuracy, the data frames may have various sizes. Splitting a video segment into several DATA frames of different sizes can be performed by the server. The server only needs to ensure that the network layer will not split DATA frames into several TCP/IP packets (hence smaller DATA frames) or not buffer content to be sent and merge several DATA frames into a TCP/IP packet. Based on those measurements, standard techniques can be used for computing the available bandwidth (an example can be found in the above-mentioned document) that the server may use to actually decide which video representation to use.</div>
<div class="description-paragraph" id="p-0311" num="0404">With reference to <figref idrefs="DRAWINGS">FIG. 12</figref>, there is described the case of an initial video playing. The server pushes data using the fast start priority. It is considered that the data probably have a low-bit rate and that the client will receive those data and send acknowledgments to the server so that the server can estimate the bandwidth and switch to the optimal representation. The client-side process is described in steps <b>1200</b> to <b>1207</b>. The server-side process is described in steps <b>1210</b> to <b>1215</b>.</div>
<div class="description-paragraph" id="p-0312" num="0405">The client process starts with a step <b>1200</b> of receipt of pushed data. The client then checks whether the priority has the fast start value (step <b>1201</b>). In that case, the client typically maximizes the dedicated buffer (step <b>1202</b>). This maximization is performed when receiving the PUSH_PROMISE of the pushed data. The data are then stored (step <b>1203</b>) and the client sends an acknowledgement to the server using the WINDOW_UPDATE frame (step <b>1204</b>). The client then checks whether enough data are available to start playing the video (step <b>1205</b>). If they are, the video playing starts (step <b>1206</b>). Otherwise the client waits for more data (step <b>1207</b>), until enough data are available for starting playing the data.</div>
<div class="description-paragraph" id="p-0313" num="0406">The server process starts with a step <b>1211</b> of sending segment data frames with the fast start priority (step <b>1210</b>). The server then receives acknowledgments (step <b>1211</b>) that will allow computing the available bandwidth (step <b>1212</b>). Once enough measurements are obtained, the server selects the optimal representation (step <b>1213</b>) and starts pushing optimal representation segments (step <b>1214</b>). The server decides when to switch representation. This has at least two benefits. First the server may know when the measurements are accurate enough and may switch from one resolution to another as soon as this is the case, while the client will need to handle some delay. Second, the server may decide to switch from one resolution to another at the time that is less disturbing for the user experience. Indeed, the server has the knowledge of the video content. In particular, the MPD may be augmented with information on the times at which resolution switch can be best envisioned.</div>
<div class="description-paragraph" id="p-0314" num="0407">The present invention relates to an enhanced streaming method where, at the server side, a request relating to first media data is received, from the client device; second media data to be sent to the client device without having been requested are identified; and then data relating to said first media data are transmitted to said client device, in response to said request, and at least one announcement message respectively identifying said second media data is prepared with a view to transmit the announcement message or messages to the client device.</div>
<div class="description-paragraph" id="p-0315" num="0408">At the client side, a request relating to first media data is transmitted to the server device; and data relating to said first media data are received from said server device, in response to said request,</div>
<div class="description-paragraph" id="p-0316" num="0409">The enhanced streaming method reduces the mismatches between the server's decisions to push some media data and the client's needs for such data. As will be apparent from below, the server and the client share a push policy so that they both determine the same media data to be pushed from any media data requested by the client. A push policy defines how to determine the data to push, and may be seen as a rule for determining which resources linked to requested data are about to be pushed after the requested data are processed (after a GET request), and possibly how they are pushed (e.g. in which order). Usually, the linked resources are determined using one document, for instance a manifest file, such as an MPD file (in the DASH context for multimedia data), or an HTML document.</div>
<div class="description-paragraph" id="p-0317" num="0410">As a consequence, based on the shared push policy, the client is able to anticipate the server's behaviour to avoid, and more precisely to cancel, the transmission of useless media data from the server. Use of bandwidth in the communication network between the client and the server is thus reduced. Furthermore, the number of HTTP requests and PUSH_PROMISE cancellation is reduced, which lowers the latency of the application in particular for low latency live video streaming.</div>
<div class="description-paragraph" id="p-0318" num="0411">According to the invention, the server may use a push policy shared with the client device for the server device to drive the identification and the transmission of the second non-requested media data to the client device. In particular, it may use a push policy shared with the client device and defining how to determine second media data, for the server device to determine the second non-requested media data to be sent to the client device. Correspondingly, the client may use a push policy shared with the server device and defining how to determine second media data, for the client device to determine second media data to be sent by the server device without having been requested by the client device.</div>
<div class="description-paragraph" id="p-0319" num="0412"> <figref idrefs="DRAWINGS">FIG. 14<i>a </i> </figref>illustrates, using a flowchart, general steps of the invention at the client side, while <figref idrefs="DRAWINGS">FIG. 14<i>b </i> </figref>illustrates, using a flowchart, general steps of the invention at the server side.</div>
<div class="description-paragraph" id="p-0320" num="0413">In comparison to the process described with reference to <figref idrefs="DRAWINGS">FIGS. 1<i>d </i>and 1<i>e</i> </figref>, additional stages <b>1400</b> and <b>1402</b> make it possible for respectively the server and the client to determine the push strategy that is shared with the other, and thus to be used.</div>
<div class="description-paragraph" id="p-0321" num="0414">According to first embodiments, the shared push policy is an implicit push policy, meaning that the client and server do not exchange (explicit) policy data to tell the other what is the push policy to be shared. An implementation of the implicit approach for the shared push policy includes using the same algorithm, referred to as “second media data determining algorithm”, at both the server device and the client device, the algorithm enabling the server device and the client device to determine the same second media data from the first media data requested.</div>
<div class="description-paragraph" id="p-0322" num="0415">For instance, the algorithm is predetermined either during the set-up of the client and server or relatively to a specific standard. A typical example of algorithm may consist in pushing the N resources following the requested resource in a parsing order of the manifest file, where N is a predetermined number, for instance <b>4</b>.</div>
<div class="description-paragraph" id="p-0323" num="0416">Referring to the Figures, the steps <b>1400</b> and <b>1402</b> consist, in case of implicit push policy, in loading in memory the predetermined algorithm for identifying the resources to be pushed (step <b>1403</b> at the server side).</div>
<div class="description-paragraph" id="p-0324" num="0417">The client may efficiently use the so determined push policy for estimating the number of PUSH_PROMISE that are expected and for preparing cancellation messages for unwanted push data, for instance in step <b>1401</b>.</div>
<div class="description-paragraph" id="p-0325" num="0418">For instance, this would result for the server in receiving, from the client device, a cancellation request requesting to cancel transmission of a part of the second non-requested media data so that the server device does not transmit the corresponding prepared announcement message. For its part, the client would thus send, to the server device, a cancellation request requesting to cancel transmission of a part of the second non-requested media data, in order to drive the server device not to transmit an announcement message identifying the part of the second non-requested media data. One may understand that such cancellation can occur before the announcement message is transmitted from the server device or received by the client device. This approach may be useful for example, when the client decides to switch to another version of a medium. In such situation, it can decide to cancel the segments pushed for the previous version.</div>
<div class="description-paragraph" id="p-0326" num="0419">It may also be noted that, thanks to the knowledge of the resources to be pushed using the algorithm, the client can make a second request to the server in parallel, in order to retrieve subsequent resources without having to wait for the corresponding PUSH_PROMISE from the server. In case of DASH, this possibility for the client makes it possible to reduce the latency of the client while ensuring that the second request will not interfere with a PUSH_PROMISE that will be received later.</div>
<div class="description-paragraph" id="p-0327" num="0420">The client may also request other resources that it needs, if it determines from the results of the algorithm that these other needed resources are not about to be pushed.</div>
<div class="description-paragraph" id="p-0328" num="0421">According to second embodiments, the shared push policy is defined in exchanges between the client and server, either explicitly by defining the whole rule (i.e. algorithm or parameters of the algorithm), or using references to push policies predefined at both sides. This requires for the server to first determine a push policy information describing the push policy of the server. Then the push policy information is transmitted to the client to share the push policy with the client. Correspondingly, the client thus receives, from the server device, push policy information describing the shared push policy.</div>
<div class="description-paragraph" id="p-0329" num="0422">One advantage of the explicit approach relies on the fact that a different push policy could be used by the server for each client or for each multimedia presentation (e.g. each MPD), in order to better meet their processing characteristics. <figref idrefs="DRAWINGS">FIG. 15<i>a </i> </figref>illustrates, using a flowchart, step <b>1400</b> of determining the shared push policy at the client side based on the explicit approach, while <figref idrefs="DRAWINGS">FIG. 15<i>b </i> </figref>illustrates, using a flowchart, step <b>1402</b> of determining the push policy at the server side when the explicit approach is used.</div>
<div class="description-paragraph" id="p-0330" num="0423">As shown in <figref idrefs="DRAWINGS">FIG. 15<i>b</i> </figref>, the server generates at step <b>1504</b> <i>a </i>message to declare the push policy and then sends it to the client at step <b>1505</b>, in order to share it. The information describing the push policy in the declaration message is referred to as push policy information.</div>
<div class="description-paragraph" id="p-0331" num="0424"> <figref idrefs="DRAWINGS">FIGS. 16 to 18</figref> described below give exemplary details on how the push policy is declared and transmitted to the client.</div>
<div class="description-paragraph" id="p-0332" num="0425">The resources to be pushed using the push policy as determined at step <b>1402</b> are then identified at step <b>1403</b> with the selection algorithm (or second media data determining algorithm) defined in the push policy declaration message generated in step <b>1504</b>.</div>
<div class="description-paragraph" id="p-0333" num="0426">On the client side as shown in <figref idrefs="DRAWINGS">FIG. 15<i>a</i> </figref>, the client is able to pre-identify the resources to be pushed for a given resource request by applying the same selection algorithm. This makes it possible for the client to predetermine the data that will be pushed by the server and thus ensure an efficient management of push data and a reduction in the number of GET requests if appropriate.</div>
<div class="description-paragraph" id="p-0334" num="0427">To apply the same selection algorithm, the client receives the push policy information describing the push policy applied by the server.</div>
<div class="description-paragraph" id="p-0335" num="0428">Various push policy declaration methods may be used.</div>
<div class="description-paragraph" id="p-0336" num="0429">In one embodiment, the push policy declaration is shared thanks to a JavaScript program that takes, as input parameters, a request R and a DOM tree corresponding to the document containing the resources to be pushed (typically the manifest file for DASH) and that outputs an ordered list of resources to be pushed. In this embodiment, the push policy information includes a JavaScript program embedded in a web page transmitted from the server device to the client device.</div>
<div class="description-paragraph" id="p-0337" num="0430">In other embodiments, the push policy is described within the manifest file. That is the push policy information describing the shared push policy is inserted in a description file that is transmitted from the server device to the client device using the shared push policy. The description file contains description information that concerns media data including the first media data, and is used by both sides to determine the second non-requested media data to be pushed.</div>
<div class="description-paragraph" id="p-0338" num="0431">In DASH, the description file is for instance the MPD file. The description below is mainly based on DASH and MPD files. However, the same approach applies to other manifest-based streaming methods like Smooth Streaming or HTTP Live Streaming.</div>
<div class="description-paragraph" id="p-0339" num="0432">According to specific embodiments, the push policy information includes a first push attribute defining an amount of second non-requested media data to be identified in a description file. This makes it possible to specify the number of segments to be pushed after one request R is received from the client.</div>
<div class="description-paragraph" id="p-0340" num="0433">This is illustrated by <figref idrefs="DRAWINGS">FIG. 16</figref> which shows an MPD document in which a PushPolicy node <b>1600</b> is used to specify the push policy applied by the server.</div>
<div class="description-paragraph" id="p-0341" num="0434">In this example, the PushPolicy node <b>1600</b> includes a push attribute, namely “SegmentIdx”, to declare the number of segments to be pushed after a GET request is received. For instance, if the client requests segment <b>1601</b> in its GET request, it will receive, as a response, a PUSH_PROMISE frame for the next two segments in parsing order of the MPD document. In this example, the first push attribute identifies the second non-requested media data relatively to the first media data requested within the description file. More generally, a predetermined number of K segments to be pushed is used to define the push policy value. Consequently, for each segment requested by the client, the server will push the K next segments.</div>
<div class="description-paragraph" id="p-0342" num="0435">Whereas the example <b>1600</b> of <figref idrefs="DRAWINGS">FIG. 16</figref> shows a single push attribute, there may be several push attributes. Each push attribute may represent a constraint on nodes of the DOM (Document Object Model) tree representing the manifest for selecting the segments to be pushed. Referring to the previous example of <figref idrefs="DRAWINGS">FIG. 4<i>b</i> </figref>, the push policy node <b>1600</b> can refer to media data described in the description file (MPD file) using media data attributes (the MPD elements and/or attributes) including a period attribute “PeriodIdx” that refers to a Period element to which the media data belong, an adaptation attribute “AdaptationSetIdx” that refers to an AdaptationSet element of the media data, a representation attribute “RepresentationIdx” that refers to a Representation element, i.e. an encoding version (specific codec, resolution or bitrate . . . ) of the media data and a segment attribute “SegmentIdx” that refers to a segment in a given Representation.</div>
<div class="description-paragraph" id="p-0343" num="0436">Based on these existing media data attributes, the push policy information may include at least a second push attribute defining a constraint on the media data attribute or attributes, for identifying the second non-requested media data.</div>
<div class="description-paragraph" id="p-0344" num="0437">For instance, a push attribute may be related to the PeriodIdx attribute to specify a constraint on the period for selecting the segment to push; another one may be related to the AdaptationSetIdx attribute to specify a constraint on the adaptation; another one may be related to the RepresentationIdx attribute to specify a constraint on the representation; in addition to the above first push attribute related to the SegmentIdx attribute.</div>
<div class="description-paragraph" id="p-0345" num="0438">When a push attribute is not present or void, the related media data attribute must be considered as unconstrained.</div>
<div class="description-paragraph" id="p-0346" num="0439">The value of the push attributes may use the following syntax:</div>
<div class="description-paragraph" id="p-0347" num="0440">push attribute=[operator] operand</div>
<div class="description-paragraph" id="p-0348" num="0441">where “operator” is optional and takes the value ‘+’ or ‘−’ to define the segments to be pushed relatively (“+” means after and “−” means prior to) to the requested segment, and where “operand” is either an integer value superior or equal to 0 or ‘*’ as wildcard parameter.</div>
<div class="description-paragraph" id="p-0349" num="0442"> <figref idrefs="DRAWINGS">FIG. 17</figref> illustrates, using a flowchart, steps for identifying and marking some segments as ready to be pushed according to the shared push policy “PushPolicy”. This flowchart illustrates step <b>1403</b>.</div>
<div class="description-paragraph" id="p-0350" num="0443">First, the server identifies at step <b>1700</b> the segment requested in the manifest file. The request includes an identified “reqSegIdx” of this segment.</div>
<div class="description-paragraph" id="p-0351" num="0444">For each node type in the manifest file MPD, an index value is attributed to each node. The value is incremented for each Node in the order of appearance in the manifest file.</div>
<div class="description-paragraph" id="p-0352" num="0445">Next, the indexes of the Period, AdaptationSet, Representation and SegmentURL that correspond to the requested segment (i.e. the segment specified in the GET request) are retrieved by parsing the whole MPD until the requested segment is reached.</div>
<div class="description-paragraph" id="p-0353" num="0446">The operator and operand values of the push attributes defined in the push policy are used to identify in which nodes the segments to be pushed are defined (except for the SegmentIdx attribute that defines the amount of segments to be pushed, when associated with “+” or “−” operator).</div>
<div class="description-paragraph" id="p-0354" num="0447">When no operator is specified, the operand value identifies the index of the Node within which the data to be pushed have to be retrieved. For example, where the first push attribute “SegmentIdx” has no operator, it is an identifier, within the description file, of a specific segment to be pushed. In one alternative, when the operator is not specified the operand value may identify range values, for example “SegmentIdx=2-5” would return segments with index equal to 2, 3, 4 and 5.</div>
<div class="description-paragraph" id="p-0355" num="0448">Otherwise (an operator is specified), the operand value represents an offset value (named “idxOffset”) to apply to the index of the requested segment (“reqSegIdx” obtained in step <b>1700</b>). In such case, the segments to be pushed should be in the Nodes with indexes comprised in the [reqSegIdx, reqSegIdx+idxOffset] range if the operator is “+” and in [regSegIdx−idxOffset, regSegIdx] if the operator is “−”. The use of an operator makes it possible to define a media data attribute or attributes of the second non-requested media data relatively to the corresponding media data attribute or attributes of the first media data within the description file.</div>
<div class="description-paragraph" id="p-0356" num="0449">For instance, let's consider the following push policies:
</div> <ul> <li id="ul0065-0001" num="0000"> <ul> <li id="ul0066-0001" num="0450">1. &lt;PushPolicy RepresentationIdx=“−1” SegmentIdx=“2”/&gt;</li> <li id="ul0066-0002" num="0451">2. &lt;PushPolicy PeriodIdx=“+1” SegmentIdx=“+2”/&gt;</li> <li id="ul0066-0003" num="0452">3. &lt;PushPolicy PeriodIdx=“+0” SegmentIdx=“+2”/&gt;</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0357" num="0453">PushPolicy #1 specifies that the server will push the segment of index <b>2</b> in the representation node preceding the representation node of the requested segment.</div>
<div class="description-paragraph" id="p-0358" num="0454">With PushPolicy #2, the server will push the two segments following the requested segment, either in current period or in the following. For example, when requesting segment <b>2401</b> on <figref idrefs="DRAWINGS">FIG. 24</figref>, segments <b>2405</b> and <b>2402</b> would be pushed.</div>
<div class="description-paragraph" id="p-0359" num="0455">PushPolicy #3 is very similar to the PushPolicy #2, the main difference is when the requested segment is the penultimate of the Period. For example, when requesting <b>2401</b>, only the last segment <b>2405</b> in the current Period (instead of two segments) would be pushed. With PushPolicy #3, PeriodIdx restricts the segment search to the requested segment's Period node and thus only the last segment of the Period is pushed (because the segment requested is the penultimate segment in the Period). On the contrary, with PushPolicy #2 the segments can be retrieved from the next period.</div>
<div class="description-paragraph" id="p-0360" num="0456">In an alternative or as an optional value, the value of the operand may be also ‘*’ (wildcard meaning) which means that any segment should be pushed. When it is associated with operator ‘+’ (respectively “−”), it means that all subsequent (resp. preceding) segments to the requested one should be pushed.</div>
<div class="description-paragraph" id="p-0361" num="0457">This alternative allows the client to send only a single HTTP request to retrieve all segments of one Period for instance with the following PushPolicy: &lt;PushPolicy PeriodIdx=“+0” SegnnentIdx=“+*”&gt;.</div>
<div class="description-paragraph" id="p-0362" num="0458">In these examples, the use of the SegmentIdx attribute to identify the second media data (to be pushed) relatively to the requested first media data requires that the second media data are adjacent to the first media data. In an embodiment, the SegmentIdx attribute may include an offset (in addition to the operand) to apply to the index of the requested segment. This shifts the index of a reference segment from which a specified amount of segments has to be pushed. As an example, the syntax of the SegmentIdx attribute may be:</div>
<div class="description-paragraph" id="p-0363" num="0459">push attribute:[operator]operand[,offset]</div>
<div class="description-paragraph" id="p-0364" num="0460">where “offset” is a positive or negative integer different from 0 to apply to the requested segment index. In such case the search range is [reqSegIdx+offset, reqSegIdx+idxOffset+offset] when the operator is ‘+’ and [reqSegIdx-idxOffset+offset, reqSegIdx+offset] when the operator is ‘−’.</div>
<div class="description-paragraph" id="p-0365" num="0461">The syntax of the push policy can also contain conditions like (non restrictive) a maximum size of data or a time in the presentation being pushed, respectively. For instance:</div>
<div class="description-paragraph" id="p-0366" num="0462">&lt;PushPolicy SegnnentIdx=‘+*[size&lt;500000]’&gt; defines a push policy to push no more than 500 kilo bytes of segments data.</div>
<div class="description-paragraph" id="p-0367" num="0463">&lt;PushPolicy SegnnentIdx=‘+*[time&lt;0:01:30]’&gt; defines a push policy to push no more than 1 minute and 30 seconds of next segments data.</div>
<div class="description-paragraph" id="p-0368" num="0464">While the above examples show how to declare the push policy that determines which segments have to be pushed, there may be a need to also specify in which preferred order the segments will be pushed. This information should also be shared between the client and the server.</div>
<div class="description-paragraph" id="p-0369" num="0465">As an example, the declaration of an order of transmission of the pushed segments as described above with reference to <figref idrefs="DRAWINGS">FIGS. 7 to 12</figref> could apply.</div>
<div class="description-paragraph" id="p-0370" num="0466">In one alternative embodiment for an order of transmission of pushed segments, the description information in the description file includes priority attributes associated with the media data, one priority attribute (for example “priorityIdx”) for each media data, and an order of transmission of the second media data is based on the associated priority attributes. Thanks to the transmission of the description file, the client is also aware of the values taken by these priority attributes, and is thus able to determine the intended order of transmission.</div>
<div class="description-paragraph" id="p-0371" num="0467">As shown in the example of <figref idrefs="DRAWINGS">FIG. 16</figref>, each segment (for instance identified by one SegmentURL Node) described in the manifest file includes a priorityIdx attribute (<b>1604</b>) which specifies the push order of the segment. In the example of <figref idrefs="DRAWINGS">FIG. 16</figref>, segment <b>1603</b> is pushed before segment <b>1602</b>. These priorities are computed during the media segments preparation at the server side. Different priority values can be used: a relative priority value in a given Representation (as on <figref idrefs="DRAWINGS">FIG. 16</figref>) or an absolute priority value either as a 32 bit number with 4 most significant bits for the Period priority, 4 next MSBs for the AdaptationSet priority value, next 8 bits for the Representation priority value and least 16 significant bits for the segment priority. An alternative way of signalling the absolute priority value is to use a comma separated list of priority values, one for each of the above cited levels, for example: priorityIdx=‘1, 1, 2, 1’ to define successively the Period priority, the AdaptationSet priority, the Representation priority and then the segment priority. First embodiment with 32 bit value would give (in binary):
</div> <ul> <li id="ul0067-0001" num="0000"> <ul> <li id="ul0068-0001" num="0468">priorityIdx=‘00010001000000100000000000000001’.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0372" num="0469">A main advantage of using priorityIdx values is to make it possible to define a priority order between segments from different Representation (typically an associate representation such as an alternate view of the video). It is useful when the push policy consists in sending segments of different Representation sets. A typical use case is for streaming of layered video (a layer being a view in multi-view or a scalability layer in scalable video) where segments from one layer would be interleaved with segments with one or more other layers.</div>
<div class="description-paragraph" id="p-0373" num="0470">Back to <figref idrefs="DRAWINGS">FIG. 17</figref>, based on the push policy as defined in the MPD file, the server determines at step <b>1701</b> the number of segments to be pushed. This number is directly inferred from the SegmentIdx attribute value: if the operator is not used in the attribute value, this number is equal to 1; otherwise (operator is “−” or “+”) the number is equal to the operand value and is assumed infinite when the operand is “*” (but limited by other constraints and by the number of existing segments).</div>
<div class="description-paragraph" id="p-0374" num="0471">Next, an iterative process composed of steps <b>1702</b> to <b>1705</b> is applied by streaming server until the number of segments to push is reached (test <b>1702</b>) to mark each of the segments to be pushed.</div>
<div class="description-paragraph" id="p-0375" num="0472">For each iteration, the server retrieves at step <b>1703</b> the list of segments defined in the MPD file that respect the PushPolicy constraints (Adaptation Set, Representation, Period and Segment constraints and optional conditions).</div>
<div class="description-paragraph" id="p-0376" num="0473">If the list of segment is empty or all its segments are already marked (test <b>1704</b>) the process ends and the server starts sending (step <b>102</b> above) the response to client's request.</div>
<div class="description-paragraph" id="p-0377" num="0474">Otherwise, the first segment of the list is marked in step <b>1705</b> as to be pushed during steps <b>103</b> (PUSH_PROMISE) and <b>104</b> (promised segments).</div>
<div class="description-paragraph" id="p-0378" num="0475">In these MPD-based examples of declaring the push policy, one push policy is defined using a PushPolicy element (see <b>1600</b> in <figref idrefs="DRAWINGS">FIG. 16</figref>).</div>
<div class="description-paragraph" id="p-0379" num="0476">It is recalled here that the description file describes the media data using a plurality of media data attribute levels, namely the Period, AdaptationSet and Representation elements defined above.</div>
<div class="description-paragraph" id="p-0380" num="0477">As a slight variant to the above, various shared push policies may be defined at various respective levels of the description file. This is to be able to define various push policies depending on the level (Adaptation Set, Representation, Period) concerned, so as to adapt the push strategy to the content of the media stream.</div>
<div class="description-paragraph" id="p-0381" num="0478">This is illustrated through <figref idrefs="DRAWINGS">FIG. 23</figref> in which the push policy is defined using for example the “SupplementalProperty” descriptor at the desired level, here at the Representation level.</div>
<div class="description-paragraph" id="p-0382" num="0479">Using a push policy per &lt;MPD&gt; level makes it possible to have a constant and same push strategy across media.</div>
<div class="description-paragraph" id="p-0383" num="0480">Using a push policy per &lt;Period&gt; level makes it possible to have a push strategy that can vary along time.</div>
<div class="description-paragraph" id="p-0384" num="0481">Using a push policy per &lt;AdaptationSet&gt; level makes it possible to have a media-adapted push strategy.</div>
<div class="description-paragraph" id="p-0385" num="0482">Using a push policy per &lt;Representation&gt; level makes it possible to have a push strategy that can be adapted to the media characteristics (bandwidth . . . ).</div>
<div class="description-paragraph" id="p-0386" num="0483">In the example of <figref idrefs="DRAWINGS">FIG. 23</figref>, the push policy specified at the Representation level is configured to push more segments for low bit rate video segments (<b>2300</b>) than for high bitrate video (<b>2301</b>), so to avoid using too much bandwidth with push data.</div>
<div class="description-paragraph" id="p-0387" num="0484">Note that the explanations above with respect to the syntax of the push attributes may also be applied to this slight variant. In particular the push policy can be signalled in a manifest as a new element (as in <figref idrefs="DRAWINGS">FIG. 16</figref>), or using an existing descriptor with a new schemeIdUri (as in <figref idrefs="DRAWINGS">FIG. 23</figref>) or as a new descriptor (not represented) or any means compliant with MPD schema or MPD schema extension points.</div>
<div class="description-paragraph" id="p-0388" num="0485">The MPD could also contain a list of alternative PUSH policies each one having a unique identifier (see below for more explanation about the list).</div>
<div class="description-paragraph" id="p-0389" num="0486">In other alternative embodiments, a push policy may define that segments for complementary Representations are systematically pushed, for example using the following syntax:
</div> <ul> <li id="ul0069-0001" num="0000"> <ul> <li id="ul0070-0001" num="0487">&lt;push_policy Segments=‘+complementary’&gt;</li> <li id="ul0070-0002" num="0488">or value=‘complementary’ when using a DASH descriptor.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0390" num="0489">In case of layered video, this means that for a requested video segment, each segment at the same time from all Representations declared as complementary Representations (typically through a dependencyId attribute in the MPD signalling dependencies between different Representations) would also be pushed.</div>
<div class="description-paragraph" id="p-0391" num="0490">Another push policy could also consist in pushing segments from associated Representations, signalled either with the @associationId attribute or with a role=‘supplementary’.</div>
<div class="description-paragraph" id="p-0392" num="0491">In case of fully server driven streaming, the push policy could provide information on whether the server behaviour has to be ‘aggressive’ (or ‘optimistic’) or ‘conservative’, i.e. respectively trying to push segments of higher quality or trying to push at the same quality level (preserving bandwidth).</div>
<div class="description-paragraph" id="p-0393" num="0492">In other embodiments, the push policy is transmitted in a dedicated HTTP header, referred to as “push-policy” header. That is the push policy information describing the shared push policy is embedded in a header of an HTTP frame transmitted from the server device to the client device.</div>
<div class="description-paragraph" id="p-0394" num="0493">These embodiments make it possible to vary the push policy over time, since they are no longer dependent on the transmission of the MPD file as above and the client and the server exchange using HTTP/2 protocol.</div>
<div class="description-paragraph" id="p-0395" num="0494"> <figref idrefs="DRAWINGS">FIG. 18</figref> is an example of communication between a server and client with a push policy transmitted in a HTTP “push-policy” header (the header name “push-policy” is just an example).</div>
<div class="description-paragraph" id="p-0396" num="0495">The push-policy header includes a list of push attributes, each defining a constraint on the data to be pushed. In particular, the syntax of the PushPolicy described previously may be transcribed to HTTP header syntax.</div>
<div class="description-paragraph" id="p-0397" num="0496">In <figref idrefs="DRAWINGS">FIG. 18<i>a</i> </figref>, the server in response to a MPD request from the client (arrow <b>1800</b>) transmits (step <b>1801</b>) the push-policy in an HTTP header accompanying the MPD sent, to share the push policy.</div>
<div class="description-paragraph" id="p-0398" num="0497">For instance, the push policy specifies that the segment following a requested segment will be pushed. As consequence, when the client requests (arrow <b>1802</b>) segment Data<b>1</b>.<b>1</b>, the server sends (arrow <b>1803</b>) PUSH PROMISE for segment Data<b>2</b>.<b>1</b> and then the data of segment Data<b>1</b>.<b>1</b> (arrow <b>1804</b>).</div>
<div class="description-paragraph" id="p-0399" num="0498">Any syntax could be used to define which data is about to be transmitted for subsequent segment request: a MPD-specific one or a more abstract one based on DOM tree node traversal.</div>
<div class="description-paragraph" id="p-0400" num="0499">In a specific embodiment dedicated to dynamic shared push policies, the client may request a specific push policy, i.e. may update the shared push policy, for example if the current shared push policy is not adapted to its needs or may be improved.</div>
<div class="description-paragraph" id="p-0401" num="0500">That means that the client device sends push policy update information embedded in a header of an HTTP frame to the server device. Correspondingly, the server device receives push policy update information embedded in a header of an HTTP frame from the client device. The server device may thus update accordingly the shared push policy before determining non-requested media data from other media data requested by the client device (for instance, for the next request).</div>
<div class="description-paragraph" id="p-0402" num="0501">In an embodiment, the push policy request from the client is conveyed in an HTTP header or request named “push-policy-request” (name here is just an example).</div>
<div class="description-paragraph" id="p-0403" num="0502"> <figref idrefs="DRAWINGS">FIG. 18<i>b </i> </figref>illustrates client-server exemplary exchanges when the client requests a new push policy.</div>
<div class="description-paragraph" id="p-0404" num="0503">The beginning of the exchanges is the same as in <figref idrefs="DRAWINGS">FIG. 18</figref> <i>a. </i> </div>
<div class="description-paragraph" id="p-0405" num="0504">After receiving segment Data<b>2</b>.<b>1</b>, the client identifies that the current push policy should be modified, for instance because the available bandwidth is stable enough to let the server push more segments in response to a segment request.</div>
<div class="description-paragraph" id="p-0406" num="0505">As a consequence, the client sends at step <b>1805</b> a push-policy-request that asks the server to push more segments (3 instead of 1) for each new request.</div>
<div class="description-paragraph" id="p-0407" num="0506">The server positively answers this push policy request with an OK <b>200</b>, at step <b>1806</b>. This positive answer means the server will use the new push-policy described in push-policy-request for any new request from the same client.</div>
<div class="description-paragraph" id="p-0408" num="0507">If the server does not want to change its push-policy, it returns an error code answer to notify the client that the push policy request is rejected.</div>
<div class="description-paragraph" id="p-0409" num="0508">Next, when the client requests at step <b>1807</b> a next segment Data<b>3</b>.<b>1</b>, the server answers at step <b>1808</b> with PUSH PROMISE for the next three segments Data <b>4</b>.<b>1</b>, Data<b>5</b>.<b>1</b> and Data <b>6</b>.<b>1</b>.</div>
<div class="description-paragraph" id="p-0410" num="0509"> <figref idrefs="DRAWINGS">FIG. 21</figref> illustrates, using a flowchart, steps of the process at the server side when using the HTTP request for sharing push policy, while <figref idrefs="DRAWINGS">FIG. 22</figref> illustrates, using a flowchart, steps of the process at the client side when using the HTTP request for sharing push policy.</div>
<div class="description-paragraph" id="p-0411" num="0510">In comparison to the process of the <figref idrefs="DRAWINGS">FIG. 14</figref>, the server includes new processing steps (<b>2100</b> to <b>2105</b>) to handle a push policy request from the client and also to send the initial push policy and updates thereof.</div>
<div class="description-paragraph" id="p-0412" num="0511">If the request received by the server is a push policy request from the client (test <b>2100</b>), the server first parses the push policy request at step <b>2101</b> in order to extract the constraints of data push proposed by the client.</div>
<div class="description-paragraph" id="p-0413" num="0512">During this step, the server may decide to follow the push policy requested by the client. In such case the server updates its internal push policy (step <b>2102</b>) and sends an OK <b>200</b> response to the client at step <b>2103</b>, in order to validate the proposed push policy.</div>
<div class="description-paragraph" id="p-0414" num="0513">Otherwise, when the server discards the push policy (for instance because the proposed policy is too costly in terms of resources or cannot be applied), step <b>2102</b> does not modify the internal push policy at the server and an error code is transmitted to the client at step <b>2103</b>.</div>
<div class="description-paragraph" id="p-0415" num="0514">According to a specific embodiment, the server may in addition update its push policy independently of the client's requests. In such case, the server determines a push policy during step <b>1402</b> and may either decide to change its characteristics (for instance by analysing the requests performed by the client and network characteristics) or see that the determined push policy is different from the current one. In such a situation, the server has to share the new push policy with the client if the latter is not already aware of it (test <b>2104</b>), in which case the new push policy is transmitted in an HTTP header in step <b>2105</b>.</div>
<div class="description-paragraph" id="p-0416" num="0515">The corresponding process at the client side is explained with reference to <figref idrefs="DRAWINGS">FIG. 22</figref>. As for the server processing, new processing steps (<b>2200</b> to <b>2204</b>) are added in comparison to the process of <figref idrefs="DRAWINGS">FIG. 14</figref> in order to process push policy messages and perform push policy requests.</div>
<div class="description-paragraph" id="p-0417" num="0516">After having determined the current shared push policy (i.e. the push policy of the server) in step <b>1400</b>, the client may desire a new push policy, for instance to reduce the number of HTTP requests to send for retrieving segments of a media stream. Thus, when a new push policy is required by the client (test <b>2200</b>), the client sends at step <b>2201</b> an HTTP request with a “push-policy-request” as described previously.</div>
<div class="description-paragraph" id="p-0418" num="0517">The response to this request is processed in step <b>2204</b> in which the client checks whether or not the server validates the request by returning an OK <b>200</b> response or otherwise an error code.</div>
<div class="description-paragraph" id="p-0419" num="0518">If the server returns an OK <b>200</b> response, the current push policy determined in step <b>1400</b> is replaced by the requested policy. Otherwise it is unchanged.</div>
<div class="description-paragraph" id="p-0420" num="0519">In addition to the process of <figref idrefs="DRAWINGS">FIG. 14</figref>, when the client receives a frame with a new push policy from the server (test <b>2202</b>), the push policy is parsed and stored (step <b>2203</b>) in memory in order to be retrieved in a next occurrence of step <b>1400</b>.</div>
<div class="description-paragraph" id="p-0421" num="0520">It has to be noted that when the push-policy request is in a frame that also includes other data (e.g. media data), the other data are processed through steps <b>109</b>-<b>111</b>-<b>113</b>-<b>115</b>.</div>
<div class="description-paragraph" id="p-0422" num="0521">Whereas the above HTTP-based examples use an HTTP request to fully define the push policy to be applied, one specific embodiment may rely on having a set of the same predefined push policies defined at both client and server sides, and each having a unique identifier. In this case, the HTTP request is only used to specify an identifier of the push policy to be used from amongst the set. This specific embodiment reduces the size of the HTTP request.</div>
<div class="description-paragraph" id="p-0423" num="0522">In one embodiment, the push policy request is sent as an additional HEADER of one of the HTTP requests used for requesting one of the server resource: typically, the push policy request is sent in an “Accept-Push-Policy” HTTP header in the GET request for the MPD file.</div>
<div class="description-paragraph" id="p-0424" num="0523">In another embodiment, the client specifies several “Accept-Push-Policy” in one HTTP request to indicate the list of push policies supported (or required) by the client. In response to the HTTP request the server may either choose one of the push policy in the proposed list and then specify the push policy in the HTTP response or respond by a new push policy if none is supported.</div>
<div class="description-paragraph" id="p-0425" num="0524">In yet another embodiment, the push policy request is sent in a dedicated HTTP request independent of any of the resource known by the server. For example, a GET (or POST) request is formed with an URL corresponding to none of the resource of the web page, for instance http://server/push_policy and also with at least one Accept-Push-Policy header.</div>
<div class="description-paragraph" id="p-0426" num="0525">In yet another specific embodiment, the set of alternative push policies may be defined in the MPD file exchanged between the server and the client, each having a unique identifier. One of the push policies may be marked as default push policy selected by the server. The client may specify which push policy should be used by sending a new push policy request which includes the identifier of the push policy to be used in replacement of the default push policy.</div>
<div class="description-paragraph" id="p-0427" num="0526">In one embodiment, a specific push policy is defined to indicate which segment will be pushed just after the request to the MPD document for fast start.</div>
<div class="description-paragraph" id="p-0428" num="0527">In a hybrid approach, the push policy information describing the shared push policy is defined by a first push policy part and a second push policy part, the first push policy part being inserted in the description file (MPD), and the second push policy part being embedded in a header of an HTTP frame transmitted from the server device to the client device.</div>
<div class="description-paragraph" id="p-0429" num="0528">For instance, the MPD may define the push policy with template arguments that are then defined (or even overloaded) by the server thanks to push-policy HTTP request. As an example, the push policy defined in the MPD file may be: &lt;PushPolicy SegmentIdx=“parameter”/&gt; and the value of the variable “parameter” may be defined in a push-policy HTTP request. In this example, the second push policy part comprises (only) one or more values for one or more associated variables defined in the first push policy part.</div>
<div class="description-paragraph" id="p-0430" num="0529">Using the push-policy-identifier-based approach described above, the description file may include the description of a plurality of candidate push policies, and the second push policy part may thus comprise an identifier of a candidate push policy from said plurality, which identified candidate push policy thereby forming the first push policy part.</div>
<div class="description-paragraph" id="p-0431" num="0530">In another embodiment to declare the push policy to the client, the push policy relies on the &lt;Role&gt; descriptor defined in the MPD to indicate in which representation the push data will be selected. Typically, the push policy may specify that the push strategy will use a segment in a Representation with an “alternate” or “supplementary” role value.</div>
<div class="description-paragraph" id="p-0432" num="0531">In another embodiment, the document of resources, for example a streaming manifest or an HTML page, is transformed into a priority tree that is browsed to determine the resources to be pushed after a GET request is received. The navigation within the priority tree may be performed thanks to an XPath request. In this approach, the push policy information includes an XPath expression to be evaluated on a tree representation of the document of resources to identify the second non-requested media data.</div>
<div class="description-paragraph" id="p-0433" num="0532">For example, in the streaming manifest a “following[name( )=”SegmentURL“][2]” XPath expression could be used to select, as segments to be pushed, the next two segments following the segment requested by the client in the GET request. Also for the chapter-switching use case, a “((following[name( )=”Period“]//SegmentURL)[2])” XPath expression makes it possible to select two first segments of the following Period for preloading the first two segments of each chapter. For example, when the client requests segment <b>2401</b> in the MPD file of <figref idrefs="DRAWINGS">FIG. 24</figref>, segments <b>2402</b> and <b>2403</b> of the following Period are also transmitted by the server as pushed data.</div>
<div class="description-paragraph" id="p-0434" num="0533">In addition, the priority tree could be first re-ordered for example using an XSLT instruction in order to simplify the XPath expression writing for advanced push policy rules. The XSLT instruction makes it possible to reorganise the tree before applying a push policy. The XPath expressions is preferably transmitted to the client, for instance in one HTTP header and the XSLT stylesheet is defined in a web page. This applies in particular to HTML documents for example to group all pictures declared in the document, all CSS resources as consecutive nodes at the same level of the DOM tree.</div>
<div class="description-paragraph" id="p-0435" num="0534">For instance, the tree <b>2501</b> of <figref idrefs="DRAWINGS">FIG. 25</figref> represents an HTML page with different resources of different types: hashed nodes (<b>2511</b>-<b>2514</b>) correspond to image resources and nodes in plain color (<b>2521</b>-<b>2524</b>) are scripted resources (CSS or Javascript). The tree <b>2502</b> is an example of XSLT transformation result to group the resources by type (images in <b>2530</b> and scripted resources in <b>2540</b>). A simple XPath expression could thus be defined to indicate that some resources for a given type will be pushed once the first resource of this given type is requested.</div>
<div class="description-paragraph" id="p-0436" num="0535">In all the embodiments described above, it is very likely that for each client request the server replies with several PUSH PROMISE if the push policy requires several segments to be pushed.</div>
<div class="description-paragraph" id="p-0437" num="0536">For instance, MPD <b>1900</b> of <figref idrefs="DRAWINGS">FIG. 19</figref> has a push policy which indicates that the three segments following a requested segment will be pushed (see &lt;PushPolicy&gt; element). Consequently, if the client requests the initialization segment with a GET request for media <b>1901</b> with a byte range equal to 0-999, the server will send the three PUSH_PROMISE messages <b>1902</b> during step <b>103</b>.</div>
<div class="description-paragraph" id="p-0438" num="0537">In one embodiment, if the identified second media data comprise a plurality of media segments, each requiring an announcement message (i.e. a PUSH_PROMISE), the corresponding plurality of announcement messages may be merged into a single announcement message to be transmitted to the client device.</div>
<div class="description-paragraph" id="p-0439" num="0538">To achieve this situation, as shown in <figref idrefs="DRAWINGS">FIG. 20</figref>, the processing at the server preferably includes a pre-processing step <b>2000</b> just before sending the push promises in step <b>103</b>, compared to the general process of <figref idrefs="DRAWINGS">FIG. 14</figref>. The pre-processing step seeks to perform the above-mentioned merger of announcement messages.</div>
<div class="description-paragraph" id="p-0440" num="0539">When the push promises include byte range requests as in <b>1902</b>, the list of push promises <b>1902</b> is browsed to generate a reduced set of push promises <b>1903</b> that contains consecutive byte range addresses. Next, each set of push promises <b>1902</b> is replaced by a reduced set of push promises <b>1903</b> with a contiguous byte range equal to the concatenation of the byte ranges in the push promises set or by a single push promise with a list of non-contiguous byte ranges for example <b>1905</b>.</div>
<div class="description-paragraph" id="p-0441" num="0540">For instance, the three push promises <b>1902</b> are replaced by the single push promise <b>1903</b> shown in <figref idrefs="DRAWINGS">FIG. 19</figref>.</div>
<div class="description-paragraph" id="p-0442" num="0541">This approach of merging push promises makes it possible for the client to cancel the send of push data in a simpler way and at lower bandwidth and processing costs. This is because the client just has to close a single stream for the single push promise instead of closing several streams for each of the non-merged push promises.</div>
<div class="description-paragraph" id="p-0443" num="0542">In an alternative, even if the push promises have disjoint byte range intervals, all push promises may be replaced by a list of byte ranges (where consecutive byte range intervals have been concatenated).</div>
<div class="description-paragraph" id="p-0444" num="0543">In addition, if the push promises do not include byte range intervals but rather different SegmentURL values, the push promises may also be concatenated to generate a single push promise message as follows: the method of the generated push promise message is defined as MGET (for multiple GET) and the path field is a list of segment URLs as represented in <b>1904</b>. Similar to the previous embodiment, the client has to close the single stream corresponding to the generated push promise to cancel the push of all segments.</div>
<div class="description-paragraph" id="p-0445" num="0544">Note that the server may include END_SEGMENT flags at the end of each segment in the data then transmitted, in order to ensure that the client is able to parse and identify each pushed segment.</div>
<div class="description-paragraph" id="p-0446" num="0545">In addition, the SETTINGS frame of HTTP/2 is extended to include a new SETTINGS_ENABLE_GROUP_PUSH_PROMISE parameter that makes it possible to indicate if the grouping of push promises is allowed for the streaming session.</div>
<div class="description-paragraph" id="p-0447" num="0546">Embodiments of the invention may make it possible to have a DASH fast start because one or several roundtrip(s) can be avoided. This aspect of the invention is now described with reference to <figref idrefs="DRAWINGS">FIGS. 26 to 28</figref>.</div>
<div class="description-paragraph" id="p-0448" num="0547">The DASH fast start feature may be used with any communication approach as described above with reference to all or part of <figref idrefs="DRAWINGS">FIGS. 7 to 12 and 14 to 25</figref>.</div>
<div class="description-paragraph" id="p-0449" num="0548"> <figref idrefs="DRAWINGS">FIG. 26</figref> shows exemplary methods respectively implemented by a server and by a client device in accordance with the teachings of the invention, in order to obtain a DASH fast start.</div>
<div class="description-paragraph" id="p-0450" num="0549">As in the standard process just described, the first step consists for the client to request the description file, here an MPD file (step <b>2650</b>). The client then waits for the server's response (step <b>2651</b>).</div>
<div class="description-paragraph" id="p-0451" num="0550">In the meantime, the server analyses the MPD file (step <b>2652</b>), in particular to identify (step <b>2653</b>) initialization data which will help the client to start faster, as explained below. An exemplary embodiment for step <b>2653</b> is described below with reference to <figref idrefs="DRAWINGS">FIG. 27</figref>.</div>
<div class="description-paragraph" id="p-0452" num="0551">Once initialization data is identified by the server, it sends a PUSH_PROMISE frame to the client at step <b>2654</b> to indicate its intention to push initialization data without waiting for a client's request.</div>
<div class="description-paragraph" id="p-0453" num="0552">Possibly, it signals in addition that it will also push initial media data (step <b>2656</b>) by sending another PUSH_PROMISE frame including header fields that allow the client to identify the concerned resource, i.e. the concerned initial media data, such as :scheme, :host, and :path.</div>
<div class="description-paragraph" id="p-0454" num="0553">Both in the case of a PUSH_PROMISE frame for initialization data and of a PUSH_PROMISE frame for initial media data, other header fields are also added by the server to indicate how much the server is confident in the data it has decided to push: in the present embodiment, a confidence_level parameter is associated to (i.e. included in a header of) the PUSH_PROMISE frame. The determination of the confidence_level parameter is described below with reference to <figref idrefs="DRAWINGS">FIG. 27</figref>. The server can also insert a specific DASH header to unambiguously indicate the segment that it intends to push.</div>
<div class="description-paragraph" id="p-0455" num="0554">To minimize the risk that a client will make a request for initialization data and first media data that are to be pushed, the PUSH_PROMISE frames should be sent prior to any content in the response, i.e. step <b>2654</b> and step <b>2656</b> should occur before a step <b>2655</b> of sending the MPD file from the server to the client device.</div>
<div class="description-paragraph" id="p-0456" num="0555">Thus, when PUSH_PROMISE frames are sent to the client device, the server sends the MPD file to the client device at step <b>2655</b>.</div>
<div class="description-paragraph" id="p-0457" num="0556">If the server has not received any CANCEL or ERROR message from the client device in the meantime, it starts pushing initialization data (step <b>2657</b>) and first media data (step <b>2658</b>).</div>
<div class="description-paragraph" id="p-0458" num="0557">PUSH_PROMISE frames and pushing of data from the server to the client device is for instance performed in accordance with corresponding features being developed in the frame of HTTP 2.0, as described for instance in the document “Hypertext Transfer Protocol version 2.0, draft-ietf-httpbis-http2-latest”, HTTPbis Working Group, Internet-Draft, Jun. 24, 2013 (available for instance at http://http2.githubio/http2-spec/).</div>
<div class="description-paragraph" id="p-0459" num="0558">Upon receipt at the client device, the initialization data can be used by the client to set up the decoder(s) (step <b>2659</b>) and the first media data are buffered (step <b>2660</b>) until a sufficient amount of data is available for decoding and rendering (e.g. displaying) without display freeze.</div>
<div class="description-paragraph" id="p-0460" num="0559">When the client has fully received the MPD file, it parses it (step <b>2662</b>) and starts decoding and displaying (step <b>2663</b>) provided enough data are buffered (step <b>2661</b>). If this is not the case, and the client device knows from PUSH_PROMISE frames sent by the server (see step <b>2656</b>) that more segments will be sent, it waits at step <b>2664</b> for the completion of the push of first media data from the server. During this idle step <b>2664</b>, the client device may prepare the next requests for subsequent segments that will be issued in a standard client controlled DASH (step <b>2665</b>), as already explained above. This is possible because the client device has received information on the initial media data to be pushed (or being pushed) in the corresponding PUSH_PROMISE frame (see step <b>2656</b> above) and can thus prepare requests for the temporal segment immediately following the last temporal segment intended to be pushed by the server.</div>
<div class="description-paragraph" id="p-0461" num="0560">The client device, when it has fully received the MPD, may also use the information on initial media data received at step <b>2656</b> to check whether this initial media data fills the buffer and, if not, to send a request for the following media data (e.g. media data corresponding to a temporal segment following the temporal segment represented by initial media data) according to the standard client controlled DASH process prior to step <b>2661</b> (contrary to what is shown in <figref idrefs="DRAWINGS">FIG. 26</figref> which shows a case where the pushed initial media data fills the buffer). This enables the client to correct a bad estimation from the server on the quantity of first media data to push.</div>
<div class="description-paragraph" id="p-0462" num="0561">This process enables a streaming client to start displaying media earlier than in standard manifest-based streaming. Indeed, the startup delay is reduced because the number of HTTP roundtrips on the network is reduced to get initialization data and/or initial media data.</div>
<div class="description-paragraph" id="p-0463" num="0562">This process remains however compliant with the current DASH standard, because:
</div> <ul> <li id="ul0071-0001" num="0000"> <ul> <li id="ul0072-0001" num="0563">there is no modification of the MPD file: its transmission remains light and fast;</li> <li id="ul0072-0002" num="0564">the behaviour of standard DASH clients (i.e. not benefiting from the teachings of the invention) may be unchanged: such client devices would ignore unrecognized HTTP headers and, when not accepting the push feature, would simply have to perform more requests/responses and thus spend more time to start the presentation.</li> </ul> </li> </ul>
<div class="description-paragraph" id="p-0464" num="0565"> <figref idrefs="DRAWINGS">FIG. 27</figref> describes an exemplary method implemented at the server side following a request for the manifest (or description file) from a client device.</div>
<div class="description-paragraph" id="p-0465" num="0566">This method seeks to identify the most relevant initial data to push in advance so that the client can start rapidly the display of the media presentation.</div>
<div class="description-paragraph" id="p-0466" num="0567">In step <b>2700</b>, the request for the manifest is received. The server then checks at step <b>2701</b> whether the client device inserted some preferences in the request. This may be done via a dedicated HTTP header like for example to express a transmission rate for the media presentation and a preferred language for audio stream:</div>
<div class="description-paragraph" id="p-0467" num="0568">GET http://myserver.com/presentation/pres1.mpd \r\n</div>
<div class="description-paragraph" id="p-0468" num="0569">Prefered-MediaRange: bw=2000;lang=FR\r\n\r\n</div>
<div class="description-paragraph" id="p-0469" num="0570">If the request includes preferences (test <b>2701</b> true), the server analyses the client's preferences (step <b>2703</b>) and sets its confidence_level parameter to the value “high” (step <b>2704</b>).</div>
<div class="description-paragraph" id="p-0470" num="0571">If no indication is provided in the request (test <b>2701</b> false), the server checks at step <b>2702</b> whether it has already registered service usage information (logs) for this client (i.e. statistics or usage data based on prior exchanges between the user or client device and the server) or the information from the User-Agent header. Indeed, the User-Agent header is defined as a HTTP header in RFC2616 (see e.g. http://www.ietf.org/rfc/rfc2616.txt) and provides a means for applications to exchange information like for example operating system, browser type, application name, etc.). For instance, the DASH server may have an authentication scheme for the clients before being able to use the service; in a variation, it can be a user logging before getting access to the service. With such means, the server can link media parameters to a connected user or device.</div>
<div class="description-paragraph" id="p-0471" num="0572">When prior usage information (logs) is available for the concerned client device or user (test <b>2702</b> true), by parsing the logs at step <b>2705</b>, the server can deduce most frequent usages for a given client or user. For example, it can deduce that the user or client device always selects an audio stream with French language and video stream in HD (High Definition). Moreover, the server can know whether this is a first request in the open TCP connection or not (client connected to service and requesting a second media presentation). In this case, the bandwidth estimation can be more accurate and reliable and the TCP congestion window may be bigger than for a first request. This can impact the choice made by the server in terms of suitable Representation,</div>
<div class="description-paragraph" id="p-0472" num="0573">By registering DASH quality metrics, the server can have in its logs the changes among various representations the user/client usually performs. From this, the server determines the usual behaviour between “aggressive” or constant depending on the frequency of changes (by changes we mean switches to other Representation, whatever the criterion: bandwidth, resolution, frame rate, etc.). An aggressive client is a DASH client that will automatically switch to a different representation when its context changes. As an example, when monitoring bandwidth or buffer occupancy, an aggressive client will request a Representation with a different bandwidth as soon as a new Representation has characteristics closer to the client's context compared to the current Representation. In opposition, a constant client will try to avoid frequent Representation switches in order to maintain stable quality and display rate. When the user/client device behaviour is rather aggressive in terms of adaptation, the server then knows that whatever it selects as initial representation to start the streaming, the client will try to adapt in the following first seconds or minutes of streaming.</div>
<div class="description-paragraph" id="p-0473" num="0574">When preferences are deduced from logs, the server sets its confidence_level parameter to the value “mid” at step <b>2706</b>. Indeed, this information may be a bit less relevant than explicit preferences signaling by the client itself (test <b>2701</b> true).</div>
<div class="description-paragraph" id="p-0474" num="0575">When no log information is available (test <b>2702</b> false), then the server puts its confidence_level parameter to the lowest value: “low” at step <b>2707</b>. This indicates that the server is performing a best guess on the information it pushes because it has no a priori information to decide. Further process in this case is described below (see step <b>2711</b>).</div>
<div class="description-paragraph" id="p-0475" num="0576">In parallel of this confidence_level parameter computation, the server may parse the manifest at step <b>2708</b>. In cases where the manifest is not liable to change very often (especially for on-demand service, in opposite to live service), the parsing of the manifest can be performed offline, once for all, by registering the description of the various Representations in a lookup table. This lookup table may also be used by the server to link clients' logs to some parts of the media presentation. This enables a faster log processing (see step <b>2705</b> described above) to deduce some client's preferences.</div>
<div class="description-paragraph" id="p-0476" num="0577">The parsing of the manifest (step <b>2708</b>) provides information to the server at the time of selecting (at step <b>2709</b>) a suitable Representation as initial Representation (i.e. initial media data) to start the streaming.</div>
<div class="description-paragraph" id="p-0477" num="0578">Both steps <b>2703</b> and <b>2705</b> (obtaining preferences respectively in the request or based on usage data from prior exchanges) consist in translating preferences or usages from client device/user into concrete parameters that would match MPD attributes. For example, it can be bandwidth, width and height of the video, the kind of codec in use, the language for subtitles or audio streams. Then, from the obtained values for these parameters, the server compares with values in the manifest to identify at step <b>2709</b> the most convenient Representation to push to the client.</div>
<div class="description-paragraph" id="p-0478" num="0579">It may be noted that this step <b>2709</b> is typically what the client device performs continuously in a dynamic and adaptive streaming protocol like DASH. Here, the same step is performed by the server at the beginning of the streaming session by MPD parsing means.</div>
<div class="description-paragraph" id="p-0479" num="0580">In case no suitable Representation can be deduced in <b>2709</b>, test <b>2710</b> is false and the server puts its confidence_level_parameter to the “low” value (in step <b>2707</b> previously mentioned).</div>
<div class="description-paragraph" id="p-0480" num="0581">When the confidence_value parameter has the “low” value (either because no preferences could be determined or because no suitable Representation can be found based on preferences), the server decides at step <b>2711</b> to select the simplest Representation. For video, for instance, the simplest Representation may be the Representation with lowest spatial resolution and designed for lowest bandwidth.</div>
<div class="description-paragraph" id="p-0481" num="0582">According to a possible complementary feature (not represented in <figref idrefs="DRAWINGS">FIG. 27</figref>), when there is no ambiguity on the codec (i.e. all video Representations have the same value for the codec attribute, i.e. the same codec, for example HEVC, has been used to encode all the video Representations), the confidence_level parameter may be raised to the value “mid”.</div>
<div class="description-paragraph" id="p-0482" num="0583">The next step after step <b>2711</b>, or when a suitable Representation has been found (test <b>2710</b> true), consists in identifying the initialization data (step <b>2712</b>). Indeed, in the DASH manifest (or description file), initialization information can be signaled in different ways: it can be explicitly put in an Initialization element of a SegmentBase, SegmentList or SegmentTemplate element that provides a direct URL to the initialization data.</div>
<div class="description-paragraph" id="p-0483" num="0584">In this case, this URL is put in a header field of the PUSH_PROMISE frame (see step <b>2654</b> described above with reference to <figref idrefs="DRAWINGS">FIG. 26</figref>) that will allow the client to identify the resource promised to be pushed (by specifying the variables :scheme, :host, and :path and eventually :Range).</div>
<div class="description-paragraph" id="p-0484" num="0585">When initialization data is not explicitly described, this means that media segments are self-initialized. In such case, the server has to parse the beginning of the segment (e.g. segment index information boxes for segments in mp4 format). Based on this analysis, it can build the corresponding URL with the appropriate byte range that will be put as header in the PUSH_PROMISE frame.</div>
<div class="description-paragraph" id="p-0485" num="0586">Once identified, a PUSH_PROMISE frame for initialization data is immediately sent to the client (step <b>2713</b>, corresponding to step <b>2654</b> in <figref idrefs="DRAWINGS">FIG. 26</figref>), immediately followed here by the push of the initialization data (step <b>2717</b> <i>a</i>, corresponding to step <b>2657</b> in <figref idrefs="DRAWINGS">FIG. 26</figref>). When initialization data are received, the client can then initialize its media decoders (step <b>2717</b> <i>b</i>).</div>
<div class="description-paragraph" id="p-0486" num="0587">Optionally, to improve the segment signaling and later identification by the client device when processing the PUSH_PROMISE frame (see step <b>2806</b> described below), the server can indicate in step <b>2713</b>: the nature of the pushed data: initialization or media or both (in case of self-initializing segments); the parameters of the URL template or an indication of the segment as a path in the MPD representation tree of <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>(for example: P2AS21R211S1; i.e. a concatenation of element type followed by an identifier). It may be noted that this requires the client device to have received the MPD. Then, the server can decide to add this specific information only in the PUSH_PROMISE messages that it thinks will be processed after MPD reception by the client device. To help the decision at the client device on accepting or not a PUSH_PROMISE before the MPD reception and parsing, the server can indicate, instead of the segment path in the MPD, qualitative information on the pushed segment, such as whether it is a segment from a base layer or an enhancement layer; according to another example, the server can place in a header the attributes of the selected Representation with their values.</div>
<div class="description-paragraph" id="p-0487" num="0588">According to a possible embodiment (not represented on <figref idrefs="DRAWINGS">FIG. 27</figref>), when parsing the manifest at step <b>2708</b> determines that initialization data is present in top level elements of the manifest (i.e. whatever the Representations, the initialization data is common to all representations; for example in case of dependent Representation), the server can immediately (i.e. concurrently with step <b>2708</b>) send the PUSH_PROMISE frame designating initialization data with a confidence_level parameter set to the value “high” since there is no risk of mismatch between pushed data and what the client would have chosen. The benefit of sending the confidence_level parameter with the PUSH_PROMISE frame, for example as a HTTP header, is that it can help the client device in accepting or cancelling the push promise (see the description of <figref idrefs="DRAWINGS">FIG. 28</figref> below).</div>
<div class="description-paragraph" id="p-0488" num="0589">Thanks to this feature, the client will receive even earlier the initialization data required to setup its decoders (as the PUSH_PROMISE frame is sent early). This also works when initialization data is unique for a given media type (e.g. one single InitializationSegment per AdaptationSet whatever the number of Representations in this AdaptationSet). This even faster push would come just after the parsing of the manifest (step <b>2708</b> described above), thus before processing logs or preferences (steps <b>2701</b>, <b>2703</b> and <b>2705</b> described above).</div>
<div class="description-paragraph" id="p-0489" num="0590">Then, if the confidence_level parameter previously determined by the server is greater than or equal to the “mid” value (test <b>2714</b>), the server takes the initiative of pushing the first media data it considers as suitable for the client.</div>
<div class="description-paragraph" id="p-0490" num="0591">This is done iteratively in two steps: first a PUSH_PROMISE frame is sent (step <b>2715</b>, corresponding to step <b>2656</b> in <figref idrefs="DRAWINGS">FIG. 26</figref>) and then the push of first media data starts in step <b>2719</b>. This is repeated for each first media data segment that has been selected to be pushed in step <b>2709</b>.</div>
<div class="description-paragraph" id="p-0491" num="0592">According to a possible embodiment, when consecutive media segments are promised to be pushed (i.e. a plurality of PUSH_PROMISE are sent for respective media segments), the PUSH_PROMISE associated to the current media segment is marked as a child or a follower of a previous PUSH_PROMISE (step <b>2716</b>). This can be put as a new HTTP header in the PUSH_PROMISE frame if the server is stateless or kept in a table if the server is stateful. Keeping this relationship can be useful to perform hierarchical cancel on push promises (as described below with reference to <figref idrefs="DRAWINGS">FIG. 28</figref>).</div>
<div class="description-paragraph" id="p-0492" num="0593">A possible schedule of the various transmissions of data is as follows: before actually pushing first media data, the server starts pushing the initialization data in step <b>2717</b> <i>a </i>mentioned above; in parallel to sending the PUSH_PROMISE frame relating to first media data and initialization data, the server also sends the MPD file (manifest) at step <b>2718</b> and keeps the stream open until the pushed data are completely sent.</div>
<div class="description-paragraph" id="p-0493" num="0594">In another embodiment, test <b>2714</b> can be avoided to push first media data whatever the level of confidence. But in case the confidence_level parameter is set to “low”, the server may wait for a potential CANCEL from the client before actually pushing the first (or initial) media data.</div>
<div class="description-paragraph" id="p-0494" num="0595">When pushing the first media data, the server determines the overall quantity of data to push and the speed to use (flow control).</div>
<div class="description-paragraph" id="p-0495" num="0596">Regarding the first aspect, the server can exploit information from the manifest such as for example the minBufferTime attribute mentioned at the beginning of the manifest. Using this attribute, and considering the Representation selected in step <b>2709</b> or <b>2711</b>, and given the segment duration attribute also provided in the manifest, the server easily determines the number of segments to push to fulfill the minBufferTime constraint (i.e. the quantity of segments, hence the quantity of data, forming the initial media data to be pushed). Advantageously, when parsing of the manifest (step <b>2708</b>) is performed offline, this number of first media segments can be recorded in a table in a memory of the server.</div>
<div class="description-paragraph" id="p-0496" num="0597">Regarding the second aspect, given the duration of the segment and the bandwidth of the chosen Representation, an estimate of the required bitrate may be obtained by the server. This provides, mainly for video segments, the transmission rate to use. For example for a compressed video representation with bandwidth equal to 1.6 Mbits/s having segments of 5 seconds duration, each segment would represent 1 mega-byte of data to send. By default, the flow control in HTTP v2.0 provides a stream window size at most equal to 65535 bytes. Thus, in our example, this means that the client would have to send back to the server an acknowledgement for each packet of 65536 pushed bytes, so in our example more than 15 times per segment! Since we aim at reducing network roundtrips and traffic when using the push feature under development HTTP 2.0, we see clearly that there is a need here to modify the default behaviour (actually the default congestion window size) to enable DASH fast start (by reducing network traffic).</div>
<div class="description-paragraph" id="p-0497" num="0598">In case the client device sends preferences included in its request for the manifest, it can also indicate that a SETTINGS frame is to be sent immediately after the request; this SETTINGS frame specifies for instance an initial window size (SETTINGS_INITIAL_WINDOW_SIZE) in line with its buffering capacities. According to a possible variation, this SETTINGS frame can be sent at connection setup time. Another possibility is for the client device, when acknowledging the first pushed data, to send a WINDOW_UPDATE with appropriate size.</div>
<div class="description-paragraph" id="p-0498" num="0599"> <figref idrefs="DRAWINGS">FIG. 28</figref> describes a possible method implemented by the client device, when exchanging data with the server executing a method for instance as described in <figref idrefs="DRAWINGS">FIG. 27</figref>, in accordance with the teachings of the invention.</div>
<div class="description-paragraph" id="p-0499" num="0600">According to a possible application of this method, the client device connects to the server in order to benefit from a video on demand service. The connection establishment between the client and the server is conventional. In the present example, both the client device and the server are able to exchange messages using HTTP/2.0 protocol described for instance in the already mentioned document “Hypertext Transfer Protocol version 2.0, draft-ietf-httpbis-http2-latest”.</div>
<div class="description-paragraph" id="p-0500" num="0601">At a time (for instance when the user at the client device selects a given video), the client device gets information from the server on the address (e.g. the URL) of a manifest describing a media presentation (here the video the user would like to see).</div>
<div class="description-paragraph" id="p-0501" num="0602">The client device then prepares a request to download the manifest (step <b>2800</b>). In a preferred embodiment, the client adds through HTTP headers some preferences on the video resolution, codecs, bandwidth it supports (step <b>2801</b>). The client device then sends its request to the server (step <b>2802</b>).</div>
<div class="description-paragraph" id="p-0502" num="0603">In the present embodiment, the client device then sends at step <b>2803</b> an HTTP/2.0 SETTINGS frame to indicate an initial window size (SETTINGS_INITIAL_WINDOW_SIZE) in line with its buffering capacities (see the document “Hypertext Transfer Protocol version 2.0, draft-ietf-httpbis-http2-latest” mentioned above, section 3.8.5).</div>
<div class="description-paragraph" id="p-0503" num="0604">In step <b>2804</b>, the client device starts processing the various server responses: receiving data forming the manifest and parsing it (step <b>2805</b>) but also the PUSH_PROMISE frame(s) sent by the server (step <b>2806</b>).</div>
<div class="description-paragraph" id="p-0504" num="0605">Before deciding to accept or to cancel the push(es) designated in the PUSH_PROMISE frame(s), the client builds the URL of the resource the server intends to push (step <b>2806</b>) and checks (step <b>2807</b>) the confidence_level parameter that has been included in the PUSH_PROMISE frame by the server.</div>
<div class="description-paragraph" id="p-0505" num="0606">In parallel and when the manifest (or description file) is fully received, the client device builds (step <b>2808</b>) the list of desired media segments it would like to get (i.e. the list of versions of each segment that best suit its needs) and initializes a current segment index variable to 0 (step <b>2809</b>). The first step in processing the PUSH_PROMISE consists (step <b>2810</b> <i>a</i>) in checking the confidence_level parameter. Then, depending on (predefined) client settings or user preferences the client may decide to reject the PUSH_PROMISE under a certain level of confidence, for example the PUSH_PROMISEs for which the PUSH_PROMISE frames include a confidence_level parameter with a “low” value.</div>
<div class="description-paragraph" id="p-0506" num="0607">If the client can match (step <b>2810</b> <i>b</i>) the URL mentioned in the PUSH_PROMISE frame with the URL of a desired segment (as derived from the manifest in step <b>2808</b> as just mentioned), it initializes a table for a list of pending segments being transmitted with their transmission status (step <b>2811</b>). If the client cannot identify the segment intended to be pushed by the server in step <b>2810</b> <i>b </i>in the list of desired media segments, it then cancels the push (step <b>2812</b>) by sending an appropriate CANCEL instruction to the server.</div>
<div class="description-paragraph" id="p-0507" num="0608">To facilitate the segment identification at step <b>2810</b> <i>b</i>, the client can exploit additional header information like for example the index of the pushed segment, as the path in the MPD tree representation (see <figref idrefs="DRAWINGS">FIG. 5<i>b</i> </figref>), or the URL template parameters when the description file (i.e. the MPD file or manifest) relies on Segment Template.</div>
<div class="description-paragraph" id="p-0508" num="0609">This is a specific CANCEL message here (step <b>2812</b>) since using the hierarchical relationship inserted by the server when building the PUSH_PROMISE (see the description of <figref idrefs="DRAWINGS">FIG. 27</figref> above), the client can send a recursive CANCEL that will result in the cancellation of the current PUSH_PROMISE plus the following ones.</div>
<div class="description-paragraph" id="p-0509" num="0610">According to a possible embodiment, when the client device cannot interpret the push promise, it stops by default all pushes of media data corresponding to the next temporal segments of a media resource.</div>
<div class="description-paragraph" id="p-0510" num="0611">This new usage of the CANCEL instructions will avoid the client to repeat CANCEL messages once it is desynchronized with the server in terms of media segment identification. In such case, the client will fall back to a pull mode.</div>
<div class="description-paragraph" id="p-0511" num="0612">When the segment to be received by the push from the server corresponds to a desired segment (test <b>2810</b> <i>b </i>true), the client then continues the processing of the PUSH_PROMISE frames (test <b>2813</b> and loop on step <b>2806</b>).</div>
<div class="description-paragraph" id="p-0512" num="0613">When all PUSH_PROMISE frames have been processed, the client device expects and begins receiving and buffering (step <b>2814</b>) data corresponding to the accepted PUSH_PROMISE.</div>
<div class="description-paragraph" id="p-0513" num="0614">When enough media segments are received in the reception buffer of the client (test <b>2815</b>), they are processed by the client (<b>2816</b>). The current segment index variable is then updated with the ordering number of the first segment in the list (step <b>2817</b>). It should be noted that not all clients may get access to the client's buffer. For example, web applications in particular do not usually have access to the web browser cache. In such a case, the server may send the list of pushed segments to the web application client directly. This information may be exchanged from the server to the client using a web socket connection, for instance.</div>
<div class="description-paragraph" id="p-0514" num="0615">When all pushed media segments have been processed, the client can then go back to standard pull-based DASH (step <b>2818</b>), starting requesting data corresponding to the next segment, designated by the variable segment_index+1. In parallel, the pushed segment data are used to start the decoding and the display of the selected video.</div>
<div class="description-paragraph" id="p-0515" num="0616"> <figref idrefs="DRAWINGS">FIG. 13</figref> is a schematic illustration of a device according to embodiments. The device may be a server, a client or a proxy. The device comprises a RAM memory <b>1302</b> which may be used as a working memory for a control unit <b>1301</b> configured for implementing a method according to embodiments. For example, the control unit may be configured to execute instructions of a computer program loaded from a ROM memory <b>1303</b>. The program may also be loaded from a hard drive <b>1306</b>. For example, the computer program is designed based on the flowcharts of <figref idrefs="DRAWINGS">FIGS. 8-12, 14, 15, 17, 20-22 and 26-28</figref>, and the above description.</div>
<div class="description-paragraph" id="p-0516" num="0617">The device also comprises a network interface <b>1304</b> which may be a single network interface, or comprise a set of network interfaces (for instance several wireless interfaces, or several types of wired or wireless interfaces). The device may comprise a user interface <b>1305</b> for displaying information to a user and for receiving inputs from the user.</div>
<div class="description-paragraph" id="p-0517" num="0618">The device may also comprise an input/output module <b>1307</b> for receiving and/or sending data from/to external devices.</div>
<div class="description-paragraph" id="p-0518" num="0619">While the invention has been illustrated and described in detail in the drawings and foregoing description, such illustration and description are to be considered illustrative or exemplary and not restrictive, the invention being not restricted to the disclosed embodiment. Other variations to the disclosed embodiment can be understood and effected by those skilled in the art in practicing the claimed invention, from a study of the drawings, the disclosure and the appended claims.</div>
<div class="description-paragraph" id="p-0519" num="0620">In the claims, the word “comprising” does not exclude other elements or steps, and the indefinite article “a” or “an” does not exclude a plurality. A single processor or other unit may fulfill the functions of several items recited in the claims. The mere fact that different features are recited in mutually different dependent claims does not indicate that a combination of these features cannot be advantageously used. Any reference signs in the claims should not be construed as limiting the scope of the invention.</div>
</div>
</div>
</section><section itemprop="claims" itemscope="">
<h2>Claims (<span itemprop="count">20</span>)</h2>
<div html="" itemprop="content"><div class="claims" lang="EN" load-source="patent-office" mxw-id="PCLM265561784">
<claim-statement>The invention claimed is:</claim-statement>
<div class="claim"> <div class="claim" id="CLM-00001" num="00001">
<div class="claim-text">1. A method of providing media data from a server to a client, the method comprising:
<div class="claim-text">receiving, from the client, an MPD request (Media Presentation Description request) for requesting an MPD and including parameters signaling the client's preference for initialization information and media, wherein the server requires one MPD request from the client in order to provide media data to the client and the MPD is defined in MPEG-DASH standard,</div>
<div class="claim-text">analysing the client's preference to determine whether to push initialization data and one or more segments,</div>
<div class="claim-text">determining, according to the parameters in the MPD request from the client, the one or more segments to be pushed to the client, and</div>
<div class="claim-text">pushing the determined one or more segments to the client in response to the MPD request from the client, wherein the pushing allows the server to send unsolicited resource representations to the client.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00002" num="00002">
<div class="claim-text">2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in the determining step, an initialization segment, containing metadata that is necessary to present media streams encapsulated in media segments, is determined to be pushed to the client.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00003" num="00003">
<div class="claim-text">3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in the determining step, some media segments are determined to be pushed to the client.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00004" num="00004">
<div class="claim-text">4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in the determining step, an initialization segment and some media segments are determined to be pushed to the client.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00005" num="00005">
<div class="claim-text">5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising sending, to the client, a notification indicating that the server intends to push the determined one or more segments according to the parameters.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00006" num="00006">
<div class="claim-text">6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the parameters include a parameter relating to height of a video.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00007" num="00007">
<div class="claim-text">7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the parameters include a parameter relating to bandwidth.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00008" num="00008">
<div class="claim-text">8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the parameters signal at least one of: transmission rate for a video segment and language information for audio segment.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00009" num="00009">
<div class="claim-text">9. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising transmitting the MPD to the client in response to the MPD request.</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00010" num="00010">
<div class="claim-text">10. A method of receiving media data by a client from a server, the method comprising:
<div class="claim-text">transmitting, to the server, an MPD request (Media Presentation Description request) for requesting an MPD and including parameters signaling the client's preference for initialization information and media, wherein the server requires one MPD request from the client in order to provide media data to the client and the MPD is defined in MPEG-DASH standard,</div>
<div class="claim-text">analysing the client's preference to determine whether to push initialization data and one or more segments based on a predetermined threshold, and</div>
<div class="claim-text">receiving the one or more segments pushed from the server in response to the MPD request, wherein the one or more pushed segments are determined by the server according to the parameters included in the MPD request, wherein the pushing allows the server to send unsolicited resource representations to the client.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00011" num="00011">
<div class="claim-text">11. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein, in the receiving step, an initialization segment, containing metadata that is necessary to present media streams encapsulated in media segments, and pushed from the server is received.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00012" num="00012">
<div class="claim-text">12. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein, in the receiving step, some media segments pushed from the server are received.</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00013" num="00013">
<div class="claim-text">13. A device for providing media data to a client, the device comprising:
<div class="claim-text">a hardware processor; and</div>
<div class="claim-text">a memory storing one or more programs configured to be executed by the hardware processor, the one or more programs including instructions for:</div>
<div class="claim-text">receiving, from the client, an MPD request (Media Presentation Description request) for requesting an MPD and including parameters signaling the client's preference for initialization information and media, wherein a server requires one MPD request from the client in order to provide media data to the client and the MPD is defined in MPEG-DASH standard,</div>
<div class="claim-text">analysing the client's preference to determine whether to push initialization data and one or more segments, determining, according to the parameters in the MPD request from the client, the one or more segments to be pushed to the client, and</div>
<div class="claim-text">pushing the determined one or more segments to the client in response to the MPD request from the client, wherein the pushing allows the server to send unsolicited resource representations to the client.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00014" num="00014">
<div class="claim-text">14. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein, in the determining step, an initialization segment, containing metadata that is necessary to present media streams encapsulated in media segments, is determined to be pushed to the client.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00015" num="00015">
<div class="claim-text">15. The device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein, in the determining step, some media segments are determined to be pushed to the client.</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00016" num="00016">
<div class="claim-text">16. A device for receiving media data from a server, the device comprising:
<div class="claim-text">a hardware processor; and</div>
<div class="claim-text">a memory storing one or more programs configured to be executed by the hardware processor, the one or more programs including instructions for:</div>
<div class="claim-text">transmitting, to the server, an MPD request (Media Presentation Description request) for requesting an MPD and including parameters signaling the client's preference for initialization information and media, wherein the server requires one MPD request from the client in order to provide media data to the client and the MPD is defined in MPEG-DASH standard,</div>
<div class="claim-text">analysing the client's preference to determine whether to push initialization data and one or more segments, and</div>
<div class="claim-text">receiving the one or more segments pushed from the server in response to the MPD request, wherein the one or more pushed segments are determined by the server according to the parameters included in the MPD request, wherein the pushing allows the server to send unsolicited resource representations to the client.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00017" num="00017">
<div class="claim-text">17. The device of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein, in the receiving step, an initialization segment, containing metadata that is necessary to present media streams encapsulated in media segments, and pushed from the server is received.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00018" num="00018">
<div class="claim-text">18. The device of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein, in the receiving step, some media segments pushed from the server are received.</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00019" num="00019">
<div class="claim-text">19. A non-transitory computer-readable storage medium storing a program for causing a computer to execute a method of providing media data to a client, the method comprising:
<div class="claim-text">receiving, from the client, an MPD request (Media Presentation Description request) for requesting an MPD and including parameters signaling the client's preference for initialization information and media, wherein a server requires one MPD request from the client in order to provide media data to the client and the MPD is defined in MPEG-DASH standard,</div>
<div class="claim-text">analysing the client's preference to determine whether to push initialization data and one or more segments,</div>
<div class="claim-text">determining, according to the parameters in the MPD request from the client, the one or more segments to be pushed to the client, and</div>
<div class="claim-text">pushing the determined one or more segments to the client in response to the MPD request from the client, wherein the pushing allows the server to send unsolicited resource representations to the client.</div>
</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00020" num="00020">
<div class="claim-text">20. A non-transitory computer-readable storage medium storing a program for causing a computer to execute a method of receiving media data from a client, the method comprising:
<div class="claim-text">transmitting, to a server, an MPD request (Media Presentation Description request) for requesting an MPD and including parameters signaling the client's preference for initialization information and media, wherein the server requires one MPD request from the client in order to provide media data to the client and the MPD is defined in MPEG-DASH standard,</div>
<div class="claim-text">analysing the client's preference to determine whether to push initialization data and one or more segments, and</div>
<div class="claim-text">receiving the one or more segments pushed from the server in response to the MPD request, wherein the one or more pushed segments are determined by the server according to the parameters included in the MPD request, wherein the pushing allows the server to send unsolicited resource representations to the client.</div>
</div>
</div>
</div> </div>
</div>
</section>
                </article>
            </search-app>
        </body>
    </html>
    