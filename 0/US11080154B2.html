
    <html>
        <body>
            <search-app>
                <article class="result" itemscope="" itemtype="http://schema.org/ScholarlyArticle">
    <h1 itemprop="pageTitle">US11080154B2 - Recovering error corrected data 
        - Google Patents</h1><section itemprop="abstract" itemscope="">
<h2>Abstract</h2>
<div html="" itemprop="content"><abstract lang="EN" load-source="patent-office" mxw-id="PA457688945">
<div class="abstract" id="p-0001" num="0000">A plurality of storage nodes within a single chassis is provided. The plurality of storage nodes is configured to communicate together as a storage cluster. The plurality of storage nodes has a non-volatile solid-state storage for user data storage. The plurality of storage nodes is configured to distribute the user data and metadata associated with the user data throughout the plurality of storage nodes, with erasure coding of the user data. The plurality of storage nodes is configured to recover from failure of two of the plurality of storage nodes by applying the erasure coding to the user data from a remainder of the plurality of storage nodes. The plurality of storage nodes is configured to detect an error and engage in an error recovery via one of a processor of one of the plurality of storage nodes, a processor of the non-volatile solid state storage, or the flash memory.</div>
</abstract>
</div>
</section><section itemprop="description" itemscope="">
<h2>Description</h2>
<div html="" itemprop="content"><div class="description" lang="EN" load-source="patent-office" mxw-id="PDES298899375">
<heading id="h-0001">BACKGROUND</heading>
<div class="description-paragraph" id="p-0002" num="0001">Solid-state memory, such as flash, is currently in use in solid-state drives (SSD) to augment or replace conventional hard disk drives (HDD), writable CD (compact disk) or writable DVD (digital versatile disk) drives, collectively known as spinning media, and tape drives, for storage of large amounts of data. Flash and other solid-state memories have characteristics that differ from spinning media. Yet, many solid-state drives are designed to conform to hard disk drive standards for compatibility reasons, which makes it difficult to provide enhanced features or take advantage of unique aspects of flash and other solid-state memory. Errors can result from a read failure, or a failure of a component or a subsystem, and a solid-state drive can lose data and/or functionality. Downtime of a system, while a solid-state drive is replaced or repaired, is disruptive, as is data loss.</div>
<div class="description-paragraph" id="p-0003" num="0002">It is within this context that the embodiments arise.</div>
<heading id="h-0002">SUMMARY</heading>
<div class="description-paragraph" id="p-0004" num="0003">In some embodiments, a plurality of storage nodes within a single chassis is provided. The plurality of storage nodes is configured to communicate together as a storage cluster, each of the plurality of storage nodes having a non-volatile solid-state storage for user data storage, the non-volatile solid state storage including flash memory. The plurality of storage nodes is configured to distribute the user data and metadata associated with the user data throughout the plurality of storage nodes, with erasure coding of the user data. The plurality of storage nodes is configured to recover from failure of two of the plurality of storage nodes by applying the erasure coding to reading the user data from a remainder of the plurality of storage nodes. The plurality of storage nodes is configured to detect an error and engage in an error recovery via one of a processor of one of the plurality of storage nodes, a processor of the non-volatile solid state storage, or the flash memory.</div>
<div class="description-paragraph" id="p-0005" num="0004">Other aspects and advantages of the embodiments will become apparent from the following detailed description taken in conjunction with the accompanying drawings which illustrate, by way of example, the principles of the described embodiments.</div>
<description-of-drawings>
<heading id="h-0003">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<div class="description-paragraph" id="p-0006" num="0005">The described embodiments and the advantages thereof may best be understood by reference to the following description taken in conjunction with the accompanying drawings. These drawings in no way limit any changes in form and detail that may be made to the described embodiments by one skilled in the art without departing from the spirit and scope of the described embodiments.</div>
<div class="description-paragraph" id="p-0007" num="0006"> <figref idrefs="DRAWINGS">FIG. 1</figref> is a perspective view of a storage cluster with multiple storage nodes and internal storage coupled to each storage node to provide network attached storage, in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0008" num="0007"> <figref idrefs="DRAWINGS">FIG. 2</figref> is a block diagram showing a communications interconnect coupling multiple storage nodes in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0009" num="0008"> <figref idrefs="DRAWINGS">FIG. 3</figref> is a multiple level block diagram, showing contents of a storage node and contents of one of the non-volatile solid-state storage units in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0010" num="0009"> <figref idrefs="DRAWINGS">FIG. 4</figref> is a block diagram showing a communication path for redundant copies of metadata, with further details of storage nodes and solid-state storages in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0011" num="0010"> <figref idrefs="DRAWINGS">FIG. 5</figref> is a block diagram of storage nodes with redundant remote procedure call caches in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0012" num="0011"> <figref idrefs="DRAWINGS">FIG. 6A</figref> is a configuration diagram of data stripes of differing sizes, i.e., differing stripe widths in some embodiments.</div>
<div class="description-paragraph" id="p-0013" num="0012"> <figref idrefs="DRAWINGS">FIG. 6B</figref> is a configuration diagram of data stripes across storage nodes of various memory capacities in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0014" num="0013"> <figref idrefs="DRAWINGS">FIG. 7</figref> is a flow diagram of a method for error recovery in a storage cluster, which can be practiced on or by embodiments of the storage cluster, storage nodes and/or solid-state storages disclosed herein in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0015" num="0014"> <figref idrefs="DRAWINGS">FIG. 8</figref> is an illustration showing an exemplary computing device which may implement the embodiments described herein.</div>
</description-of-drawings>
<heading id="h-0004">DETAILED DESCRIPTION</heading>
<div class="description-paragraph" id="p-0016" num="0015">The embodiments below describe a storage cluster that stores user data, such as user data originating from one or more user or client systems or other sources external to the storage cluster. The storage cluster distributes user data across storage nodes housed within a chassis, using erasure coding and redundant copies of metadata. Erasure coding refers to a method of data protection in which data is broken into fragments, expanded and encoded with redundant data pieces and stored across a set of different locations, such as disks, storage nodes or geographic locations. Flash memory is one type of solid-state memory that may be integrated with the embodiments, although the embodiments may be extended to other types of solid-state memory or other storage medium, including non-solid state memory. Control of storage locations and workloads are distributed across the storage locations in a clustered peer-to-peer system. Tasks such as mediating communications between the various storage nodes, detecting when a storage node has become unavailable, and balancing I/Os (inputs and outputs) across the various storage nodes, are all handled on a distributed basis. Data is laid out or distributed across multiple storage nodes in data fragments or stripes that support data recovery in some embodiments. Ownership of data can be reassigned within a cluster, independent of input and output patterns. This architecture described in more detail below allows a storage node in the cluster to fail, with the system remaining operational, since the data can be reconstructed from other storage nodes and thus remain available for input and output operations. In various embodiments, a storage node may be referred to as a cluster node, a blade, or a server.</div>
<div class="description-paragraph" id="p-0017" num="0016">The storage cluster is contained within a chassis, i.e., an enclosure housing one or more storage nodes. A mechanism to provide power to each storage node, such as a power distribution bus, and a communication mechanism, such as a communication bus that enables communication between the storage nodes are included within the chassis. The storage cluster can run as an independent system in one location according to some embodiments. In one embodiment, a chassis contains at least two instances of the power distribution and the internal and external communication bus which may be enabled or disabled independently. The internal communication bus may be an Ethernet bus, however, other technologies such as Peripheral Component Interconnect (PCI) Express, InfiniBand, and others, are equally suitable. The chassis provides a port for an external communication bus for enabling communication between multiple chassis, directly or through a switch, and with client systems. The external communication may use a technology such as Ethernet, InfiniBand, Fibre Channel, etc. In some embodiments, the external communication bus uses different communication bus technologies for inter-chassis and client communication. If a switch is deployed within or between chassis, the switch may act as a translation between multiple protocols or technologies. When multiple chassis are connected to define a storage cluster, the storage cluster may be accessed by a client using either proprietary interfaces or standard interfaces such as network file system (NFS), common internet file system (CIFS), small computer system interface (SCSI) or hypertext transfer protocol (HTTP). Translation from the client protocol may occur at the switch, chassis external communication bus or within each storage node.</div>
<div class="description-paragraph" id="p-0018" num="0017">Each storage node may be one or more storage servers and each storage server is connected to one or more non-volatile solid-state memory units, which may be referred to as storage units. One embodiment includes a single storage server in each storage node and between one to eight non-volatile solid-state memory units, however this one example is not meant to be limiting. The storage server may include a processor, dynamic random access memory (DRAM) and interfaces for the internal communication bus and power distribution for each of the power buses. Inside the storage node, the interfaces and storage unit share a communication bus, e.g., PCI Express, in some embodiments. The non-volatile solid-state memory units may directly access the internal communication bus interface through a storage node communication bus, or request the storage node to access the bus interface. The non-volatile solid-state memory unit contains an embedded central processing unit (CPU), solid-state storage controller, and a quantity of solid-state mass storage, e.g., between 2-32 terabytes (TB) in some embodiments. An embedded volatile storage medium, such as DRAM, and an energy reserve apparatus are included in the non-volatile solid-state memory unit. In some embodiments, the energy reserve apparatus is a capacitor, super-capacitor, or battery that enables transferring a subset of DRAM contents to a stable storage medium in the case of power loss. In some embodiments, the non-volatile solid-state memory unit is constructed with a storage class memory, such as phase change memory (PCM) or other resistive random access memory (RRAM) or magnetoresistive random access memory (MRAM) that substitutes for DRAM and enables a reduced power hold-up apparatus.</div>
<div class="description-paragraph" id="p-0019" num="0018">One of many features of the storage nodes and non-volatile solid-state storage is the ability to proactively rebuild data in a storage cluster. The storage nodes and non-volatile solid-state storage can determine when a storage node or non-volatile solid-state storage in the storage cluster is unreachable, independent of whether there is an attempt to read data involving that storage node or non-volatile solid-state storage. The storage nodes and non-volatile solid-state storage then cooperate to recover and rebuild the data in at least partially new locations. In some embodiments the proactive rebuild enables the system to rebuild data without waiting until the data is needed for a read access initiated from a client communicating with the storage cluster.</div>
<div class="description-paragraph" id="p-0020" num="0019">With various combinations of the above features, and as further described below with reference to <figref idrefs="DRAWINGS">FIGS. 1-8</figref>, embodiments of a storage cluster recover from errors using error recovery mechanisms at multiple levels from a flash die, a storage, or a storage node, up to the multiple storage nodes that make up the storage cluster. A storage cluster may recover from an error by directing a flash die to apply error correction code at the die level, by retrying reads of the flash die with statistical probability analysis and/or with multiple values of a reference voltage or current, or by applying erasure coding during a read of user data across non-volatile solid-state storages. The storage cluster may recover from an error by reconfiguring storage nodes or non-volatile solid-state storages to a new erasure coding scheme, and rebuilding user data. The storage cluster could recover from loss of metadata, or loss of a remote procedure call cache, by accessing a redundant copy of the metadata or a redundant remote procedure call cache. In some embodiments, the storage cluster can determine an error is occurring during a read of user data, a non-volatile solid-state storage or storage node is unreachable, resources have been removed, lost, replaced or added, data has been lost or is otherwise unavailable, or metadata has been lost or is otherwise unavailable. The storage cluster may determine which of multiple recovery mechanisms to engage to recover from these situations as discussed in more detail below.</div>
<div class="description-paragraph" id="p-0021" num="0020"> <figref idrefs="DRAWINGS">FIG. 1</figref> is a perspective view of a storage cluster <b>160</b>, with multiple storage nodes <b>150</b> and internal solid-state memory coupled to each storage node to provide network attached storage or storage area network, in accordance with some embodiments. A network attached storage, storage area network, or a storage cluster, or other storage memory, could include one or more storage clusters <b>160</b>, each having one or more storage nodes <b>150</b>, in a flexible and reconfigurable arrangement of both the physical components and the amount of storage memory provided thereby. The storage cluster <b>160</b> is designed to fit in a rack, and one or more racks can be set up and populated as desired for the storage memory. The storage cluster <b>160</b> has a chassis <b>138</b> having multiple slots <b>142</b>. It should be appreciated that chassis <b>138</b> may be referred to as a housing, enclosure, or rack unit. In one embodiment, the chassis <b>138</b> has fourteen slots <b>142</b>, although other numbers of slots are readily devised. For example, some embodiments have four slots, eight slots, sixteen slots, thirty-two slots, or other suitable number of slots. Each slot <b>142</b> can accommodate one storage node <b>150</b> in some embodiments. Chassis <b>138</b> includes flaps <b>148</b> that can be utilized to mount the chassis <b>138</b> on a rack. Fans <b>144</b> provide air circulation for cooling of the storage nodes <b>150</b> and components thereof, although other cooling components could be used, or an embodiment could be devised without cooling components. A switch fabric <b>146</b> couples storage nodes <b>150</b> within chassis <b>138</b> together and to a network for communication to the memory. In an embodiment depicted in <figref idrefs="DRAWINGS">FIG. 1</figref>, the slots <b>142</b> to the left of the switch fabric <b>146</b> and fans <b>144</b> are shown occupied by storage nodes <b>150</b>, while the slots <b>142</b> to the right of the switch fabric <b>146</b> and fans <b>144</b> are empty and available for insertion of storage node <b>150</b> for illustrative purposes. This configuration is one example, and one or more storage nodes <b>150</b> could occupy the slots <b>142</b> in various further arrangements. The storage node arrangements need not be sequential or adjacent in some embodiments. Storage nodes <b>150</b> are hot pluggable, meaning that a storage node <b>150</b> can be inserted into a slot <b>142</b> in the chassis <b>138</b>, or removed from a slot <b>142</b>, without stopping or powering down the system. Upon insertion or removal of storage node <b>150</b> from slot <b>142</b>, the system automatically reconfigures in order to recognize and adapt to the change. Reconfiguration, in some embodiments, includes restoring redundancy and/or rebalancing data or load.</div>
<div class="description-paragraph" id="p-0022" num="0021">Each storage node <b>150</b> can have multiple components. In the embodiment shown here, the storage node <b>150</b> includes a printed circuit board <b>158</b> populated by a CPU <b>156</b>, i.e., processor, a memory <b>154</b> coupled to the CPU <b>156</b>, and a non-volatile solid-state storage <b>152</b> coupled to the CPU <b>156</b>, although other mountings and/or components could be used in further embodiments. The memory <b>154</b> has instructions which are executed by the CPU <b>156</b> and/or data operated on by the CPU <b>156</b>. As further explained below, the non-volatile solid-state storage <b>152</b> includes flash or, in further embodiments, other types of solid-state memory.</div>
<div class="description-paragraph" id="p-0023" num="0022">Storage cluster <b>160</b> is scalable, meaning that storage capacity with non-uniform storage sizes is readily added, as described above. One or more storage nodes <b>150</b> can be plugged into or removed from each chassis and the storage cluster self-configures in some embodiments. Plug-in storage nodes <b>150</b>, whether installed in a chassis as delivered or later added, can have different sizes. For example, in one embodiment a storage node <b>150</b> can have any multiple of 4 TB, e.g., 8 TB, 12 TB, 16 TB, 32 TB, etc. In further embodiments, a storage node <b>150</b> could have any multiple of other storage amounts or capacities. Storage capacity of each storage node <b>150</b> is broadcast, and influences decisions of how to stripe the data. For maximum storage efficiency, an embodiment can self-configure as wide as possible in the stripe, subject to a predetermined requirement of continued operation with loss of up to one, or up to two, non-volatile solid-state storage units <b>152</b> or storage nodes <b>150</b> within the chassis.</div>
<div class="description-paragraph" id="p-0024" num="0023"> <figref idrefs="DRAWINGS">FIG. 2</figref> is a block diagram showing a communications interconnect <b>170</b> and power distribution bus <b>172</b> coupling multiple storage nodes <b>150</b>. Referring back to <figref idrefs="DRAWINGS">FIG. 1</figref>, the communications interconnect <b>170</b> can be included in or implemented with the switch fabric <b>146</b> in some embodiments. Where multiple storage clusters <b>160</b> occupy a rack, the communications interconnect <b>170</b> can be included in or implemented with a top of rack switch, in some embodiments. As illustrated in <figref idrefs="DRAWINGS">FIG. 2</figref>, storage cluster <b>160</b> is enclosed within a single chassis <b>138</b>. External port <b>176</b> is coupled to storage nodes <b>150</b> through communications interconnect <b>170</b>, while external port <b>174</b> is coupled directly to a storage node. External power port <b>178</b> is coupled to power distribution bus <b>172</b>. Storage nodes <b>150</b> may include varying amounts and differing capacities of non-volatile solid-state storage <b>152</b>. In addition, one or more storage nodes <b>150</b> may be a compute only storage node. Authorities <b>168</b> are implemented on the non-volatile solid-state storages <b>152</b>, for example as lists or other data structures stored in memory. In some embodiments the authorities are stored within the non-volatile solid-state storage <b>152</b> and supported by software executing on a controller or other processor of the non-volatile solid-state storage <b>152</b>. In a further embodiment, authorities <b>168</b> are implemented on the storage nodes <b>150</b>, for example as lists or other data structures stored in the memory <b>154</b> and supported by software executing on the CPU <b>156</b> of the storage node <b>150</b>. Authorities <b>168</b>, which can be viewed as roles that the storage nodes <b>150</b> take on, control how and where data is stored in the non-volatile solid-state storages <b>152</b> in some embodiments. This control assists in determining which type of erasure coding scheme is applied to the data, and which storage nodes <b>150</b> have which portions of the data. Each authority <b>168</b> may be assigned to a non-volatile solid-state storage <b>152</b>. Each authority may control a range of inode numbers, segment numbers, or other data identifiers which are assigned to data by a file system, by the storage nodes <b>150</b>, or by the non-volatile solid-state storage <b>152</b>, in various embodiments.</div>
<div class="description-paragraph" id="p-0025" num="0024">Every piece of data, and every piece of metadata, has redundancy in the system in some embodiments. In addition, every piece of data and every piece of metadata has an owner, which may be referred to as an authority. If that authority is unreachable, for example through failure of a storage node, there is a plan of succession for how to find that data or that metadata. In various embodiments, there are redundant copies of authorities <b>168</b>. Authorities <b>168</b> have a relationship to storage nodes <b>150</b> and non-volatile solid-state storage <b>152</b> in some embodiments. Each authority <b>168</b>, covering a range of data segment numbers or other identifiers of the data, may be assigned to a specific non-volatile solid-state storage <b>152</b>. In some embodiments the authorities <b>168</b> for all of such ranges are distributed over the non-volatile solid-state storages <b>152</b> of a storage cluster. Each storage node <b>150</b> has a network port that provides access to the non-volatile solid-state storage(s) <b>152</b> of that storage node <b>150</b>. Data can be stored in a segment, which is associated with a segment number and that segment number is an indirection for a configuration of a RAID (redundant array of independent disks) stripe in some embodiments. The assignment and use of the authorities <b>168</b> thus establishes an indirection to data. Indirection may be referred to as the ability to reference data indirectly, in this case via an authority <b>168</b>, in accordance with some embodiments. A segment identifies a set of non-volatile solid-state storage <b>152</b> and a local identifier into the set of non-volatile solid-state storage <b>152</b> that may contain data. In some embodiments, the local identifier is an offset into the device and may be reused sequentially by multiple segments. In other embodiments the local identifier is unique for a specific segment and never reused. The offsets in the non-volatile solid-state storage <b>152</b> are applied to locating data for writing to or reading from the non-volatile solid-state storage <b>152</b> (in the form of a RAID stripe). Data is striped across multiple units of non-volatile solid-state storage <b>152</b>, which may include or be different from the non-volatile solid-state storage <b>152</b> having the authority <b>168</b> for a particular data segment.</div>
<div class="description-paragraph" id="p-0026" num="0025">If there is a change in where a particular segment of data is located, e.g., during a data move or a data reconstruction, the authority <b>168</b> for that data segment should be consulted, at that non-volatile solid-state storage <b>152</b> or storage node <b>150</b> having that authority <b>168</b>. In order to locate a particular piece of data, embodiments calculate a hash value for a data segment or apply an inode number or a data segment number. The output of this operation points to a non-volatile solid-state storage <b>152</b> having the authority <b>168</b> for that particular piece of data. This non-volatile solid-state storage <b>152</b>, as the authority owner for the data segment, can coordinate a move or reconstruction of the data. In some embodiments there are two stages to this operation. The first stage maps an entity identifier (ID), e.g., a segment number, inode number, or directory number to an authority identifier. This mapping may include a calculation such as a hash or a bit mask. The second stage is mapping the authority identifier to a particular non-volatile solid-state storage <b>152</b>, which may be done through an explicit mapping. The operation is repeatable, so that when the calculation is performed, the result of the calculation repeatably and reliably points to a particular non-volatile solid-state storage <b>152</b> having that authority <b>168</b>. The operation may include the set of reachable storage nodes as input. If the set of reachable non-volatile solid-state storage units changes the optimal set changes. In some embodiments, the persisted value (i.e., the value that persistently results from the calculation) is the current assignment (which is always true) and the calculated value is the target assignment the cluster will attempt to reconfigure towards. This calculation may be used to determine the optimal non-volatile solid-state storage <b>152</b> for an authority in the presence of a set of non-volatile solid-state storage <b>152</b> that are reachable and constitute the same cluster. The calculation also determines an ordered set of peer non-volatile solid-state storages <b>152</b> that will also record the authority to non-volatile solid-state storage mapping so that the authority may be determined even if the assigned non-volatile solid-state storage is unreachable. A duplicate or substitute authority <b>168</b> may be consulted if a specific authority <b>168</b> is unavailable in some embodiments.</div>
<div class="description-paragraph" id="p-0027" num="0026">Two of the many tasks of the CPU <b>156</b> on a storage node <b>150</b> are to break up write data, and reassemble read data. When the system has determined that data is to be written, the authority <b>168</b> for that data is located as above. When the segment ID for data is determined, the request to write is forwarded to the non-volatile solid-state storage <b>152</b> currently determined to be the host of the authority <b>168</b> determined from the segment. The host CPU <b>156</b> of the storage node <b>150</b>, on which the non-volatile solid-state storage <b>152</b> and corresponding authority <b>168</b> reside, then breaks up or shards the data and transmits the data out to various non-volatile solid-state storages <b>152</b>. In some embodiments, the authority <b>168</b> for the data segment being written to may defer sharding and distributing data to be done asynchronously after establishing redundancy for that data itself. The transmitted data is written as a data stripe in accordance with an erasure coding scheme. In some embodiments, data is requested to be pulled, and in other embodiments, data is pushed. In reverse, when data is read, the authority <b>168</b> for the segment ID containing the data is located as described above. The host CPU <b>156</b> of the storage node <b>150</b> on which the non-volatile solid-state storage <b>152</b> and corresponding authority <b>168</b> reside requests the data from the non-volatile solid-state storage and corresponding storage nodes pointed to by the authority. In some embodiments the data is read from flash storage as a data stripe. The host CPU <b>156</b> of storage node <b>150</b> then reassembles the read data, correcting any errors (if present) according to the appropriate erasure coding scheme, and forwards the reassembled data to the network. In further embodiments, some or all of these tasks can be handled in the non-volatile solid-state storage <b>152</b>. In some embodiments, the segment host requests the data be sent to storage node <b>150</b> by requesting pages from storage and then sending the data to the storage node <b>150</b> making the original request. In some embodiments, a stripe width is only read if there is a single page read failure or delay.</div>
<div class="description-paragraph" id="p-0028" num="0027">In some systems, for example in UNIX-style file systems, data is handled with an index node or inode, which specifies a data structure that represents an object in a file system. The object could be a file or a directory, for example. Metadata may accompany the object, as attributes such as permission data and a creation timestamp, among other attributes. A segment number could be assigned to all or a portion of such an object in a file system. In other systems, data segments are handled with a segment number assigned elsewhere. For purposes of discussion, the unit of distribution is an entity, and an entity can be a file, a directory or a segment. That is, entities are units of data or metadata stored by a storage system. Entities are grouped into sets called authorities. Each authority has an authority owner, which is a storage node that has the exclusive right to update the entities in the authority. In other words, a storage node contains the authority, and that the authority, in turn, contains entities.</div>
<div class="description-paragraph" id="p-0029" num="0028">A segment is a logical container of data in accordance with some embodiments. A segment is an address space between medium address space and physical flash locations, i.e., the data segment number, are in this address space. Segments may also contain metadata, which enable data redundancy to be restored (rewritten to different flash locations or devices) without the involvement of higher level software. In one embodiment, an internal format of a segment contains client data and medium mappings to determine the position of that data. Each data segment is protected, e.g., from memory and other failures, by breaking the segment into a number of data and parity shards, where applicable. The data and parity shards are distributed, i.e., striped, across non-volatile solid-state storage <b>152</b> coupled to the host CPUs <b>156</b> in accordance with an erasure coding scheme. Usage of the term segments refers to the container and its place in the address space of segments in some embodiments. Usage of the term stripe refers to the same set of shards as a segment and includes how the shards are distributed along with redundancy or parity information in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0030" num="0029">A series of address-space transformations takes place across an entire storage system. At the top are the directory entries (file names) which link to an inode. Modes point into medium address space, where data is logically stored. Medium addresses may be mapped through a series of indirect mediums to spread the load of large files, or implement data services like deduplication or snapshots. Medium addresses may be mapped through a series of indirect mediums to spread the load of large files, or implement data services like deduplication or snapshots. Segment addresses are then translated into physical flash locations. Physical flash locations have an address range bounded by the amount of flash in the system in accordance with some embodiments. Medium addresses and segment addresses are logical containers, and in some embodiments use a 128 bit or larger identifier so as to be practically infinite, with a likelihood of reuse calculated as longer than the expected life of the system. Addresses from logical containers are allocated in a hierarchical fashion in some embodiments. Initially, each non-volatile solid-state storage <b>152</b> may be assigned a range of address space. Within this assigned range, the non-volatile solid-state storage <b>152</b> is able to allocate addresses without synchronization with other non-volatile solid-state storage <b>152</b>.</div>
<div class="description-paragraph" id="p-0031" num="0030">Data and metadata is stored by a set of underlying storage layouts that are optimized for varying workload patterns and storage devices. These layouts incorporate multiple redundancy schemes, compression formats and index algorithms. Some of these layouts store information about authorities and authority masters, while others store file metadata and file data. The redundancy schemes include error correction codes that tolerate corrupted bits within a single storage device (such as a NAND flash chip), erasure codes that tolerate the failure of multiple storage nodes, and replication schemes that tolerate data center or regional failures. In some embodiments, low density parity check (LDPC) code is used within a single storage unit. Reed-Solomon encoding is used within a storage cluster, and mirroring is used within a storage grid in some embodiments. Metadata may be stored using an ordered log structured index (such as a Log Structured Merge Tree), and large data may not be stored in a log structured layout.</div>
<div class="description-paragraph" id="p-0032" num="0031">In order to maintain consistency across multiple copies of an entity, the storage nodes agree implicitly on two things through calculations: (1) the authority that contains the entity, and (2) the storage node that contains the authority. The assignment of entities to authorities can be done by pseudorandomly assigning entities to authorities, by splitting entities into ranges based upon an externally produced key, or by placing a single entity into each authority. Examples of pseudorandom schemes are linear hashing and the Replication Under Scalable Hashing (RUSH) family of hashes, including Controlled Replication Under Scalable Hashing (CRUSH). In some embodiments, pseudo-random assignment is utilized only for assigning authorities to nodes because the set of nodes can change. The set of authorities cannot change so any subjective function may be applied in these embodiments. Some placement schemes automatically place authorities on storage nodes, while other placement schemes rely on an explicit mapping of authorities to storage nodes. In some embodiments, a pseudorandom scheme is utilized to map from each authority to a set of candidate authority owners. A pseudorandom data distribution function related to CRUSH may assign authorities to storage nodes and create a list of where the authorities are assigned. Each storage node has a copy of the pseudorandom data distribution function, and can arrive at the same calculation for distributing, and later finding or locating an authority. Each of the pseudorandom schemes requires the reachable set of storage nodes as input in some embodiments in order to conclude the same target nodes. Once an entity has been placed in an authority, the entity may be stored on physical devices so that no expected failure will lead to unexpected data loss. In some embodiments, rebalancing algorithms attempt to store the copies of all entities within an authority in the same layout and on the same set of machines.</div>
<div class="description-paragraph" id="p-0033" num="0032">Authority owners have the exclusive right to modify entities, to migrate entities from one non-volatile solid-state storage unit to another non-volatile solid-state storage unit, and to add and remove copies of entities. This allows for maintaining the redundancy of the underlying data. When an authority owner fails, is going to be decommissioned, or is overloaded, the authority is transferred to a new storage node. Transient failures make it non-trivial to ensure that all non-faulty machines agree upon the new authority location. The ambiguity that arises due to transient failures can be achieved automatically by a consensus protocol such as Paxos, hot-warm failover schemes, via manual intervention by a remote system administrator, or by a local hardware administrator (such as by physically removing the failed machine from the cluster, or pressing a button on the failed matching). In some embodiments, a consensus protocol is used, and failover is automatic. If too many failures or replication events occur in too short a time period, the system goes into a self-preservation mode and halts replication and data movement activities until an administrator intervenes in accordance with some embodiments.</div>
<div class="description-paragraph" id="p-0034" num="0033">As authorities are transferred between storage nodes and authority owners update entities in their authorities, the system transfers messages between the storage nodes and non-volatile solid-state storage units. With regard to persistent messages, messages that have different purposes are of different types. Depending on the type of the message, the system maintains different ordering and durability guarantees. As the persistent messages are being processed, the messages are temporarily stored in multiple durable and non-durable storage hardware technologies. In some embodiments, messages are stored in RAM, NVRAM and on NAND flash devices, and a variety of protocols are used in order to make efficient use of each storage medium. Latency-sensitive client requests may be persisted in replicated NVRAM, and then later NAND, while background rebalancing operations are persisted directly to NAND.</div>
<div class="description-paragraph" id="p-0035" num="0034">Persistent messages are persistently stored prior to being replicated. This allows the system to continue to serve client requests despite failures and component replacement. Although many hardware components contain unique identifiers that are visible to system administrators, manufacturers, hardware supply chains and ongoing monitoring quality control infrastructure, applications running on top of the infrastructure can address virtualized addresses. These virtualized addresses do not change over the lifetime of the storage system, regardless of component failures and replacements. This allows each component of the storage system to be replaced over time without reconfiguration or disruptions of client request processing.</div>
<div class="description-paragraph" id="p-0036" num="0035">In some embodiments, the virtualized addresses are stored with sufficient redundancy. A continuous monitoring system correlates hardware and software status and the hardware identifiers. This allows detection and prediction of failures due to faulty components and manufacturing details. The monitoring system also enables the proactive transfer of authorities and entities away from impacted devices before failure occurs by removing the component from the critical path in some embodiments.</div>
<div class="description-paragraph" id="p-0037" num="0036">In addition to component redundancy in the communication channel, storage cluster <b>160</b> is configured to allow for the loss of one or more storage nodes <b>150</b>. In some embodiments this cluster redundancy level may be one for relatively small storage clusters <b>160</b> (less than 8 storage nodes <b>150</b>) and two for relatively larger storage clusters <b>160</b> (8 or more storage nodes <b>150</b>) although any number would be suitable for the cluster redundancy level. In some embodiments, where more storage nodes <b>150</b> than the redundancy level are lost, the storage cluster <b>160</b> cannot guarantee availability of data or integrity of future updates. As mentioned above, data redundancy is implemented via segments. A segment is formed by selecting equal sized shards from a subset of the non-volatile solid-state storage <b>152</b>, each within a different storage node <b>150</b>. Shards are reserved to establish the redundancy level, e.g., one or two, and then a remainder constitutes the data (the data shards). The shards are encoded using an ECC scheme such as parity or Reed-Soloman (RAID 6), so that any subset of the shards equal in count to the data shards may be used to reconstruct the complete data. The storage cluster redundancy represents a minimum level of redundancy and it may be exceeded for any individual data element. Segments are stored as a set of non-volatile solid-state storage units, roles (data position or parity) and allocation unit local to each non-volatile solid-state storage unit. The allocation units may be a physical address or an indirection determined within the non-volatile solid-state storage <b>152</b>. Each shard may be portioned into pages and each page into code words. In some embodiments, the pages are between about 4 kilobytes (kB) and 64 kB, e.g., 16 kB, while the code words are between about 512 bytes to 4 kB, e.g., 1 kB. These sizes are one example and not meant to be limiting as any suitable size for the code words and the pages may be utilized. The code words contain local error correction and a checksum to verify the error correction was successful. This checksum is “salted” with the logical address of the contents meaning that a failure to match the checksum may occur if the data is uncorrectable or misplaced. In some embodiments, when a code word fails a checksum it is converted to an “erasure” for purpose of the error correction algorithm so that the code word may be rebuilt.</div>
<div class="description-paragraph" id="p-0038" num="0037"> <figref idrefs="DRAWINGS">FIG. 3</figref> is a multiple level block diagram, showing contents of a storage node <b>150</b> and contents of a non-volatile solid-state storage <b>152</b> of the storage node <b>150</b>. Data is communicated to and from the storage node <b>150</b> by a network interface controller (NIC) <b>202</b> in some embodiments. Each storage node <b>150</b> has a CPU <b>156</b>, and one or more non-volatile solid-state storage <b>152</b>, as discussed above. Moving down one level in <figref idrefs="DRAWINGS">FIG. 3</figref>, each non-volatile solid-state storage <b>152</b> has a relatively fast non-volatile solid-state memory, such as non-volatile random access memory (NVRAM) <b>204</b>, and flash memory <b>206</b>. In some embodiments, NVRAM <b>204</b> may be a component that does not require program/erase cycles (DRAM, MRAM, PCM), and can be a memory that can support being written vastly more often than the memory is read from. Moving down another level in <figref idrefs="DRAWINGS">FIG. 3</figref>, the NVRAM <b>204</b> is implemented in one embodiment as high speed volatile memory, such as dynamic random access memory (DRAM) <b>216</b>, backed up by energy reserve <b>218</b>. Energy reserve <b>218</b> provides sufficient electrical power to keep the DRAM <b>216</b> powered long enough for contents to be transferred to the flash memory <b>206</b> in the event of power failure. In some embodiments, energy reserve <b>218</b> is a capacitor, super-capacitor, battery, or other device, that supplies a suitable supply of energy sufficient to enable the transfer of the contents of DRAM <b>216</b> to a stable storage medium in the case of power loss. The flash memory <b>206</b> is implemented as multiple flash dies <b>222</b>, which may be referred to as packages of flash dies <b>222</b> or an array of flash dies <b>222</b>. It should be appreciated that the flash dies <b>222</b> could be packaged in any number of ways, with a single die per package, multiple dies per package (i.e. multichip packages), in hybrid packages, as dies on a printed circuit board or other substrate. In some embodiments, the hybrid package may include a combination of memory types, such as NVRAM, random access memory (RAM), CPU, field programmable gate array (FPGA), or different sized flash memory in the same package. In the embodiment shown, the non-volatile solid-state storage <b>152</b> has a controller <b>212</b> or other processor, and an input output (I/O) port <b>210</b> coupled to the controller <b>212</b>. I/O port <b>210</b> is coupled to the CPU <b>156</b> and/or the network interface controller <b>202</b> of the flash storage node <b>150</b>. Flash input output (I/O) port <b>220</b> is coupled to the flash dies <b>222</b>, and a direct memory access unit (DMA) <b>214</b> is coupled to the controller <b>212</b>, the DRAM <b>216</b> and the flash dies <b>222</b>. In the embodiment shown, the I/O port <b>210</b>, controller <b>212</b>, DMA unit <b>214</b> and flash I/O port <b>220</b> are implemented on a programmable logic device (PLD) <b>208</b>, e.g., a field programmable gate array (FPGA). In this embodiment, each flash die <b>222</b> has pages, organized as sixteen kB (kilobyte) pages <b>224</b>, and a register <b>226</b> through which data can be written to or read from the flash die <b>222</b>. In further embodiments, other types of solid-state memory are used in place of, or in addition to flash memory illustrated within flash die <b>222</b>.</div>
<div class="description-paragraph" id="p-0039" num="0038">In some embodiments, flash dies <b>222</b> have the ability to perform error correction, e.g., using error correction code, internal to the flash die <b>222</b>. A non-volatile solid-state storage <b>152</b> having such a flash die <b>222</b> could recover from a read error internal to the flash die <b>222</b> by having the flash die <b>222</b> apply the error correction internally. In some embodiments, flash dies <b>222</b> have the ability to change a level at which a read is performed, for example by changing a reference voltage or a reference current internal to the flash die <b>222</b>. The reference voltage or a reference current may be supplied external to the flash die <b>222</b>. A non-volatile solid-state storage <b>152</b> having such a flash die could recover from a read error internal to the flash die <b>222</b> by having the flash die perform multiple retries, with multiple levels of the reference voltage or current. In some embodiments, a non-volatile solid-state storage <b>152</b> could perform multiple retries of a read from a flash die <b>222</b>, with or without the above mentioned capabilities of the flash die <b>222</b>, and perform probabilistic calculations as to whether the data is more likely to be a “1” or a “0”.</div>
<div class="description-paragraph" id="p-0040" num="0039"> <figref idrefs="DRAWINGS">FIG. 4</figref> is a block diagram showing a communication path or redundant copies of metadata, with further details of flash storage nodes and non-volatile solid-state storage units in accordance with some embodiments. Metadata <b>230</b> includes information about the user data that is written to or read from the flash memory <b>206</b>. Metadata <b>230</b> can include messages, or derivations from the messages, indicating actions to be taken or actions that have taken place involving the data that is written to or read from the flash memory <b>206</b>. Distributing redundant copies of metadata <b>230</b> to the non-volatile solid-state storage units <b>152</b> through the communications interconnect <b>170</b> ensures that messages are persisted and can survive various types of failure the system may experience. Each non-volatile solid-state storage <b>152</b> dedicates a portion of the NVRAM <b>204</b> to storing metadata <b>230</b>. In many embodiments, redundant copies of metadata <b>230</b> are stored in the additional non-volatile solid-state storage <b>152</b>.</div>
<div class="description-paragraph" id="p-0041" num="0040">Flash storage nodes <b>150</b> are coupled via the communication interconnect <b>170</b> (as described above with reference to <figref idrefs="DRAWINGS">FIG. 2</figref>). More specifically, the network interface controller <b>202</b> of each storage node <b>150</b> in the storage cluster is coupled to the communication interconnect <b>170</b>, providing a communication path <b>234</b> among storage nodes <b>150</b> and non-volatile solid-state storage <b>152</b>. Embodiments of storage nodes <b>150</b> have one or more non-volatile solid-state storage <b>152</b>, as described above. Non-volatile solid-state storage <b>152</b> internal to a storage node can communicate with each other, for example via a bus, a serial communication path, a network path or other communication path <b>234</b> as readily devised in accordance with the embodiments disclosed herein.</div>
<div class="description-paragraph" id="p-0042" num="0041">Referring to <figref idrefs="DRAWINGS">FIGS. 3 and 4</figref>, in case of a power failure, whether local to non-volatile solid-state storage <b>152</b> or a storage node <b>150</b>, data can be copied from the NVRAM <b>204</b> to the flash memory <b>206</b>, if necessary, i.e., later versions of NVRAM may be persistent, such as PCM. For example, the DMA unit <b>214</b> (as seen in <figref idrefs="DRAWINGS">FIG. 3</figref>) can copy contents of the NVRAM <b>204</b>, including the metadata, to the flash memory <b>206</b>, using power supplied by the energy reserve <b>218</b>. Energy reserve <b>218</b> (shown in <figref idrefs="DRAWINGS">FIG. 3</figref>) should be sized with sufficient capacity to support copy operation. That is energy reserve <b>218</b> should be sized so as to provide sufficient current at a sufficient voltage level for a time duration long enough to complete the copying. Messages that are in metadata <b>230</b> are persisted in the flash memory <b>206</b>, in case of a power failure under this mechanism.</div>
<div class="description-paragraph" id="p-0043" num="0042">A further mechanism for persisting messages in a storage system involves the communication path <b>234</b> described above in <figref idrefs="DRAWINGS">FIG. 4</figref>. Redundant copies of the metadata <b>230</b> can be distributed via the communication path <b>234</b>, in various ways. For example, a message coming from the filesystem could be distributed via the communication interconnect <b>170</b> as a broadcast over the communication path <b>234</b> to all of the non-volatile solid-state storage <b>152</b>. A non-volatile solid-state storage <b>152</b> could send a copy of metadata <b>230</b> over the communication path <b>234</b> to other solid-non-volatile solid-state storage <b>152</b> in a storage node <b>150</b>. In some embodiments, CPU <b>156</b> on a storage node <b>150</b>, receiving a message from the communication interconnect <b>170</b> via the network interface controller <b>202</b> could send a copy of the message to each solid-state storage <b>152</b>. The CPU <b>156</b> on a flash storage node <b>150</b> could rebroadcast the message to other flash storage nodes <b>150</b>, and the flash storage nodes <b>150</b> could then distribute the message to the solid-state storages <b>152</b> in each of these flash storage nodes <b>150</b>. In these and other uses of the communication path <b>234</b>, redundant copies of the metadata <b>230</b> are distributed to the non-volatile solid-state storage <b>152</b>. If one non-volatile solid-state storage unit <b>152</b>, or one storage node <b>150</b> experiences a failure, redundant copies of any message of that non-volatile solid-state storage unit <b>152</b> or that storage node <b>150</b> are available in metadata <b>230</b> of other non-volatile solid-state storage <b>152</b>. Each non-volatile solid-state storage <b>152</b> can apply decision logic <b>232</b> when evaluating various situations such as local power failure, an unreachable node, or a suggestion from a CPU <b>156</b>, or from a controller <b>212</b>, to consider or commence a data recovery or a data rebuild. The decision logic <b>232</b> includes witnessing logic, voting logic, consensus logic and/or other types of decision logic in various embodiments. Decision logic <b>232</b> could be implemented in hardware, software executing on the controller <b>212</b>, firmware, or combinations thereof, and could be implemented as part of the controller <b>212</b> or coupled to the controller <b>212</b>. The decision logic <b>232</b> is employed in consensus decisions among multiple solid-state storages <b>152</b>, in some embodiments. In further embodiments, the decision logic <b>232</b> could cooperate with the other solid-state storages <b>152</b> in order to gather copies of the redundant metadata <b>230</b>, and make local decisions. The mechanisms for persisting messages in a storage system are useful in the event of a failure, and can be used in data recovery and reconstruction as described above.</div>
<div class="description-paragraph" id="p-0044" num="0043">In some embodiments, flash memory can be written to once per location, until an entire block is erased, at which point flash memory can be written to again. If a failure occurs during a block erasure, or after a block erasure but prior to rewriting the flash memory, data corruption may result. Some actions span storage servers, such as writing data across a data stripe, and these messages use cluster messaging. If a failure occurs in the middle of such a data write, part of the stripe could be written and part of the stripe not written. Likewise, if a failure occurs in the middle of a data read, part of the stripe could be read and part of the stripe not read. If a file is created, and the file is in a directory, there are two records, one record is a directive and the other is the directory itself. In the instance of a failure, and only one of these has occurred, corruption results. The directive could indicate completion so that the file is created and stored, but the directory does not show the correct location or existence of the file. In some instances the directory may show the existence of a file in a directory tree, but there is no actual file in the storage.</div>
<div class="description-paragraph" id="p-0045" num="0044">Examples of messages include a request to write data, a request to read data, a request to lock or unlock a file, a change in permission of a file, an update to a file allocation table or other file or directory structure, a request to write a file that has executable instructions or to write a file name that is reserved and interpreted as an executable directory, updates to one or more authorities <b>168</b>, updates to a fingerprint table, list or other data used in deduplication, updates to hash tables, updates to logs, and so on. When a message is received in non-volatile solid-state storage <b>152</b> of a storage node <b>150</b>, indicating some action has taken place, the message or a derivation of the message is stored as metadata <b>230</b> in the NVRAM <b>204</b> of that solid-state storage <b>152</b>. By applying the redundant copies of the metadata <b>230</b>, actions are captured that are in progress, so that if a failure happens, these actions can be replayed and replacement actions can then be performed, for example upon restart. Actions span storage nodes and use cluster messaging, so the act of sending a message can be made persistent data via one or more of the mechanisms for persisting messages. In some embodiments, these messages don't require permanence beyond completion of the actions. In other embodiments these messages are further retained to facilitate rollback or other recovery operations.</div>
<div class="description-paragraph" id="p-0046" num="0045">For example, if a command is sent out to carry out a write operation, this message is recorded and redundant. If there is a failure, it can be determined whether or not that action has been carried out, and whether or not the action should be driven to completion. Such determination can be carried out using the decision logic <b>232</b> in each non-volatile solid-state storage <b>152</b>. There is dedicated storage in NVRAM <b>204</b> for messages and other metadata <b>230</b>, so that messages are recorded in the non-volatile solid-state storage <b>152</b> and replicated in some embodiments. The messages and other metadata <b>230</b> are written into flash memory <b>206</b> if one non-volatile solid-state storage <b>152</b> experiences a power failure, or if the entire system experiences a power failure or otherwise shuts down. The redundancy level of the messages thus matches the redundancy level of the metadata in some embodiments. When there are sufficient numbers of copies of messages, the message becomes irrevocable. If one node goes down, other nodes can vote, achieve consensus, or witness the various copies of the message and determine what action, if any, to carry to completion. If the entire system goes down, e.g., through a global power failure, then a sufficient number of these messages are written from NVRAM <b>204</b> to flash memory <b>206</b>, so that upon restoration of power, the nodes can again open copies of the message and determine what action, if any, to carry to completion. It should be appreciated that the above mechanisms and actions prevent the sorts of corruptions described above.</div>
<div class="description-paragraph" id="p-0047" num="0046">Commands can come in the form of remote procedure calls, in various embodiments. A remote procedure call can be initiated by a client, and executed on one of the storage nodes <b>150</b> in the storage cluster <b>160</b>. Some embodiments of the storage nodes <b>150</b> have redundant remote procedure call caches <b>354</b>, <b>356</b>, as described below with reference to <figref idrefs="DRAWINGS">FIG. 5</figref>. Remote procedure call caches offer fault tolerance that protects the system against loss of a remote procedure call in event of a failure. Some embodiments of the storage nodes <b>150</b> support multiple filesystems contemporaneously. Combining embodiments of the storage nodes <b>150</b> with redundant remote procedure call caches and the support for multiple filesystems offers fault-tolerant operation under multiple filesystems. It should be appreciated that a remote procedure call refers to a technology that allows a computer program to cause a subroutine or procedure to execute in another address space, commonly on another computing device on a shared network, without a programmer explicitly coding the details for this remote interaction in some embodiments.</div>
<div class="description-paragraph" id="p-0048" num="0047">In the above scenarios, the client could be operating over Internet Protocol, which may or may not be reliable. As an example, the client may retransmit a remote procedure call, but, meanwhile, the filesystem might have actually responded, which can lead to inconsistency (e.g. due to multiple executions of the same remote procedure call). A measure of fault tolerance, employing redundant remote procedure call caches can mitigate these potential problems, as described below.</div>
<div class="description-paragraph" id="p-0049" num="0048"> <figref idrefs="DRAWINGS">FIG. 5</figref> is a block diagram of storage nodes <b>150</b> with redundant remote procedure call caches <b>354</b>, <b>356</b> in accordance with some embodiments. Each storage node <b>150</b> has an authority assignment table <b>352</b>, a remote procedure call cache <b>354</b>, and one or more mirrored remote procedure call caches <b>356</b>. The remote procedure call cache <b>354</b> is located where the authority is located in order to minimize risk of breakage in a communication path between the location of the authority and the location of the remote procedure call cache <b>354</b> in some embodiments. Locating the remote procedure call cache <b>354</b> distant from the location of the authority is possible but may increase delays and increase risk of such breakage of a communication path.</div>
<div class="description-paragraph" id="p-0050" num="0049">In various embodiments, the remote procedure call cache <b>354</b> and mirrored remote procedure call cache <b>356</b> are implemented in the memory <b>154</b> coupled to the CPU <b>156</b> of a storage node <b>150</b> (see <figref idrefs="DRAWINGS">FIG. 1</figref>) or in the non-volatile random access memory <b>204</b> of the non-volatile solid-state storage <b>152</b> (see <figref idrefs="DRAWINGS">FIG. 3</figref>). In other embodiments, the remote procedure call cache <b>354</b> and mirrored remote procedure call cache <b>356</b> are implemented in the dynamic random access memory <b>216</b> coupled to the controller <b>212</b> in the non-volatile solid-state storage <b>152</b>, in the flash <b>206</b> in the non-volatile solid-state storage <b>152</b>, or in flash memory on a storage node <b>150</b>. In one embodiment, the remote procedure call cache <b>354</b> and one or more mirrored remote procedure call caches <b>356</b> are implemented as metadata <b>230</b> in the non-volatile random access memory <b>204</b> of the non-volatile solid-state storage <b>152</b>. In operation, a storage node <b>150</b> mirrors the remote procedure call cache <b>354</b> in at least one other storage node <b>150</b> of the storage cluster.</div>
<div class="description-paragraph" id="p-0051" num="0050">When a remote procedure call arrives for servicing, the storage node <b>150</b> or the non-volatile solid-state storage <b>152</b> determines whether the remote procedure call has already been serviced. This can be accomplished by checking the remote procedure call cache <b>354</b> to see if a result is already posted, i.e., the result of servicing the remote procedure call is available. For example, the result could be an acknowledgment that a data write or update to a directory structure has taken place, or the result could be error corrected data from a data read. If a result has been posted, the result is returned as a response to the remote procedure call, but the servicing internal to the storage node <b>150</b> or the non-volatile solid-state storage <b>152</b> is not repeated. In this manner, a repeated remote procedure call can be answered without causing inconsistency in the storage node <b>150</b> and/or non-volatile solid-state storage <b>152</b>.</div>
<div class="description-paragraph" id="p-0052" num="0051">In a case where the remote procedure call cache <b>354</b> is unreachable, one or more of the remaining storage nodes <b>150</b> or non-volatile solid-state storages <b>152</b> locates the corresponding mirrored remote procedure call cache <b>356</b> and determines whether a result of servicing the remote procedure call is already posted. This scenario could occur, for example, if the non-volatile solid-state storage <b>152</b> or the storage node <b>150</b> having the remote procedure call cache <b>354</b> is unresponsive or otherwise unreachable. The result, if available from the mirrored remote procedure call cache <b>356</b>, is then returned as above. If there is no result, from either the remote procedure call cache <b>354</b> or the mirrored remote procedure call cache <b>356</b> as appropriate, the remote procedure call is serviced and responded to with the result of that service.</div>
<div class="description-paragraph" id="p-0053" num="0052">In one embodiment, each storage node <b>150</b> mirrors the remote procedure call cache <b>354</b> in two other storage nodes <b>150</b>, as depicted in <figref idrefs="DRAWINGS">FIG. 5</figref>. For example, the leftmost storage node <b>150</b> could send a copy of the contents of the remote procedure call cache <b>354</b> to two other storage nodes <b>150</b>. Each of these other storage nodes <b>150</b> would place the copied contents of the remote procedure call cache <b>354</b> in a mirrored remote procedure call cache <b>356</b> of that storage node <b>150</b> as depicted by the arrows in <figref idrefs="DRAWINGS">FIG. 5</figref>. Each remote procedure call message has a unique transaction identifier, assigned by the client, uniquely identifying the transaction. If a storage node <b>150</b> is unreachable (whether permanently or temporarily), a copy of the remote procedure call cache <b>354</b> is available in at least one other storage node <b>150</b>, e.g., in a mirrored remote procedure call cache <b>356</b>. Each remote procedure call cache <b>354</b>, and mirrored remote procedure call cache <b>356</b>, contains the transaction identifier, the client identifier, and the result (e.g., an indication of whether or not the action is complete), in one embodiment. The remote procedure call and information relating thereto as stored in the remote procedure call cache <b>354</b>, are forms of metadata in some embodiments.</div>
<div class="description-paragraph" id="p-0054" num="0053">In one embodiment, each storage node <b>150</b> consults the table <b>352</b> resident in that storage node <b>150</b>. For example, table <b>352</b> could reside in the memory of the storage node <b>150</b>, or the memory of a non-volatile solid-state storage <b>152</b> of the storage node <b>150</b>, and so on. The remote procedure call cache <b>354</b> is maintained for an authority for which that storage node <b>150</b> has primary authority, as indicated in table <b>352</b>. The storage node <b>150</b> mirrors the remote procedure call cache <b>354</b>, by sending updates (copies) of the contents of the remote procedure call cache <b>354</b> to the storage node <b>150</b> identified as having the first backup authority, and to the storage node <b>150</b> identified as having the second backup authority, according to the table <b>352</b>. In further embodiments, additional copies of the remote procedure call cache <b>354</b> could be mirrored, or the copies and mirror caches could be distributed in a different manner. Locations of the mirrored remote procedure call caches <b>356</b> could be tracked by another table or tracking mechanism instead of table <b>352</b> in other embodiments.</div>
<div class="description-paragraph" id="p-0055" num="0054">In a scenario where a mirrored remote procedure call cache <b>356</b> belonging to a non-volatile solid-state storage <b>152</b> or a storage node <b>150</b> is unreachable (e.g., if the solid-state storage <b>152</b> or non-volatile storage node <b>150</b> itself is unreachable), the remaining storage nodes <b>150</b> can determine and assign a replacement mirrored remote procedure call cache <b>356</b>. The determination and assignment of a replacement mirrored remote procedure call cache <b>356</b> may include applying one or more mechanisms, such as witnessing, voting, volunteering, consulting the table <b>352</b> to find a backup authority and assigning the mirrored remote procedure call cache <b>356</b> to the same node as has the backup authority, and so on. In some embodiments, a mirrored remote procedure call cache <b>356</b> could be assigned to a differing node than the node having the backup authority. Once the replacement mirrored remote procedure call cache <b>356</b> is determined, the storage node <b>150</b> corresponding to the replacement mirrored remote procedure call cache <b>356</b> can mirror the remote procedure call cache <b>354</b> to the mirrored remote procedure call cache <b>356</b>. The remote procedure call may then be serviced and responded to with a result. In some embodiments, remote procedure call entries to the remote procedure call cache <b>354</b> and/or the mirrored remote procedure call cache(s) <b>356</b> are deleted after a time expires, e.g., through the use of one or more timers, or timestamps, etc.</div>
<div class="description-paragraph" id="p-0056" num="0055">The ability to change configuration of data stripes <b>314</b> is another one of many features of storage nodes <b>150</b> and non-volatile solid-state storages <b>152</b>. In the examples of <figref idrefs="DRAWINGS">FIGS. 6A and 6B</figref> data is stored in the form of data stripes <b>314</b>, <b>326</b>, <b>338</b>, <b>340</b>, <b>342</b>, <b>344</b>, in which data is sharded, i.e., broken up and distributed, across multiple storage nodes <b>150</b>. In some embodiments, data can be striped across non-volatile solid-state storages <b>152</b> in a storage node <b>150</b> or in multiple storage nodes <b>150</b>. Various RAID configurations and associated data striping schemes and levels of redundancy are possible, as controlled by the authority <b>168</b> for each data segment. A storage node <b>150</b> having an authority <b>168</b> for a specified data segment could be a storage node <b>150</b> acting as a data server, a storage node <b>150</b> acting as a parity server, or a storage node <b>150</b> having no solid-state storage <b>152</b> (compute only). In various arrangements, each storage node <b>150</b>, or each non-volatile solid-state storage <b>152</b>, provides one bit of data or one parity bit, for a data stripe <b>314</b>. Various embodiments implement an error correction code (ECC) that allows recovery of data even if one or two storage nodes <b>150</b> fail or are unavailable. In some embodiments, the storage node holding the authority <b>168</b> determines which RAID scheme or level and authority <b>168</b> points to the data stripe <b>314</b>. Data striping can be applied at a bit level, byte level or block level, and further data striping schemes are possible. In some versions, a storage node <b>150</b>, or a solid-state storage <b>152</b>, could contribute more than one bit to a data stripe <b>314</b>. In some embodiments, an error correction code calculation is performed at each non-volatile solid-state storage <b>152</b>, for the shard of data. That shard of data, corrected as needed, is sent back to the storage node <b>150</b> that has the authority <b>168</b> for the data, where the data is reassembled. More than one stripe type, or RAID scheme or level, can be present across the storage nodes <b>150</b> (i.e., coexist in the storage cluster <b>160</b>), in some embodiments.</div>
<div class="description-paragraph" id="p-0057" num="0056"> <figref idrefs="DRAWINGS">FIG. 6A</figref> is a configuration diagram of data stripes <b>314</b>, <b>326</b> of differing sizes, i.e., differing stripe widths. These data stripes <b>314</b>, <b>326</b> coexist across the storage nodes <b>150</b>, or in some embodiments coexist across non-volatile solid-state storage <b>152</b>. For example, one data stripe <b>326</b> is sharded across the three storage nodes <b>150</b> in a RAID scheme or level having double redundancy. Identical copies of the data from a first storage node <b>150</b> are present in each of the second storage node <b>150</b> and the third storage node <b>150</b>. Since this version of data recovery, in the example data stripe <b>326</b>, requires two identical copies of data, the storage overhead is 200% more than the data storage capacity. In other words, the relative total storage amount is (N+2N) divided by N, which equals three, for N bits of data, and this is independent of N. Another data stripe <b>314</b> is sharded across storage nodes <b>150</b> acting as data servers and across storage nodes <b>150</b> acting as parity servers providing the p and q parity bits. User data is written to and read from the storage nodes <b>150</b> in accordance with a RAID scheme or level having two parity bits, i.e., parity bit p and parity bit q, in this data stripe <b>314</b>. Since this particular error correction code adds two bits to the data length, the relative storage overhead is related to (N+2) divided by N, for N bits of data. For example, 10 plus 2 redundancy has 20% overhead of memory. The wider data stripe <b>314</b> therefore has greater storage efficiency and lower storage overhead than the narrower data stripe <b>326</b>.</div>
<div class="description-paragraph" id="p-0058" num="0057"> <figref idrefs="DRAWINGS">FIG. 6B</figref> is a configuration diagram of data stripes <b>338</b>, <b>340</b>, <b>342</b>, <b>344</b> across storage nodes <b>150</b> of various memory capacities in accordance with some embodiments. As illustrated, two of the storage nodes <b>150</b> have greater capacity than two others of the storage nodes <b>150</b>, for example by a factor of two. All of the capacity of these storage nodes <b>150</b> can be used by applying data stripes <b>338</b>, <b>340</b>, <b>342</b>, <b>344</b> as shown. For example, two data stripes <b>338</b>, <b>340</b> are applied across two of the higher capacity storage nodes <b>150</b> and one of the lower capacity storage nodes <b>150</b>. Two more data stripes <b>342</b>, <b>344</b> are applied across one of the lower capacity storage nodes <b>150</b> and two of the higher capacity storage nodes <b>150</b>.</div>
<div class="description-paragraph" id="p-0059" num="0058">The ability of various embodiments to self-configure, on power up or upon removal, replacement or insertion of one or more storage nodes <b>150</b> and/or solid-state storages <b>152</b> provides a storage memory topology that automatically reconfigures. For example, in a storage cluster with multiple storage nodes <b>150</b> and two levels of redundancy, two storage nodes <b>150</b> could be lost and data could still be reconstructed, as described above. In a small configuration, the storage cluster <b>160</b> could self-configure to store two replicated copies, i.e., mirrors of the data, with 200% storage overhead. In a larger configuration, the cluster could self-configure to have parity pages, with a lower storage overhead. Storage overhead is thus reconfigured as cluster membership changes. The storage nodes <b>150</b>, solid-state storages <b>152</b>, and storage cluster <b>160</b> which these form can dynamically switch between RAID schemes, and at any moment could have a hybrid combination of RAID schemes. Earlier-formed stripes do not need to be reconstructed when the topology of the storage cluster <b>160</b> changes and can be left as is, or reconstructed later according to a new RAID scheme. Storage nodes <b>150</b>, and non-volatile solid-state storage <b>152</b> can switch from one data striping scheme to another in subsequent accesses, i.e., writes or reads, in some embodiments. New data that is arriving can be written to whichever topology is in place at the moment of the data arrival. Adding one or more storage nodes <b>150</b>, or non-volatile solid-state storage <b>152</b>, does not require that data be removed from the system for system repartitioning. The topology of the storage cluster <b>160</b>, e.g., the RAID scheme(s) and storage overhead, are automatically reconfigured as the geometry of the storage cluster <b>160</b> and/or storage capacity of each storage node <b>150</b> or each non-volatile solid-state storage <b>152</b>, is changed. The storage nodes <b>150</b> and non-volatile solid-state storage <b>152</b> thus implement dynamically switching between data striping, e.g., RAID, schemes in a hybrid topology of storage memory.</div>
<div class="description-paragraph" id="p-0060" num="0059"> <figref idrefs="DRAWINGS">FIG. 7</figref> is a flow diagram of a method for error recovery in a storage cluster, which can be practiced on or by embodiments of the storage cluster, storage nodes and/or solid-state storages disclosed herein in accordance with some embodiments. The storage cluster writes user data, using erasure coding, across the storage nodes and the non-volatile solid-state storages of the storage cluster, in an action <b>702</b>. This can be performed by the various processors and modules at the various levels of the storage cluster. In an action <b>704</b>, metadata and a redundant copy or copies of the metadata are written across the storage nodes and non-volatile solid-state storages of the storage cluster. Data reads, further data writes, and further accesses to the metadata along with other operations are performed in an action <b>706</b>, which may occur during normal system operation of the storage cluster. In a decision action <b>708</b> it is determined if an error is detected. If no error is detected, flow branches back to the action <b>706</b> for further system operation. If an error is detected, flow proceeds to action <b>710</b>.</div>
<div class="description-paragraph" id="p-0061" num="0060">In the action <b>710</b>, the storage cluster (i.e., the storage nodes and the non-volatile solid-state storages of the storage cluster) determines whether to recover from the error at the die level, i.e., at the level of the flash die, dies or dice, or package, the non-volatile solid-state storage or controller level, the storage node or processor level, and/or the cluster level, i.e., at the level of the plurality of storage nodes. In an action <b>712</b>, the recovery mechanism or mechanisms at the determined level or levels is engaged. With the recovery in progress and/or completed, flow then branches back to the action <b>706</b>, for further system operation as described above. Examples are provided below that summarize various errors and engagement of various recovery mechanisms at various levels in various embodiments, as described in detail with reference to <figref idrefs="DRAWINGS">FIGS. 1-6</figref>. The examples provided are illustrative and not meant to be an exhaustive list as other scenarios can be implemented with the embodiments described herein.</div>
<heading id="h-0005">Example 1</heading>
<div class="description-paragraph" id="p-0062" num="0061">An error in reading the flash memory could lead to engagement of an error recovery at the level of the flash memory such as the flash memory applying error correction to data stored in the flash memory. Such an error could lead to engagement of an error recovery at the level of the non-volatile solid-state storage or controller in the non-volatile solid-state storage such as retrying the read of the flash memory. This could involve applying multiple levels of a reference voltage or reference current in successive read retries, and/or probabilistic calculation or other statistical analysis to the result of the read retries.</div>
<heading id="h-0006">Example 2</heading>
<div class="description-paragraph" id="p-0063" num="0062">An error in reading user data could lead to engagement of an error recovery at the level of the storage node such as applying erasure coding to data shards read from the storage nodes. An error in reading user data, or an error from loss of one or two storage nodes could lead to an error recovery at the level of the cluster or storage nodes, such as rebuilding the user data onto whichever storage nodes remain in service. This could involve a newly assigned erasure coding for rewriting the recovered data, which differs from the erasure coding by which the data was earlier written and by which the data is read during the recovery of the data.</div>
<heading id="h-0007">Example 3</heading>
<div class="description-paragraph" id="p-0064" num="0063">An error from loss of the owner of a data segment, e.g., when an initial attempt to read data fails and/or one of the storage nodes or non-volatile solid-state storages that owns the data segment is unreachable, could lead to an error recovery at the level of the cluster or storage nodes. This could include reassigning ownership of a data segment to another one of the storage nodes or non-volatile solid-state storages. This could further lead to recovering and rebuilding the data.</div>
<heading id="h-0008">Example 4</heading>
<div class="description-paragraph" id="p-0065" num="0064">An error from loss of metadata could lead to locating and accessing a redundant copy of the metadata. This loss of metadata could be a result of a failure of a memory holding the metadata, or a failure of a non-volatile solid-state storage or a storage node. The redundant copy of the metadata may be located on another one of the storage nodes or non-volatile solid-state storages. This type of error recovery engages an error recovery mechanism at the level of the storage nodes or the non-volatile solid-state storages.</div>
<heading id="h-0009">Example 5</heading>
<div class="description-paragraph" id="p-0066" num="0065">An error from loss of a remote procedure call cache could lead to locating and accessing a redundant copy of the remote procedure call cache, i.e., a mirrored remote procedure call cache. Similar to the loss of metadata, this could be a result of a failure of a memory holding the remote procedure call cache, or a failure of a non-volatile solid-state storage or a storage node. The mirrored remote procedure call cache could be located on another one of the storage nodes or non-volatile solid-state storages. This type of error recovery engages an error recovery mechanism at the level of the storage nodes or the non-volatile solid-state storages.</div>
<div class="description-paragraph" id="p-0067" num="0066">It should be appreciated that the methods described herein may be performed with a digital processing system, such as a conventional, general-purpose computer system. Special purpose computers, which are designed or programmed to perform only one function may be used in the alternative. <figref idrefs="DRAWINGS">FIG. 8</figref> is an illustration showing an exemplary computing device which may implement the embodiments described herein. The computing device of <figref idrefs="DRAWINGS">FIG. 8</figref> may be used to perform embodiments of the functionality for a storage node or a non-volatile solid-state storage in accordance with some embodiments. The computing device includes a central processing unit (CPU) <b>801</b>, which is coupled through a bus <b>805</b> to a memory <b>803</b>, and mass storage device <b>807</b>. Mass storage device <b>807</b> represents a persistent data storage device such as a disc drive, which may be local or remote in some embodiments. The mass storage device <b>807</b> could implement a backup storage, in some embodiments. Memory <b>803</b> may include read only memory, random access memory, etc. Applications resident on the computing device may be stored on or accessed via a computer readable medium such as memory <b>803</b> or mass storage device <b>807</b> in some embodiments. Applications may also be in the form of modulated electronic signals modulated accessed via a network modem or other network interface of the computing device. It should be appreciated that CPU <b>801</b> may be embodied in a general-purpose processor, a special purpose processor, or a specially programmed logic device in some embodiments.</div>
<div class="description-paragraph" id="p-0068" num="0067">Display <b>811</b> is in communication with CPU <b>801</b>, memory <b>803</b>, and mass storage device <b>807</b>, through bus <b>805</b>. Display <b>811</b> is configured to display any visualization tools or reports associated with the system described herein. Input/output device <b>809</b> is coupled to bus <b>805</b> in order to communicate information in command selections to CPU <b>801</b>. It should be appreciated that data to and from external devices may be communicated through the input/output device <b>809</b>. CPU <b>801</b> can be defined to execute the functionality described herein to enable the functionality described with reference to <figref idrefs="DRAWINGS">FIGS. 1-7</figref>. The code embodying this functionality may be stored within memory <b>803</b> or mass storage device <b>807</b> for execution by a processor such as CPU <b>801</b> in some embodiments. The operating system on the computing device may be MS-WINDOWS™, UNIX™, LINUX™, iOS™, CentOS™, Android™, Redhat Linux™, z/OS™, or other known operating systems. It should be appreciated that the embodiments described herein may be integrated with virtualized computing system also.</div>
<div class="description-paragraph" id="p-0069" num="0068">Detailed illustrative embodiments are disclosed herein. However, specific functional details disclosed herein are merely representative for purposes of describing embodiments. Embodiments may, however, be embodied in many alternate forms and should not be construed as limited to only the embodiments set forth herein.</div>
<div class="description-paragraph" id="p-0070" num="0069">It should be understood that although the terms first, second, etc. may be used herein to describe various steps or calculations, these steps or calculations should not be limited by these terms. These terms are only used to distinguish one step or calculation from another. For example, a first calculation could be termed a second calculation, and, similarly, a second step could be termed a first step, without departing from the scope of this disclosure. As used herein, the term “and/or” and the “/” symbol includes any and all combinations of one or more of the associated listed items.</div>
<div class="description-paragraph" id="p-0071" num="0070">As used herein, the singular forms “a”, “an” and “the” are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms “comprises”, “comprising”, “includes”, and/or “including”, when used herein, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof. Therefore, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting.</div>
<div class="description-paragraph" id="p-0072" num="0071">It should also be noted that in some alternative implementations, the functions/acts noted may occur out of the order noted in the figures. For example, two figures shown in succession may in fact be executed substantially concurrently or may sometimes be executed in the reverse order, depending upon the functionality/acts involved.</div>
<div class="description-paragraph" id="p-0073" num="0072">With the above embodiments in mind, it should be understood that the embodiments might employ various computer-implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. Further, the manipulations performed are often referred to in terms, such as producing, identifying, determining, or comparing. Any of the operations described herein that form part of the embodiments are useful machine operations. The embodiments also relate to a device or an apparatus for performing these operations. The apparatus can be specially constructed for the required purpose, or the apparatus can be a general-purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general-purpose machines can be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.</div>
<div class="description-paragraph" id="p-0074" num="0073">A module, an application, a layer, an agent or other method-operable entity could be implemented as hardware, firmware, or a processor executing software, or combinations thereof. It should be appreciated that, where a software-based embodiment is disclosed herein, the software can be embodied in a physical machine such as a controller. For example, a controller could include a first module and a second module. A controller could be configured to perform various actions, e.g., of a method, an application, a layer or an agent.</div>
<div class="description-paragraph" id="p-0075" num="0074">The embodiments can also be embodied as computer readable code on a non-transitory computer readable medium. The computer readable medium is any data storage device that can store data, which can be thereafter read by a computer system. Examples of the computer readable medium include hard drives, network attached storage (NAS), read-only memory, random-access memory, CD-ROMs, CD-Rs, CD-RWs, magnetic tapes, and other optical and non-optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion. Embodiments described herein may be practiced with various computer system configurations including hand-held devices, tablets, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers and the like. The embodiments can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a wire-based or wireless network.</div>
<div class="description-paragraph" id="p-0076" num="0075">Although the method operations were described in a specific order, it should be understood that other operations may be performed in between described operations, described operations may be adjusted so that they occur at slightly different times or the described operations may be distributed in a system which allows the occurrence of the processing operations at various intervals associated with the processing.</div>
<div class="description-paragraph" id="p-0077" num="0076">In various embodiments, one or more portions of the methods and mechanisms described herein may form part of a cloud-computing environment. In such embodiments, resources may be provided over the Internet as services according to one or more various models. Such models may include Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS). In IaaS, computer infrastructure is delivered as a service. In such a case, the computing equipment is generally owned and operated by the service provider. In the PaaS model, software tools and underlying equipment used by developers to develop software solutions may be provided as a service and hosted by the service provider. SaaS typically includes a service provider licensing software as a service on demand. The service provider may host the software, or may deploy the software to a customer for a given period of time. Numerous combinations of the above models are possible and are contemplated.</div>
<div class="description-paragraph" id="p-0078" num="0077">Various units, circuits, or other components may be described or claimed as “configured to” perform a task or tasks. In such contexts, the phrase “configured to” is used to connote structure by indicating that the units/circuits/components include structure (e.g., circuitry) that performs the task or tasks during operation. As such, the unit/circuit/component can be said to be configured to perform the task even when the specified unit/circuit/component is not currently operational (e.g., is not on). The units/circuits/components used with the “configured to” language include hardware—for example, circuits, memory storing program instructions executable to implement the operation, etc. Reciting that a unit/circuit/component is “configured to” perform one or more tasks is expressly intended not to invoke 35 U.S.C. 112, sixth paragraph, for that unit/circuit/component. Additionally, “configured to” can include generic structure (e.g., generic circuitry) that is manipulated by software and/or firmware (e.g., an FPGA or a general-purpose processor executing software) to operate in manner that is capable of performing the task(s) at issue. “Configured to” may also include adapting a manufacturing process (e.g., a semiconductor fabrication facility) to fabricate devices (e.g., integrated circuits) that are adapted to implement or perform one or more tasks.</div>
<div class="description-paragraph" id="p-0079" num="0078">The foregoing description, for the purpose of explanation, has been described with reference to specific embodiments. However, the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the embodiments and its practical applications, to thereby enable others skilled in the art to best utilize the embodiments and various modifications as may be suited to the particular use contemplated. Accordingly, the present embodiments are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope and equivalents of the appended claims.</div>
</div>
</div>
</section><section itemprop="claims" itemscope="">
<h2>Claims (<span itemprop="count">19</span>)</h2>
<div html="" itemprop="content"><div class="claims" lang="EN" load-source="patent-office" mxw-id="PCLM295101999">
<claim-statement>What is claimed is:</claim-statement>
<div class="claim"> <div class="claim" id="CLM-00001" num="00001">
<div class="claim-text">1. A method comprising:
<div class="claim-text">detecting a read error in reading data from solid-state memory of a storage system;</div>
<div class="claim-text">retrying the reading the data from the solid-state memory; and</div>
<div class="claim-text">determining error corrected data as a result of analysis of data from the retrying the reading of the data, wherein the determining is performed with assistance of a mirrored remote procedure call cache responsive to determination of a loss of a remote procedure call cache.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00002" num="00002">
<div class="claim-text">2. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with differing levels of reference voltage in or to the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00003" num="00003">
<div class="claim-text">3. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with differing levels of reference current in or to the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00004" num="00004">
<div class="claim-text">4. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with error correction internal to a die in the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00005" num="00005">
<div class="claim-text">5. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with differing levels at which a read is performed in the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00006" num="00006">
<div class="claim-text">6. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the analysis includes applying one or more probabilistic calculations, that determine, for each bit in the error corrected data, whether the error corrected data bit is more likely to be a “1” or a “0”.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00007" num="00007">
<div class="claim-text">7. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, comprising:
<div class="claim-text">rebuilding the error corrected data in one of a plurality of storage nodes of the storage system, the rebuilt data utilizing an erasure coding differing from an erasure coding applied to data within the one of the plurality of storage nodes.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00008" num="00008">
<div class="claim-text">8. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the mirrored remote procedure call cache is located on a storage node of the storage system that is different than a storage node having the remote procedure call cache.</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00009" num="00009">
<div class="claim-text">9. A non-transitory machine-readable medium having executable instructions to cause one or more processing units to perform a method for error recovery in a storage system, comprising:
<div class="claim-text">detecting a read error in reading data from solid-state memory of the storage system;</div>
<div class="claim-text">retrying the reading the data from the solid-state memory; and</div>
<div class="claim-text">determining error corrected data as a result of analysis of data from the retrying the reading of the data, wherein the determining is performed with assistance of a mirrored remote procedure call cache responsive to determination of a loss of a remote procedure call cache.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00010" num="00010">
<div class="claim-text">10. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with differing levels of reference voltage in or to the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00011" num="00011">
<div class="claim-text">11. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with differing levels of reference current in or to the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00012" num="00012">
<div class="claim-text">12. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with error correction internal to a die in the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00013" num="00013">
<div class="claim-text">13. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the retrying the reading the data from the solid-state memory comprises:
<div class="claim-text">retrying the reading the data with differing levels at which a read is performed in the solid-state memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00014" num="00014">
<div class="claim-text">14. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the analysis includes applying one or more probabilistic calculations, that determine, for each bit in the error corrected data, whether the error corrected data bit is more likely to be a “1” or a “0”.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00015" num="00015">
<div class="claim-text">15. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, comprising:
<div class="claim-text">rebuilding the error corrected data in one of a plurality of storage nodes of the storage system, the rebuilt data utilizing an erasure coding differing from an erasure coding applied to data within the one of the plurality of storage nodes.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00016" num="00016">
<div class="claim-text">16. The non-transitory machine-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the mirrored remote procedure call cache is located on a storage node of the storage system that is different than a storage node having the remote procedure call cache.</div>
</div>
</div> <div class="claim"> <div class="claim" id="CLM-00017" num="00017">
<div class="claim-text">17. A method, comprising:
<div class="claim-text">detecting a read error in reading data from solid-state memory of a storage system;</div>
<div class="claim-text">retrying the reading the data from the solid-state memory; and</div>
<div class="claim-text">determining error corrected data as a result of analysis of data from the retrying the reading of the data, wherein the analysis includes applying one or more calculations, that determine, for each bit in the error corrected data, whether the error corrected data bit is more likely to be a “1” or a “0”.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00018" num="00018">
<div class="claim-text">18. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the determining is performed with assistance of a mirrored remote procedure call cache responsive to determination of a loss of a remote procedure call cache.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00019" num="00019">
<div class="claim-text">19. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the mirrored remote procedure call cache is located on a storage node of the storage system that is different than a storage node having the remote procedure call cache.</div>
</div>
</div> </div>
</div>
</section>
                </article>
            </search-app>
        </body>
    </html>
    