
    <html>
        <body>
            <search-app>
                <article class="result" itemscope="" itemtype="http://schema.org/ScholarlyArticle">
    <h1 itemprop="pageTitle">US20170364476A1 - Instruction and logic for performing a dot-product operation 
      - Google Patents</h1><section itemprop="abstract" itemscope="">
<h2>Abstract</h2>
<div html="" itemprop="content"><abstract lang="EN" load-source="patent-office" mxw-id="PA212096441">
<div class="abstract" id="p-0001" num="0000">Method, apparatus, and program means for performing a dot-product operation. In one embodiment, an apparatus includes execution resources to execute a first instruction. In response to the first instruction, said execution resources store to a storage location a result value equal to a dot-product of at least two operands.</div>
</abstract>
</div>
</section><section itemprop="description" itemscope="">
<h2>Description</h2>
<div html="" itemprop="content"><ul class="description" lang="EN" load-source="patent-office" mxw-id="PDES123636458">
<heading id="h-0001">RELATED APPLICATIONS</heading>
<li> <para-num num="[0001]"> </para-num> <div class="description-line" id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 13/844,366, filed on Mar. 15, 2013, which is a continuation of U.S. patent application Ser. No. 11/524,852, filed on Sep. 20, 2006, now abandoned, all of which is hereby incorporated by reference.</div>
</li> <heading id="h-0002">FIELD OF THE INVENTION</heading>
<li> <para-num num="[0002]"> </para-num> <div class="description-line" id="p-0003" num="0002">The present disclosure pertains to the field of processing apparatuses and associated software and software sequences that perform mathematical operations.</div>
</li> <heading id="h-0003">DESCRIPTION OF RELATED ART</heading>
<li> <para-num num="[0003]"> </para-num> <div class="description-line" id="p-0004" num="0003">Computer systems have become increasingly pervasive in our society. The processing capabilities of computers have increased the efficiency and productivity of workers in a wide spectrum of professions. As the costs of purchasing and owning a computer continues to drop, more and more consumers have been able to take advantage of newer and faster machines. Furthermore, many people enjoy the use of notebook computers because of the freedom. Mobile computers allow users to easily transport their data and work with them as they leave the office or travel. This scenario is quite familiar with marketing staff, corporate executives, and even students.</div>
</li> <li> <para-num num="[0004]"> </para-num> <div class="description-line" id="p-0005" num="0004">As processor technology advances, newer software code is also being generated to run on machines with these processors. Users generally expect and demand higher performance from their computers regardless of the type of software being used. One such issue can arise from the kinds of instructions and operations that are actually being performed within the processor. Certain types of operations require more time to complete based on the complexity of the operations and/or type of circuitry needed. This provides an opportunity to optimize the way certain complex operations are executed inside the processor.</div>
</li> <li> <para-num num="[0005]"> </para-num> <div class="description-line" id="p-0006" num="0005">Media applications have been driving microprocessor development for more than a decade. In fact, most computing upgrades in recent years have been driven by media applications. These upgrades have predominantly occurred within consumer segments, although significant advances have also been seen in enterprise segments for entertainment enhanced education and communication purposes. Nevertheless, future media applications will require even higher computational requirements. As a result, tomorrow's personal computing experience will be even richer in audio-visual effects, as well as being easier to use, and more importantly, computing will merge with communications.</div>
</li> <li> <para-num num="[0006]"> </para-num> <div class="description-line" id="p-0007" num="0006">Accordingly, the display of images, as well as playback of audio and video data, which is collectively referred to as content, have become increasingly popular applications for current computing devices. Filtering and convolution operations are some of the most common operations performed on content data, such as image audio and video data. Such operations are computationally intensive, but offer a high level of data parallelism that can be exploited through an efficient implementation using various data storage devices, such as for example, single instruction multiple data (SIMD) registers. A number of current architectures also require multiple operations, instructions, or sub-instructions (often referred to as “micro-operations” or “uops”) to perform various mathematical operations on a number of operands, thereby diminishing throughput and increasing the number of clock cycles required to perform the mathematical operations.</div>
</li> <li> <para-num num="[0007]"> </para-num> <div class="description-line" id="p-0008" num="0007">For example, an instruction sequence consisting of a number of instructions may be required to perform one or more operations necessary to generate a dot-product, including adding the products of two or more numbers represented by various datatypes within a processing apparatus, system or computer program. However, such prior art techniques may require numerous processing cycles and may cause a processor or system to consume unnecessary power in order to generate the dot-product. Furthermore, some prior art techniques may be limited in the operand datatypes that may be operated upon.</div>
</li> <description-of-drawings>
<heading id="h-0004">BRIEF DESCRIPTION OF THE FIGURES</heading>
<li> <para-num num="[0008]"> </para-num> <div class="description-line" id="p-0009" num="0008">The present invention is illustrated by way of example and not limitation in the Figures of the accompanying drawings:</div>
</li> <li> <para-num num="[0009]"> </para-num> <div class="description-line" id="p-0010" num="0009"> <figref idrefs="DRAWINGS">FIG. 1A</figref> is a block diagram of a computer system formed with a processor that includes execution units to execute an instruction for a dot-product operation in accordance with one embodiment of the present invention;</div>
</li> <li> <para-num num="[0010]"> </para-num> <div class="description-line" id="p-0011" num="0010"> <figref idrefs="DRAWINGS">FIG. 1B</figref> is a block diagram of another exemplary computer system in accordance with an alternative embodiment of the present invention;</div>
</li> <li> <para-num num="[0011]"> </para-num> <div class="description-line" id="p-0012" num="0011"> <figref idrefs="DRAWINGS">FIG. 1C</figref> is a block diagram of yet another exemplary computer system in accordance with another alternative embodiment of the present invention;</div>
</li> <li> <para-num num="[0012]"> </para-num> <div class="description-line" id="p-0013" num="0012"> <figref idrefs="DRAWINGS">FIG. 2</figref> is a block diagram of the micro-architecture for a processor of one embodiment that includes logic circuits to perform a dot-product operation in accordance with the present invention;</div>
</li> <li> <para-num num="[0013]"> </para-num> <div class="description-line" id="p-0014" num="0013"> <figref idrefs="DRAWINGS">FIG. 3A</figref> illustrates various packed data type representations in multimedia registers according to one embodiment of the present invention;</div>
</li> <li> <para-num num="[0014]"> </para-num> <div class="description-line" id="p-0015" num="0014"> <figref idrefs="DRAWINGS">FIG. 3B</figref> illustrates packed data-types in accordance with an alternative embodiment;</div>
</li> <li> <para-num num="[0015]"> </para-num> <div class="description-line" id="p-0016" num="0015"> <figref idrefs="DRAWINGS">FIG. 3C</figref> illustrates various signed and unsigned packed data type representations in multimedia registers according to one embodiment of the present invention;</div>
</li> <li> <para-num num="[0016]"> </para-num> <div class="description-line" id="p-0017" num="0016"> <figref idrefs="DRAWINGS">FIG. 3D</figref> illustrates one embodiment of an operation encoding (opcode) format;</div>
</li> <li> <para-num num="[0017]"> </para-num> <div class="description-line" id="p-0018" num="0017"> <figref idrefs="DRAWINGS">FIG. 3E</figref> illustrates an alternative operation encoding (opcode) format;</div>
</li> <li> <para-num num="[0018]"> </para-num> <div class="description-line" id="p-0019" num="0018"> <figref idrefs="DRAWINGS">FIG. 3F</figref> illustrates yet another alternative operation encoding format;</div>
</li> <li> <para-num num="[0019]"> </para-num> <div class="description-line" id="p-0020" num="0019"> <figref idrefs="DRAWINGS">FIG. 4</figref> is a block diagram of one embodiment of logic to perform a dot-product operation on packed data operands in accordance with the present invention.</div>
</li> <li> <para-num num="[0020]"> </para-num> <div class="description-line" id="p-0021" num="0020"> <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>is a block diagram of a logic to perform a dot-product operation on single precision packed data operands in accordance with one embodiment of the present invention;</div>
</li> <li> <para-num num="[0021]"> </para-num> <div class="description-line" id="p-0022" num="0021"> <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>is a block diagram of logic to perform a dot-product operation on double precision packed data operands in accordance with one embodiment of the present invention;</div>
</li> <li> <para-num num="[0022]"> </para-num> <div class="description-line" id="p-0023" num="0022"> <figref idrefs="DRAWINGS">FIG. 6A</figref> is a block diagram of a circuit for performing a dot-product operation in accordance with one embodiment of the present invention;</div>
</li> <li> <para-num num="[0023]"> </para-num> <div class="description-line" id="p-0024" num="0023"> <figref idrefs="DRAWINGS">FIG. 6B</figref> is a block diagram of a circuit for performing a dot-product operation in accordance with another embodiment of the present invention;</div>
</li> <li> <para-num num="[0024]"> </para-num> <div class="description-line" id="p-0025" num="0024"> <figref idrefs="DRAWINGS">FIG. 7A</figref> is a pseudo-code representation of operations that may be performed by executing a DPPS instruction, according to one embodiment.</div>
</li> <li> <para-num num="[0025]"> </para-num> <div class="description-line" id="p-0026" num="0025"> <figref idrefs="DRAWINGS">FIG. 7B</figref> is a pseudo-code representation of operations that may be performed by executing a DPPD instruction, according to one embodiment.</div>
</li> </description-of-drawings>
<heading id="h-0005">DETAILED DESCRIPTION</heading>
<li> <para-num num="[0026]"> </para-num> <div class="description-line" id="p-0027" num="0026">The following description describes embodiments of a technique to perform a dot-product operation within a processing apparatus, computer system, or software program. In the following description, numerous specific details such as processor types, micro-architectural conditions, events, enablement mechanisms, and the like are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. Additionally, some well known structures, circuits, and the like have not been shown in detail to avoid unnecessarily obscuring the present invention.</div>
</li> <li> <para-num num="[0027]"> </para-num> <div class="description-line" id="p-0028" num="0027">Although the following embodiments are described with reference to a processor, other embodiments are applicable to other types of integrated circuits and logic devices. The same techniques and teachings of the present invention can easily be applied to other types of circuits or semiconductor devices that can benefit from higher pipeline throughput and improved performance. The teachings of the present invention are applicable to any processor or machine that performs data manipulations. However, the present invention is not limited to processors or machines that perform 256 bit, 128 bit, 64 bit, 32 bit, or 16 bit data operations and can be applied to any processor and machine in which manipulation of packed data is needed.</div>
</li> <li> <para-num num="[0028]"> </para-num> <div class="description-line" id="p-0029" num="0028">In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. One of ordinary skill in the art, however, will appreciate that these specific details are not necessary in order to practice the present invention. In other instances, well known electrical structures and circuits have not been set forth in particular detail in order to not necessarily obscure the present invention. In addition, the following description provides examples, and the accompanying drawings show various examples for the purposes of illustration. However, these examples should not be construed in a limiting sense as they are merely intended to provide examples of the present invention rather than to provide an exhaustive list of all possible implementations of the present invention.</div>
</li> <li> <para-num num="[0029]"> </para-num> <div class="description-line" id="p-0030" num="0029">Although the below examples describe instruction handling and distribution in the context of execution units and logic circuits, other embodiments of the present invention can be accomplished by way of software. In one embodiment, the methods of the present invention are embodied in machine-executable instructions. The instructions can be used to cause a general-purpose or special-purpose processor that is programmed with the instructions to perform the steps of the present invention. The present invention may be provided as a computer program product or software which may include a machine or computer-readable medium having stored thereon instructions which may be used to program a computer (or other electronic devices) to perform a process according to the present invention. Alternatively, the steps of the present invention might be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components. Such software can be stored within a memory in the system. Similarly, the code can be distributed via a network or by way of other computer readable media.</div>
</li> <li> <para-num num="[0030]"> </para-num> <div class="description-line" id="p-0031" num="0030">Thus a machine-readable medium may include any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer), but is not limited to, floppy diskettes, optical disks, Compact Disc, Read-Only Memory (CD-ROMs), and magneto-optical disks, Read-Only Memory (ROMs), Random Access Memory (RAM), Erasable Programmable Read-Only Memory (EPROM), Electrically Erasable Programmable Read-Only Memory (EEPROM), magnetic or optical cards, flash memory, a transmission over the Internet, electrical, optical, acoustical or other forms of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.) or the like. Accordingly, the computer-readable medium includes any type of media/machine-readable medium suitable for storing or transmitting electronic instructions or information in a form readable by a machine (e.g., a computer). Moreover, the present invention may also be downloaded as a computer program product. As such, the program may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client). The transfer of the program may be by way of electrical, optical, acoustical, or other forms of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem, network connection or the like).</div>
</li> <li> <para-num num="[0031]"> </para-num> <div class="description-line" id="p-0032" num="0031">A design may go through various stages, from creation to simulation to fabrication. Data representing a design may represent the design in a number of manners. First, as is useful in simulations, the hardware may be represented using a hardware description language or another functional description language. Additionally, a circuit level model with logic and/or transistor gates may be produced at some stages of the design process. Furthermore, most designs, at some stage, reach a level of data representing the physical placement of various devices in the hardware model. In the case where conventional semiconductor fabrication techniques are used, the data representing the hardware model may be the data specifying the presence or absence of various features on different mask layers for masks used to produce the integrated circuit. In any representation of the design, the data may be stored in any form of a machine readable medium. An optical or electrical wave modulated or otherwise generated to transmit such information, a memory, or a magnetic or optical storage such as a disc may be the machine readable medium. Any of these mediums may “carry” or “indicate” the design or software information. When an electrical carrier wave indicating or carrying the code or design is transmitted, to the extent that copying, buffering, or re-transmission of the electrical signal is performed, a new copy is made. Thus, a communication provider or a network provider may make copies of an article (a carrier wave) embodying techniques of the present invention.</div>
</li> <li> <para-num num="[0032]"> </para-num> <div class="description-line" id="p-0033" num="0032">In modern processors, a number of different execution units are used to process and execute a variety of code and instructions. Not all instructions are created equal as some are quicker to complete while others can take an enormous number of clock cycles. The faster the throughput of instructions, the better the overall performance of the processor. Thus it would be advantageous to have as many instructions execute as fast as possible. However, there are certain instructions that have greater complexity and require more in terms of execution time and processor resources. For example, there are floating point instructions, load/store operations, data moves, etc.</div>
</li> <li> <para-num num="[0033]"> </para-num> <div class="description-line" id="p-0034" num="0033">As more and more computer systems are used in internet and multimedia applications, additional processor support has been introduced over time. For instance, Single Instruction, Multiple Data (SIMD) integer/floating point instructions and Streaming SIMD Extensions (SSE) are instructions that reduce the overall number of instructions required to execute a particular program task, which in turn can reduce the power consumption. These instructions can speed up software performance by operating on multiple data elements in parallel. As a result, performance gains can be achieved in a wide range of applications including video, speech, and image/photo processing. The implementation of SIMD instructions in microprocessors and similar types of logic circuit usually involve a number of issues. Furthermore, the complexity of SIMD operations often leads to a need for additional circuitry in order to correctly process and manipulate the data.</div>
</li> <li> <para-num num="[0034]"> </para-num> <div class="description-line" id="p-0035" num="0034">Presently a SIMD dot-product instruction is not available. Without the presence of a SIMD dot-product instruction, a large number of instructions and data registers may be needed to accomplish the same results in applications such as audio/video compression, processing, and manipulation. Thus, at least one dot-product instruction in accordance with embodiments of the present invention can reduce code overhead and resource requirements. Embodiments of the present invention provide a way to implement a dot-product operation as an algorithm that makes use of SIMD related hardware. Presently, it is somewhat difficult and tedious to perform dot-product operations on data in a SIMD register. Some algorithms require more instructions to arrange data for arithmetic operations than the actual number of instructions to execute those operations. By implementing embodiments of a dot-product operation in accordance with embodiments of the present invention, the number of instructions needed to achieve dot-product processing can be drastically reduced.</div>
</li> <li> <para-num num="[0035]"> </para-num> <div class="description-line" id="p-0036" num="0035">Embodiments of the present invention involve an instruction for implementing a dot-product operation. A dot-product operation generally involves multiplying at least two values and adding this product to the product of at least two other values. Other variations may be made on the generic dot-product algorithm, including adding the result of various dot-product operations to generate another dot-product. For example, a dot product operation according to one embodiment as applied to data elements can be generically represented as:</div>
</li> <li> <div class="description-line" id="p-0037" num="0000"> <br/>DEST1→SRC1*SRC2;
</div>
</li> <li> <div class="description-line" id="p-0038" num="0000"> <br/>DEST2→SRC3*SRC4;
</div>
</li> <li> <div class="description-line" id="p-0039" num="0000"> <br/>DEST3→DEST1+DEST2;
</div>
</li> <li> <div class="description-line" id="p-0040" num="0000">For a packed SIMD data operand, this flow can be applied to each data element of each operand.</div>
</li> <li> <para-num num="[0036]"> </para-num> <div class="description-line" id="p-0041" num="0036">In the above flow, “DEST” and “SRC” are generic terms to represent the source and destination of the corresponding data or operation. In some embodiments, they may be implemented by registers, memory, or other storage areas having other names or functions than those depicted. For example, in one embodiment, DEST<b>1</b> and DEST<b>2</b> may be a first and second temporary storage area (e.g., “TEMP<b>1</b>” and “TEMP<b>2</b>” register), SRC<b>1</b> and SRC<b>3</b> may be first and second destination storage area (e.g., “DEST<b>1</b>” and “DEST<b>2</b>” register), and so forth. In other embodiments, two or more of the SRC and DEST storage areas may correspond to different data storage elements within the same storage area (e.g., a SIMD register). Furthermore, in one embodiment, a dot-product operation may generate sum of dot-products generated by the above generic flow.</div>
</li> <li> <para-num num="[0037]"> </para-num> <div class="description-line" id="p-0042" num="0037"> <figref idrefs="DRAWINGS">FIG. 1A</figref> is a block diagram of an exemplary computer system formed with a processor that includes execution units to execute an instruction for a dot-product operation in accordance with one embodiment of the present invention. System <b>100</b> includes a component, such as a processor <b>102</b> to employ execution units including logic to perform algorithms for process data, in accordance with the present invention, such as in the embodiment described herein. System <b>100</b> is representative of processing systems based on the PENTIUM® III, PENTIUM® 4, Xeon™, Itanium®, XScale™ and/or StrongARM™ microprocessors available from Intel Corporation of Santa Clara, Calif., although other systems (including PCs having other microprocessors, engineering workstations, set-top boxes and the like) may also be used. In one embodiment, sample system <b>100</b> may execute a version of the WINDOWS™ operating system available from Microsoft Corporation of Redmond, Wash., although other operating systems (UNIX and Linux for example), embedded software, and/or graphical user interfaces, may also be used. Thus, embodiments of the present invention is not limited to any specific combination of hardware circuitry and software.</div>
</li> <li> <para-num num="[0038]"> </para-num> <div class="description-line" id="p-0043" num="0038">Embodiments are not limited to computer systems. Alternative embodiments of the present invention can be used in other devices such as handheld devices and embedded applications. Some examples of handheld devices include cellular phones, Internet Protocol devices, digital cameras, personal digital assistants (PDAs), and handheld PCs. Embedded applications can include a micro controller, a digital signal processor (DSP), system on a chip, network computers (NetPC), set-top boxes, network hubs, wide area network (WAN) switches, or any other system that performs dot-product operations on operands. Furthermore, some architectures have been implemented to enable instructions to operate on several data simultaneously to improve the efficiency of multimedia applications. As the type and volume of data increases, computers and their processors have to be enhanced to manipulate data in more efficient methods.</div>
</li> <li> <para-num num="[0039]"> </para-num> <div class="description-line" id="p-0044" num="0039"> <figref idrefs="DRAWINGS">FIG. 1A</figref> is a block diagram of a computer system <b>100</b> formed with a processor <b>102</b> that includes one or more execution units <b>108</b> to perform an algorithm to calculate the dot-product of a data elements from one or more operands in accordance with one embodiment of the present invention. One embodiment may be described in the context of a single processor desktop or server system, but alternative embodiments can be included in a multiprocessor system. System <b>100</b> is an example of a hub architecture. The computer system <b>100</b> includes a processor <b>102</b> to process data signals. The processor <b>102</b> can be a complex instruction set computer (CISC) microprocessor, a reduced instruction set computing (RISC) microprocessor, a very long instruction word (VLIW) microprocessor, a processor implementing a combination of instruction sets, or any other processor device, such as a digital signal processor, for example. The processor <b>102</b> is coupled to a processor bus <b>110</b> that can transmit data signals between the processor <b>102</b> and other components in the system <b>100</b>. The elements of system <b>100</b> perform their conventional functions that are well known to those familiar with the art.</div>
</li> <li> <para-num num="[0040]"> </para-num> <div class="description-line" id="p-0045" num="0040">In one embodiment, the processor <b>102</b> includes a Level 1 (L1) internal cache memory <b>104</b>. Depending on the architecture, the processor <b>102</b> can have a single internal cache or multiple levels of internal cache. Alternatively, in another embodiment, the cache memory can reside external to the processor <b>102</b>. Other embodiments can also include a combination of both internal and external caches depending on the particular implementation and needs. Register file <b>106</b> can store different types of data in various registers including integer registers, floating point registers, status registers, and instruction pointer register.</div>
</li> <li> <para-num num="[0041]"> </para-num> <div class="description-line" id="p-0046" num="0041">Execution unit <b>108</b>, including logic to perform integer and floating point operations, also resides in the processor <b>102</b>. The processor <b>102</b> also includes a microcode (ucode) ROM that stores microcode for certain macroinstructions. For this embodiment, execution unit <b>108</b> includes logic to handle a packed instruction set <b>109</b>. In one embodiment, the packed instruction set <b>109</b> includes a packed dot-product instruction for calculating the dot-product of a number of operands. By including the packed instruction set <b>109</b> in the instruction set of a general-purpose processor <b>102</b>, along with associated circuitry to execute the instructions, the operations used by many multimedia applications may be performed using packed data in a general-purpose processor <b>102</b>. Thus, many multimedia applications can be accelerated and executed more efficiently by using the full width of a processor's data bus for performing operations on packed data. This can eliminate the need to transfer smaller units of data across the processor's data bus to perform one or more operations one data element at a time.</div>
</li> <li> <para-num num="[0042]"> </para-num> <div class="description-line" id="p-0047" num="0042">Alternate embodiments of an execution unit <b>108</b> can also be used in micro controllers, embedded processors, graphics devices, DSPs, and other types of logic circuits. System <b>100</b> includes a memory <b>120</b>. Memory <b>120</b> can be a dynamic random access memory (DRAM) device, a static random access memory (SRAM) device, flash memory device, or other memory device. Memory <b>120</b> can store instructions and/or data represented by data signals that can be executed by the processor <b>102</b>.</div>
</li> <li> <para-num num="[0043]"> </para-num> <div class="description-line" id="p-0048" num="0043">A system logic chip <b>116</b> is coupled to the processor bus <b>110</b> and memory <b>120</b>. The system logic chip <b>116</b> in the illustrated embodiment is a memory controller hub (MCH). The processor <b>102</b> can communicate to the MCH <b>116</b> via a processor bus <b>110</b>. The MCH <b>116</b> provides a high bandwidth memory path <b>118</b> to memory <b>120</b> for instruction and data storage and for storage of graphics commands, data and textures. The MCH <b>116</b> is to direct data signals between the processor <b>102</b>, memory <b>120</b>, and other components in the system <b>100</b> and to bridge the data signals between processor bus <b>110</b>, memory <b>120</b>, and system I/O <b>122</b>. In some embodiments, the system logic chip <b>116</b> can provide a graphics port for coupling to a graphics controller <b>112</b>. The MCH <b>116</b> is coupled to memory <b>120</b> through a memory interface <b>118</b>. The graphics card <b>112</b> is coupled to the MCH <b>116</b> through an Accelerated Graphics Port (AGP) interconnect <b>114</b>.</div>
</li> <li> <para-num num="[0044]"> </para-num> <div class="description-line" id="p-0049" num="0044">System <b>100</b> uses a proprietary hub interface bus <b>122</b> to couple the MCH <b>116</b> to the I/O controller hub (ICH) <b>130</b>. The ICH <b>130</b> provides direct connections to some I/O devices via a local I/O bus. The local I/O bus is a high-speed I/O bus for connecting peripherals to the memory <b>120</b>, chipset, and processor <b>102</b>. Some examples are the audio controller, firmware hub (flash BIOS) <b>128</b>, wireless transceiver <b>126</b>, data storage <b>124</b>, legacy I/O controller containing user input and keyboard interfaces, a serial expansion port such as Universal Serial Bus (USB), and a network controller <b>134</b>. The data storage device <b>124</b> can comprise a hard disk drive, a floppy disk drive, a CD-ROM device, a flash memory device, or other mass storage device.</div>
</li> <li> <para-num num="[0045]"> </para-num> <div class="description-line" id="p-0050" num="0045">For another embodiment of a system, an execution unit to execute an algorithm with a dot-product instruction can be used with a system on a chip. One embodiment of a system on a chip comprises of a processor and a memory. The memory for one such system is a flash memory. The flash memory can be located on the same die as the processor and other system components. Additionally, other logic blocks such as a memory controller or graphics controller can also be located on a system on a chip.</div>
</li> <li> <para-num num="[0046]"> </para-num> <div class="description-line" id="p-0051" num="0046"> <figref idrefs="DRAWINGS">FIG. 1B</figref> illustrates a data processing system <b>140</b> which implements the principles of one embodiment of the present invention. It will be readily appreciated by one of skill in the art that the embodiments described herein can be used with alternative processing systems without departure from the scope of the invention.</div>
</li> <li> <para-num num="[0047]"> </para-num> <div class="description-line" id="p-0052" num="0047">Computer system <b>140</b> comprises a processing core <b>159</b> capable of performing SIMD operations including a dot-product operation. For one embodiment, processing core <b>159</b> represents a processing unit of any type of architecture, including but not limited to a CISC, a RISC or a VLIW type architecture. Processing core <b>159</b> may also be suitable for manufacture in one or more process technologies and by being represented on a machine readable media in sufficient detail, may be suitable to facilitate said manufacture.</div>
</li> <li> <para-num num="[0048]"> </para-num> <div class="description-line" id="p-0053" num="0048">Processing core <b>159</b> comprises an execution unit <b>142</b>, a set of register file(s) <b>145</b>, and a decoder <b>144</b>. Processing core <b>159</b> also includes additional circuitry (not shown) which is not necessary to the understanding of the present invention. Execution unit <b>142</b> is used for executing instructions received by processing core <b>159</b>. In addition to recognizing typical processor instructions, execution unit <b>142</b> can recognize instructions in packed instruction set <b>143</b> for performing operations on packed data formats. Packed instruction set <b>143</b> includes instructions for supporting dot-product operations, and may also include other packed instructions. Execution unit <b>142</b> is coupled to register file <b>145</b> by an internal bus. Register file <b>145</b> represents a storage area on processing core <b>159</b> for storing information, including data. As previously mentioned, it is understood that the storage area used for storing the packed data is not critical. Execution unit <b>142</b> is coupled to decoder <b>144</b>. Decoder <b>144</b> is used for decoding instructions received by processing core <b>159</b> into control signals and/or microcode entry points. In response to these control signals and/or microcode entry points, execution unit <b>142</b> performs the appropriate operations.</div>
</li> <li> <para-num num="[0049]"> </para-num> <div class="description-line" id="p-0054" num="0049">Processing core <b>159</b> is coupled with bus <b>141</b> for communicating with various other system devices, which may include but are not limited to, for example, synchronous dynamic random access memory (SDRAM) control <b>146</b>, static random access memory (SRAM) control <b>147</b>, burst flash memory interface <b>148</b>, personal computer memory card international association (PCMCIA)/compact flash (CF) card control <b>149</b>, liquid crystal display (LCD) control <b>150</b>, direct memory access (DMA) controller <b>151</b>, and alternative bus master interface <b>152</b>. In one embodiment, data processing system <b>140</b> may also comprise an I/O bridge <b>154</b> for communicating with various I/O devices via an I/O bus <b>153</b>. Such I/O devices may include but are not limited to, for example, universal asynchronous receiver/transmitter (UART) <b>155</b>, universal serial bus (USB) <b>156</b>, Bluetooth wireless UART <b>157</b> and I/O expansion interface <b>158</b>.</div>
</li> <li> <para-num num="[0050]"> </para-num> <div class="description-line" id="p-0055" num="0050">One embodiment of data processing system <b>140</b> provides for mobile, network and/or wireless communications and a processing core <b>159</b> capable of performing SIMD operations including a dot-product operation. Processing core <b>159</b> may be programmed with various audio, video, imaging and communications algorithms including discrete transformations such as a Walsh-Hadamard transform, a fast Fourier transform (FFT), a discrete cosine transform (DCT), and their respective inverse transforms; compression/decompression techniques such as color space transformation, video encode motion estimation or video decode motion compensation; and modulation/demodulation (MODEM) functions such as pulse coded modulation (PCM). Some embodiments of the invention may also be applied to graphics applications, such as three dimensional (“3D”) modeling, rendering, objects collision detection, 3D objects transformation and lighting, etc.</div>
</li> <li> <para-num num="[0051]"> </para-num> <div class="description-line" id="p-0056" num="0051"> <figref idrefs="DRAWINGS">FIG. 1C</figref> illustrates yet alternative embodiments of a data processing system capable of performing SIMD dot-product operations. In accordance with one alternative embodiment, data processing system <b>160</b> may include a main processor <b>166</b>, a SIMD coprocessor <b>161</b>, a cache memory <b>167</b>, and an input/output system <b>168</b>. The input/output system <b>168</b> may optionally be coupled to a wireless interface <b>169</b>. SIMD coprocessor <b>161</b> is capable of performing SIMD operations including dot-product operations. Processing core <b>170</b> may be suitable for manufacture in one or more process technologies and by being represented on a machine readable media in sufficient detail, may be suitable to facilitate the manufacture of all or part of data processing system <b>160</b> including processing core <b>170</b>.</div>
</li> <li> <para-num num="[0052]"> </para-num> <div class="description-line" id="p-0057" num="0052">For one embodiment, SIMD coprocessor <b>161</b> comprises an execution unit <b>162</b> and a set of register file(s) <b>164</b>. One embodiment of main processor <b>165</b> comprises a decoder <b>165</b> to recognize instructions of instruction set <b>163</b> including SIMD dot-product calculation instructions for execution by execution unit <b>162</b>. For alternative embodiments, SIMD coprocessor <b>161</b> also comprises at least part of decoder <b>165</b>B to decode instructions of instruction set <b>163</b>. Processing core <b>170</b> also includes additional circuitry (not shown) which is not necessary to the understanding of embodiments of the present invention.</div>
</li> <li> <para-num num="[0053]"> </para-num> <div class="description-line" id="p-0058" num="0053">In operation, the main processor <b>166</b> executes a stream of data processing instructions that control data processing operations of a general type including interactions with the cache memory <b>167</b>, and the input/output system <b>168</b>. Embedded within the stream of data processing instructions are SIMD coprocessor instructions. The decoder <b>165</b> of main processor <b>166</b> recognizes these SIMD coprocessor instructions as being of a type that should be executed by an attached SIMD coprocessor <b>161</b>. Accordingly, the main processor <b>166</b> issues these SIMD coprocessor instructions (or control signals representing SIMD coprocessor instructions) on the coprocessor bus <b>166</b> where from they are received by any attached SIMD coprocessors. In this case, the SIMD coprocessor <b>161</b> will accept and execute any received SIMD coprocessor instructions intended for it.</div>
</li> <li> <para-num num="[0054]"> </para-num> <div class="description-line" id="p-0059" num="0054">Data may be received via wireless interface <b>169</b> for processing by the SIMD coprocessor instructions. For one example, voice communication may be received in the form of a digital signal, which may be processed by the SIMD coprocessor instructions to regenerate digital audio samples representative of the voice communications. For another example, compressed audio and/or video may be received in the form of a digital bit stream, which may be processed by the SIMD coprocessor instructions to regenerate digital audio samples and/or motion video frames. For one embodiment of processing core <b>170</b>, main processor <b>166</b>, and a SIMD coprocessor <b>161</b> are integrated into a single processing core <b>170</b> comprising an execution unit <b>162</b>, a set of register file(s) <b>164</b>, and a decoder <b>165</b> to recognize instructions of instruction set <b>163</b> including SIMD dot-product instructions.</div>
</li> <li> <para-num num="[0055]"> </para-num> <div class="description-line" id="p-0060" num="0055"> <figref idrefs="DRAWINGS">FIG. 2</figref> is a block diagram of the micro-architecture for a processor <b>200</b> that includes logic circuits to perform a dot-product instruction in accordance with one embodiment of the present invention. For one embodiment of the dot-product instruction, the instruction can multiply a first data element with a second data element and add this product to a product of third and fourth data element. In some embodiments, the dot-product instruction can be implemented to operate on data elements having sizes of byte, word, doubleword, quadword, etc., as well as datatypes, such as single and double precision integer and floating point datatypes. In one embodiment the in-order front end <b>201</b> is the part of the processor <b>200</b> that fetches macro-instructions to be executed and prepares them to be used later in the processor pipeline. The front end <b>201</b> may include several units. In one embodiment, the instruction prefetcher <b>226</b> fetches macro-instructions from memory and feeds them to an instruction decoder <b>228</b> which in turn decodes them into primitives called micro-instructions or micro-operations (also called micro op or uops) that the machine can execute. In one embodiment, the trace cache <b>230</b> takes decoded uops and assembles them into program ordered sequences or traces in the uop queue <b>234</b> for execution. When the trace cache <b>230</b> encounters a complex macro-instruction, the microcode ROM <b>232</b> provides the uops needed to complete the operation.</div>
</li> <li> <para-num num="[0056]"> </para-num> <div class="description-line" id="p-0061" num="0056">Many macro-instructions are converted into a single micro-op, whereas others need several micro-ops to complete the full operation. In one embodiment, if more than four micro-ops are needed to complete a macro-instruction, the decoder <b>228</b> accesses the microcode ROM <b>232</b> to do the macro-instruction. For one embodiment, a packed dot-product instruction can be decoded into a small number of micro ops for processing at the instruction decoder <b>228</b>. In another embodiment, an instruction for a packed dot-product algorithm can be stored within the microcode ROM <b>232</b> should a number of micro-ops be needed to accomplish the operation. The trace cache <b>230</b> refers to a entry point programmable logic array (PLA) to determine a correct micro-instruction pointer for reading the micro-code sequences for the dot-product algorithm in the micro-code ROM <b>232</b>. After the microcode ROM <b>232</b> finishes sequencing micro-ops for the current macro-instruction, the front end <b>201</b> of the machine resumes fetching micro-ops from the trace cache <b>230</b>.</div>
</li> <li> <para-num num="[0057]"> </para-num> <div class="description-line" id="p-0062" num="0057">Some SIMD and other multimedia types of instructions are considered complex instructions. Most floating point related instructions are also complex instructions. As such, when the instruction decoder <b>228</b> encounters a complex macro-instruction, the microcode ROM <b>232</b> is accessed at the appropriate location to retrieve the microcode sequence for that macro-instruction. The various micro-ops needed for performing that macro-instruction are communicated to the out-of-order execution engine <b>203</b> for execution at the appropriate integer and floating point execution units.</div>
</li> <li> <para-num num="[0058]"> </para-num> <div class="description-line" id="p-0063" num="0058">The out-of-order execution engine <b>203</b> is where the micro-instructions are prepared for execution. The out-of-order execution logic has a number of buffers to smooth out and re-order the flow of micro-instructions to optimize performance as they go down the pipeline and get scheduled for execution. The allocator logic allocates the machine buffers and resources that each uop needs in order to execute. The register renaming logic renames logic registers onto entries in a register file. The allocator also allocates an entry for each uop in one of the two uop queues, one for memory operations and one for non-memory operations, in front of the instruction schedulers: memory scheduler, fast scheduler <b>202</b>, slow/general floating point scheduler <b>204</b>, and simple floating point scheduler <b>206</b>. The uop schedulers <b>202</b>, <b>204</b>, <b>206</b>, determine when a uop is ready to execute based on the readiness of their dependent input register operand sources and the availability of the execution resources the uops need to complete their operation. The fast scheduler <b>202</b> of this embodiment can schedule on each half of the main clock cycle while the other schedulers can only schedule once per main processor clock cycle. The schedulers arbitrate for the dispatch ports to schedule uops for execution.</div>
</li> <li> <para-num num="[0059]"> </para-num> <div class="description-line" id="p-0064" num="0059">Register files <b>208</b>, <b>210</b>, sit between the schedulers <b>202</b>, <b>204</b>, <b>206</b>, and the execution units <b>212</b>, <b>214</b>, <b>216</b>, <b>218</b>, <b>220</b>, <b>222</b>, <b>224</b> in the execution block <b>211</b>. There is a separate register file <b>208</b>, <b>210</b>, for integer and floating point operations, respectively. Each register file <b>208</b>, <b>210</b>, of this embodiment also includes a bypass network that can bypass or forward just completed results that have not yet been written into the register file to new dependent uops. The integer register file <b>208</b> and the floating point register file <b>210</b> are also capable of communicating data with the other. For one embodiment, the integer register file <b>208</b> is split into two separate register files, one register file for the low order 32 bits of data and a second register file for the high order 32 bits of data. The floating point register file <b>210</b> of one embodiment has 128 bit wide entries because floating point instructions typically have operands from 64 to 128 bits in width.</div>
</li> <li> <para-num num="[0060]"> </para-num> <div class="description-line" id="p-0065" num="0060">The execution block <b>211</b> contains the execution units <b>212</b>, <b>214</b>, <b>216</b>, <b>218</b>, <b>220</b>, <b>222</b>, <b>224</b>, where the instructions are actually executed. This section includes the register files <b>208</b>, <b>210</b>, that store the integer and floating point data operand values that the micro-instructions need to execute. The processor <b>200</b> of this embodiment is comprised of a number of execution units: address generation unit (AGU) <b>212</b>, AGU <b>214</b>, fast ALU <b>216</b>, fast ALU <b>218</b>, slow ALU <b>220</b>, floating point ALU <b>222</b>, floating point move unit <b>224</b>. For this embodiment, the floating point execution blocks <b>222</b>, <b>224</b>, execute floating point, MMX, SIMD, and SSE operations. The floating point ALU <b>222</b> of this embodiment includes a 64 bit by 64 bit floating point divider to execute divide, square root, and remainder micro-ops. For embodiments of the present invention, any act involving a floating point value occurs with the floating point hardware. For example, conversions between integer format and floating point format involve a floating point register file. Similarly, a floating point divide operation happens at a floating point divider. On the other hand, non-floating point numbers and integer type are handled with integer hardware resources. The simple, very frequent ALU operations go to the high-speed ALU execution units <b>216</b>, <b>218</b>. The fast ALUs <b>216</b>, <b>218</b>, of this embodiment can execute fast operations with an effective latency of half a clock cycle. For one embodiment, most complex integer operations go to the slow ALU <b>220</b> as the slow ALU <b>220</b> includes integer execution hardware for long latency type of operations, such as a multiplier, shifts, flag logic, and branch processing. Memory load/store operations are executed by the AGUs <b>212</b>, <b>214</b>. For this embodiment, the integer ALUs <b>216</b>, <b>218</b>, <b>220</b>, are described in the context of performing integer operations on 64 bit data operands. In alternative embodiments, the ALUs <b>216</b>, <b>218</b>, <b>220</b>, can be implemented to support a variety of data bits including 16, 32, 128, 256, etc. Similarly, the floating point units <b>222</b>, <b>224</b>, can be implemented to support a range of operands having bits of various widths. For one embodiment, the floating point units <b>222</b>, <b>224</b>, can operate on 128 bits wide packed data operands in conjunction with SIMD and multimedia instructions.</div>
</li> <li> <para-num num="[0061]"> </para-num> <div class="description-line" id="p-0066" num="0061">In this embodiment, the uops schedulers <b>202</b>, <b>204</b>, <b>206</b>, dispatch dependent operations before the parent load has finished executing. As uops are speculatively scheduled and executed in processor <b>200</b>, the processor <b>200</b> also includes logic to handle memory misses. If a data load misses in the data cache, there can be dependent operations in flight in the pipeline that have left the scheduler with temporarily incorrect data. A replay mechanism tracks and re-executes instructions that use incorrect data. Only the dependent operations need to be replayed and the independent ones are allowed to complete. The schedulers and replay mechanism of one embodiment of a processor are also designed to catch instruction sequences for dot-product operations.</div>
</li> <li> <para-num num="[0062]"> </para-num> <div class="description-line" id="p-0067" num="0062">The term “registers” is used herein to refer to the on-board processor storage locations that are used as part of macro-instructions to identify operands. In other words, the registers referred to herein are those that are visible from the outside of the processor (from a programmer's perspective). However, the registers of an embodiment should not be limited in meaning to a particular type of circuit. Rather, a register of an embodiment need only be capable of storing and providing data, and performing the functions described herein. The registers described herein can be implemented by circuitry within a processor using any number of different techniques, such as dedicated physical registers, dynamically allocated physical registers using register renaming, combinations of dedicated and dynamically allocated physical registers, etc. In one embodiment, integer registers store thirty-two bit integer data. A register file of one embodiment also contains sixteen XMM and general purpose registers, eight multimedia (e.g., “EM64T” additions) multimedia SIMD registers for packed data. For the discussions below, the registers are understood to be data registers designed to hold packed data, such as 64 bits wide MMX™ registers (also referred to as ‘mm’ registers in some instances) in microprocessors enabled with MMX technology from Intel Corporation of Santa Clara, Calif. These MMX registers, available in both integer and floating point forms, can operate with packed data elements that accompany SIMD and SSE instructions. Similarly, 128 bits wide XMM registers relating to SSE2, SSE3, SSE4, or beyond (referred to generically as “SSEx”) technology can also be used to hold such packed data operands. In this embodiment, in storing packed data and integer data, the registers do not need to differentiate between the two data types.</div>
</li> <li> <para-num num="[0063]"> </para-num> <div class="description-line" id="p-0068" num="0063">In the examples of the following figures, a number of data operands are described. <figref idrefs="DRAWINGS">FIG. 3A</figref> illustrates various packed data type representations in multimedia registers according to one embodiment of the present invention. <figref idrefs="DRAWINGS">FIG. 3A</figref> illustrates data types for a packed byte <b>310</b>, a packed word <b>320</b>, and a packed doubleword (dword) <b>330</b> for 128 bits wide operands. The packed byte format <b>310</b> of this example is 128 bits long and contains sixteen packed byte data elements. A byte is defined here as 8 bits of data. Information for each byte data element is stored in bit <b>7</b> through bit <b>0</b> for byte 0, bit <b>15</b> through bit <b>8</b> for byte 1, bit <b>23</b> through bit <b>16</b> for byte 2, and finally bit <b>120</b> through bit <b>127</b> for byte 15. Thus, all available bits are used in the register. This storage arrangement increases the storage efficiency of the processor. As well, with sixteen data elements accessed, one operation can now be performed on sixteen data elements in parallel.</div>
</li> <li> <para-num num="[0064]"> </para-num> <div class="description-line" id="p-0069" num="0064">Generally, a data element is an individual piece of data that is stored in a single register or memory location with other data elements of the same length. In packed data sequences relating to SSEx technology, the number of data elements stored in a XMM register is 128 bits divided by the length in bits of an individual data element. Similarly, in packed data sequences relating to MMX and SSE technology, the number of data elements stored in an MMX register is 64 bits divided by the length in bits of an individual data element. Although the data types illustrated in <figref idrefs="DRAWINGS">FIG. 3A</figref> are 128 bit long, embodiments of the present invention can also operate with 64 bit wide or other sized operands. The packed word format <b>320</b> of this example is 128 bits long and contains eight packed word data elements. Each packed word contains sixteen bits of information. The packed doubleword format <b>330</b> of <figref idrefs="DRAWINGS">FIG. 3A</figref> is 128 bits long and contains four packed doubleword data elements. Each packed doubleword data element contains thirty two bits of information. A packed quadword is 128 bits long and contains two packed quad-word data elements.</div>
</li> <li> <para-num num="[0065]"> </para-num> <div class="description-line" id="p-0070" num="0065"> <figref idrefs="DRAWINGS">FIG. 3B</figref> illustrates alternative in-register data storage formats. Each packed data can include more than one independent data element. Three packed data formats are illustrated; packed half <b>341</b>, packed single <b>342</b>, and packed double <b>343</b>. One embodiment of packed half <b>341</b>, packed single <b>342</b>, and packed double <b>343</b> contain fixed-point data elements. For an alternative embodiment one or more of packed half <b>341</b>, packed single <b>342</b>, and packed double <b>343</b> may contain floating-point data elements. One alternative embodiment of packed half <b>341</b> is one hundred twenty-eight bits long containing eight 16-bit data elements. One embodiment of packed single <b>342</b> is one hundred twenty-eight bits long and contains four 32-bit data elements. One embodiment of packed double <b>343</b> is one hundred twenty-eight bits long and contains two 64-bit data elements. It will be appreciated that such packed data formats may be further extended to other register lengths, for example, to 96-bits, 160-bits, 192-bits, 224-bits, 256-bits or more.</div>
</li> <li> <para-num num="[0066]"> </para-num> <div class="description-line" id="p-0071" num="0066"> <figref idrefs="DRAWINGS">FIG. 3C</figref> illustrates various signed and unsigned packed data type representations in multimedia registers according to one embodiment of the present invention. Unsigned packed byte representation <b>344</b> illustrates the storage of an unsigned packed byte in a SIMD register. Information for each byte data element is stored in bit seven through bit zero for byte zero, bit fifteen through bit eight for byte one, bit twenty-three through bit sixteen for byte two, and finally bit one hundred twenty through bit one hundred twenty-seven for byte fifteen. Thus, all available bits are used in the register. This storage arrangement can increase the storage efficiency of the processor. As well, with sixteen data elements accessed, one operation can now be performed on sixteen data elements in a parallel fashion. Signed packed byte representation <b>345</b> illustrates the storage of a signed packed byte. Note that the eighth bit of every byte data element is the sign indicator. Unsigned packed word representation <b>346</b> illustrates how word seven through word zero are stored in a SIMD register. Signed packed word representation <b>347</b> is similar to the unsigned packed word in-register representation <b>346</b>. Note that the sixteenth bit of each word data element is the sign indicator. Unsigned packed doubleword representation <b>348</b> shows how doubleword data elements are stored. Signed packed doubleword representation <b>349</b> is similar to unsigned packed doubleword in-register representation <b>348</b>. Note that the necessary sign bit is the thirty-second bit of each doubleword data element.</div>
</li> <li> <para-num num="[0067]"> </para-num> <div class="description-line" id="p-0072" num="0067"> <figref idrefs="DRAWINGS">FIG. 3D</figref> is a depiction of one embodiment of an operation encoding (opcode) format <b>360</b>, having thirty-two or more bits, and register/memory operand addressing modes corresponding with a type of opcode format described in the “IA-32 Intel Architecture Software Developer's Manual Volume 2: Instruction Set Reference,” which is which is available from Intel Corporation, Santa Clara, Calif. on the world-wide-web (www) at intel.com/design/litcentr. In one embodiment, a dot-product operation may be encoded by one or more of fields <b>361</b> and <b>362</b>. Up to two operand locations per instruction may be identified, including up to two source operand identifiers <b>364</b> and <b>365</b>. For one embodiment of the dot-product instruction, destination operand identifier <b>366</b> is the same as source operand identifier <b>364</b>, whereas in other embodiments they are different. For an alternative embodiment, destination operand identifier <b>366</b> is the same as source operand identifier <b>365</b>, whereas in other embodiments they are different. In one embodiment of a dot-product instruction, one of the source operands identified by source operand identifiers <b>364</b> and <b>365</b> is overwritten by the results of the dot-product operations, whereas in other embodiments identifier <b>364</b> corresponds to a source register element and identifier <b>365</b> corresponds to a destination register element. For one embodiment of the dot-product instruction, operand identifiers <b>364</b> and <b>365</b> may be used to identify 32-bit or 64-bit source and destination operands.</div>
</li> <li> <para-num num="[0068]"> </para-num> <div class="description-line" id="p-0073" num="0068"> <figref idrefs="DRAWINGS">FIG. 3E</figref> is a depiction of another alternative operation encoding (opcode) format <b>370</b>, having forty or more bits. Opcode format <b>370</b> corresponds with opcode format <b>360</b> and comprises an optional prefix byte <b>378</b>. The type of dot-product operation may be encoded by one or more of fields <b>378</b>, <b>371</b>, and <b>372</b>. Up to two operand locations per instruction may be identified by source operand identifiers <b>374</b> and <b>375</b> and by prefix byte <b>378</b>. For one embodiment of the dot-product instruction, prefix byte <b>378</b> may be used to identify 32-bit or 64-bit source and destination operands. For one embodiment of the dot-product instruction, destination operand identifier <b>376</b> is the same as source operand identifier <b>374</b>, whereas in other embodiments they are different. For an alternative embodiment, destination operand identifier <b>376</b> is the same as source operand identifier <b>375</b>, whereas in other embodiments they are different. In one embodiment, the dot-product operations multiply one of the operands identified by operand identifiers <b>374</b> and <b>375</b> to another operand identified by the operand identifiers <b>374</b> and <b>375</b> is overwritten by the results of the dot-product operations, whereas in other embodiments the dot-product of the operands identified by identifiers <b>374</b> and <b>375</b> are written to another data element in another register. Opcode formats <b>360</b> and <b>370</b> allow register to register, memory to register, register by memory, register by register, register by immediate, register to memory addressing specified in part by MOD fields <b>363</b> and <b>373</b> and by optional scale-index-base and displacement bytes.</div>
</li> <li> <para-num num="[0069]"> </para-num> <div class="description-line" id="p-0074" num="0069">Turning next to <figref idrefs="DRAWINGS">FIG. 3F</figref>, in some alternative embodiments, 64 bit single instruction multiple data (SIMD) arithmetic operations may be performed through a coprocessor data processing (CDP) instruction. Operation encoding (opcode) format <b>380</b> depicts one such CDP instruction having CDP opcode fields <b>382</b> and <b>389</b>. The type of CDP instruction, for alternative embodiments of dot-product operations, may be encoded by one or more of fields <b>383</b>, <b>384</b>, <b>387</b>, and <b>388</b>. Up to three operand locations per instruction may be identified, including up to two source operand identifiers <b>385</b> and <b>390</b> and one destination operand identifier <b>386</b>. One embodiment of the coprocessor can operate on 8, 16, 32, and 64 bit values. For one embodiment, the dot-product operation is performed on integer data elements. In some embodiments, a dot-product instruction may be executed conditionally, using selection field <b>381</b>. For some dot-product instructions source data sizes may be encoded by field <b>383</b>. In some embodiments of dot-product instruction, Zero (Z), negative (N), carry (C), and overflow (V) detection can be done on SIMD fields. For some instructions, the type of saturation may be encoded by field <b>384</b>.</div>
</li> <li> <para-num num="[0070]"> </para-num> <div class="description-line" id="p-0075" num="0070"> <figref idrefs="DRAWINGS">FIG. 4</figref> is a block diagram of one embodiment of logic to perform a dot-product operation on packed data operands in accordance with the present invention. Embodiments of the present invention can be implemented to function with various types of operands such as those described above. For one implementation, dot-product operations in accordance to the present invention are implemented as a set of instructions to operate on specific data types. For instance, a dot-product packed single-precision (DPPS) instruction is provided to determine the dot-product for 32-bit data types, including integer and floating point. Similarly, a dot-product packed double-precision (DPPD) instruction is provided to determine the dot-product for 64-bit data types, including integer and floating point. Although these instructions have different names, the general dot-product operation that they perform is similar. For simplicity, the following discussions and examples below are in the context of a dot-product instruction to process data elements.</div>
</li> <li> <para-num num="[0071]"> </para-num> <div class="description-line" id="p-0076" num="0071">In one embodiment, the dot-product instruction identifies various information, including: an identifier of a first data operand DATA A <b>410</b> and an identifier of a second second data operand DATA B <b>420</b>, and an identifier for the RESULTANT <b>440</b> of the dot-product operation (which may be the same identifier as one of the first data operand identifiers in one embodiment). For the following discussions, DATA A, DATA B, and RESULTANT are generally referred to as operands or data blocks, but not restricted as such, and also include registers, register files, and memory locations. In one embodiment, each dot-product instruction (DPPS, DPPD) is decoded into one micro-operation. In an alternative embodiment, each instruction may be decoded into a various number of micro-ops to perform the dot-product operation on the data operands. For this example, the operands <b>410</b>, <b>420</b>, are 128 bit wide pieces of information stored in a source register/memory having word wide data elements. In one embodiment, the operands <b>410</b>, <b>420</b>, are held in 128 bit long SIMD registers, such as 128 bit SSEx XMM registers. For one embodiment, the RESULTANT <b>440</b> is also a XMM data register. Furthermore, RESULTANT <b>440</b> may also be the same register or memory location as one of the source operands. Depending on the particular implementation, the operands and registers can be other lengths such as 32, 64, and 256 bits, and have byte, doubleword, or quadword sized data elements. Although the data elements of this example are word size, the same concept can be extended to byte and doubleword sized elements. In one embodiment, where the data operands are 64 bit wide, MMX registers are used in place of the XMM registers.</div>
</li> <li> <para-num num="[0072]"> </para-num> <div class="description-line" id="p-0077" num="0072">The first operand <b>410</b> in this example is comprised of a set of eight data elements: A<b>3</b>, A<b>2</b>, A<b>1</b>, and A<b>0</b>. Each individual data element corresponds to a data element position in the resultant <b>440</b>. The second operand <b>420</b> is comprised of another set of eight data segments: B<b>3</b>, B<b>2</b>, B<b>1</b>, and B<b>0</b>. The data segments here are of equal length and each comprise of a single word (32 bits) of data. However, data elements and data element positions can possess other granularities other than words. If each data element was a byte (8 bits), doubleword (32 bits), or a quadword (64 bits), the 128 bit operands would have sixteen byte wide, four doubleword wide, or two quadword wide data elements, respectively. Embodiments of the present invention are not restricted to particular length data operands or data segments, and can be sized appropriately for each implementation.</div>
</li> <li> <para-num num="[0073]"> </para-num> <div class="description-line" id="p-0078" num="0073">The operands <b>410</b>, <b>420</b>, can reside either in a register or a memory location or a register file or a mix. The data operands <b>410</b>, <b>420</b>, are sent to the dot-product computation logic <b>430</b> of an execution unit in the processor along with a dot-product instruction. By the time the dot-product instruction reaches the execution unit, the instruction should have been decoded earlier in the processor pipeline, in one embodiment. Thus the dot-product instruction can be in the form of a micro operation (uop) or some other decoded format. For one embodiment, the two data operands <b>410</b>, <b>420</b>, are received at dot-product computation logic <b>430</b>. The dot-product computation logic <b>430</b> generates a first multiplication product of two data elements of the first operand <b>410</b>, with a second multiplication product of two data elements in the corresponding data element position of the second operand <b>420</b>, and stores the sum of the first and second multiplication products into the appropriate position in the resultant <b>440</b>, which may correspond to the same storage location as the first or second operand. In one embodiment, the data elements from the first and second operands are single precision (e.g., 32 bit), whereas in other embodiments, the data elements from the first and second operands are double precision (e.g., 64 bit).</div>
</li> <li> <para-num num="[0074]"> </para-num> <div class="description-line" id="p-0079" num="0074">For one embodiment, the data elements for all of the data positions are processed in parallel. In another embodiment, a certain portion of the data element positions can be processed together at a time. In one embodiment, the resultant <b>440</b> is comprised of two or four possible dot-product result positions, depending on whether DPPD or DPPS is performed, respectively: DOT-PRODUCT<sub>A31-0</sub>, DOT-PRODUCT<sub>A63-32</sub>, DOT-PRODUCT<sub>A95-64</sub>, DOT-PRODUCT<sub>A127-96 </sub>(for DPPS instruction results), and DOT-PRODUCT<sub>A63-0</sub>, DOT-PRODUCT<sub>A27-64 </sub>(for DPPD instruction results).</div>
</li> <li> <para-num num="[0075]"> </para-num> <div class="description-line" id="p-0080" num="0075">In one embodiment, the position of the dot-product result in resultant <b>440</b> depends upon a selection field associated with the dot-product instruction. For example, for DPPS instructions, the position of the dot-product result in the resultant <b>440</b> is DOT-PRODUCT<sub>A31-0</sub>, if the selection field is equal to a first value, DOT-PRODUCT<sub>A63-32</sub>, if the selection field is equal to a second value, DOT-PRODUCT<sub>A95-64</sub>, if the selection field is equal to a third value, and DOT-PRODUCT<sub>A127-64</sub>, if the selection field is equal to a fourth value. In the case of a DPPD instruction, the position of the dot-product result in resultant <b>440</b> is DOT-PRODUCT<sub>A63-0</sub>, if the selection field is a first value, and DOT-PRODUCT<sub>A127-64 </sub>if the selection field is a second value.</div>
</li> <li> <para-num num="[0076]"> </para-num> <div class="description-line" id="p-0081" num="0076"> <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>illustrates the operation of a dot-product instruction according to one embodiment of the present invention. Specifically, <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>illustrates the operation of a DPPS instruction, according to one embodiment. In one embodiment, the dot-product operation of the example illustrated in <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>may substantially be performed by the dot-product computation logic <b>430</b> of <figref idrefs="DRAWINGS">FIG. 4</figref>. In other embodiments, the dot-product operation of <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>may be performed by other logic, including hardware, software, or some combination thereof.</div>
</li> <li> <para-num num="[0077]"> </para-num> <div class="description-line" id="p-0082" num="0077">In other embodiments, the operations illustrated in <figref idrefs="DRAWINGS">FIGS. 4, 5</figref> <i>a</i>, and <b>5</b> <i>b </i>may be performed in any combination or order to produce the dot-product result. In one embodiment, <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>illustrates a 128-bit source register <b>501</b> <i>a </i>including storage locations to up to store four single precision floating point or integer values of 32 bits each, A<b>0</b>-A<b>3</b>. Similarly illustrated in <figref idrefs="DRAWINGS">FIG. 5<i>a </i> </figref>is a 128-bit destination register <b>505</b> <i>a </i>including storage locations to store up to four single precision floating point or integer values of 32 bits each, B<b>0</b>-B<b>3</b>. In one embodiment, each value, A<b>0</b>-A<b>3</b>, stored in the source register is multiplied to a corresponding value, B<b>0</b>-B<b>3</b>, stored in the corresponding position of the destination register and each resultant value, A<b>0</b>*B<b>0</b>, A<b>1</b>*B<b>1</b>, A<b>2</b>*B<b>2</b>, A<b>3</b>*B<b>3</b> (referred to herein as the “products”), is stored in a corresponding storage location of a first 128-bit temporary register (“TEMP<b>1</b>”) <b>510</b> <i>a </i>including storage locations to store up to four single precision floating point or integer values of 32 bits each.</div>
</li> <li> <para-num num="[0078]"> </para-num> <div class="description-line" id="p-0083" num="0078">In one embodiment, pairs of products are added together and each sum (referred to herein as “the intermediate sums”) is stored into a storage location of a second 128-bit temporary register (“TEMP<b>2</b>”) <b>515</b> <i>a </i>and a third 128-bit temporary register (“TEMP<b>3</b>”) <b>520</b> <i>a</i>. In one embodiment the products are stored into the least-most significant 32-bit element storage location of the first and second temporary registers. In other embodiments, they may be stored in other element storage locations of the first and second temporary registers. Furthermore, in some embodiments, the products may be stored in the same register, such as either the first or second temporary register.</div>
</li> <li> <para-num num="[0079]"> </para-num> <div class="description-line" id="p-0084" num="0079">In one embodiment, the intermediate sums are added together (referred to herein as “the final sum”) and stored into storage element a fourth 128-bit temporary register (“TEMP<b>4</b>”) <b>525</b> <i>a</i>. In one embodiment, the final sum is stored into a least-significant 32-bit storage element of the TEMP<b>4</b>, whereas in other embodiments the final sum is stored into other storage elements of TEMP<b>4</b>. The final sum is then stored into a storage element of the destination register <b>505</b> <i>a</i>. The exact storage element into which the final sum is to be stored may depend on variables configurable within the dot-product instruction. In one embodiment, an immediate field (“IMMy[x]”) containing a number of bit storage locations may be used to determine the destination register storage element into which the final sum is to be stored. For example, in one embodiment, if the IMM<b>8</b>[<b>0</b>] field contains a first value (e.g., “1”), the final sum is stored into storage element B<b>0</b> of the destination register, if the IMM<b>8</b>[<b>1</b>] field contains a first value (e.g., “1”), the final sum is stored into storage element B<b>1</b>, if the IMM<b>8</b> [<b>2</b>] field contains a first value (e.g., “1”), the final sum is stored into storage element B<b>2</b> of the destination register, and if the IMM<b>8</b>[<b>3</b>] field contains a first value (e.g., “1”), the final sum is stored into storage element B<b>3</b> of the destination register. In other embodiments, other immediate fields may be used to determine the storage element into which the final sum is stored in the destination register.</div>
</li> <li> <para-num num="[0080]"> </para-num> <div class="description-line" id="p-0085" num="0080">In one embodiment, immediate fields may be used to control whether each multiply and addition operation is performed in the operation illustrated in <figref idrefs="DRAWINGS">FIG. 5<i>a</i> </figref>. For example, IMM<b>8</b>[<b>4</b>] may be used to indicate (by being set to a “0” or “1”, for example) whether the A<b>0</b> is to be multiplied by B<b>0</b> and the result stored into TEMP<b>1</b>. Similarly, IMM<b>8</b>[<b>5</b>] may be used to indicate (by being set to a “0” or “1”, for example) whether the A<b>1</b> is to be multiplied by B<b>1</b> and the result stored into TEMP<b>1</b>. Likewise, IMM<b>8</b>[<b>6</b>] may be used to indicate (by being set to a “0” or “1”, for example) whether the A<b>2</b> is to be multiplied by B<b>2</b> and the result stored into TEMP<b>1</b>. Finally, IMM<b>8</b>[<b>7</b>] may be used to indicate (by being set to a “0” or “1”, for example) whether the A<b>3</b> is to be multiplied by B<b>3</b> and the result stored into TEMP<b>1</b>.</div>
</li> <li> <para-num num="[0081]"> </para-num> <div class="description-line" id="p-0086" num="0081"> <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>illustrates the operation of a DPPD instruction, according to one embodiment. One difference between the DPPS and DPPD instructions is that DPPD operate on double precision floating point and integer values (e.g., 64 bit values) instead of single precision values. Accordingly, there are fewer data elements to manage and therefore fewer intermediate operations and storage units (e.g., registers) involved in performing a DPPD instruction than a DPPS instruction, in one embodiment.</div>
</li> <li> <para-num num="[0082]"> </para-num> <div class="description-line" id="p-0087" num="0082">In one embodiment, <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>illustrates a 128-bit source register <b>501</b> <i>b </i>including storage elements to up to store two double precision floating point or integer values of 64 bits each, A<b>0</b>-A<b>1</b>. Similarly illustrated in <figref idrefs="DRAWINGS">FIG. 5<i>b </i> </figref>is a 128-bit destination register <b>505</b> <i>b </i>including storage elements to store up to two double precision floating point or integer values of 64 bits each, B<b>0</b>-B<b>1</b>. In one embodiment, each value, A<b>0</b>-A<b>1</b>, stored in the source register is multiplied to a corresponding value, B<b>0</b>-B<b>1</b>, stored in the corresponding position of the destination register and each resultant value, A<b>0</b>*B<b>0</b>, A<b>1</b>*B<b>1</b> (referred to herein as the “products”), is stored in a corresponding storage element of a first 128-bit temporary register (“TEMP<b>1</b>”) <b>510</b> <i>b </i>including storage elements to store up to two double precision floating point or integer values of 64 bits each.</div>
</li> <li> <para-num num="[0083]"> </para-num> <div class="description-line" id="p-0088" num="0083">In one embodiment, pairs of products are added together and each sum (referred to herein as “the final sum”) is stored into a storage element of a second 128-bit temporary register (“TEMP<b>2</b>”) <b>515</b> <i>b</i>. In one embodiment the products and final sum are stored into the least-most significant 64-bit element storage location of the first and second temporary registers, respectively. In other embodiments, they may be stored in other element storage locations of the first and second temporary registers.</div>
</li> <li> <para-num num="[0084]"> </para-num> <div class="description-line" id="p-0089" num="0084">In one embodiment, the final sum is stored into a storage element of the destination register <b>505</b> <i>b</i>. The exact storage element into which the final sum is to be stored may depend on variables configurable within the dot-product instruction. In one embodiment, an immediate field (“IMMy[x]”) containing a number of bit storage locations may be used to determine the destination register storage element into which the final sum is to be stored. For example, in one embodiment, if the IMM<b>8</b>[<b>0</b>] field contains a first value (e.g., “1”), the final sum is stored into storage element B<b>0</b> of the destination register, if the IMM<b>8</b>[<b>1</b>] field contains a first value (e.g., “1”), the final sum is stored into storage element B<b>1</b>. In other embodiments, other immediate fields may be used to determine the storage element into which the final sum is stored in the destination register.</div>
</li> <li> <para-num num="[0085]"> </para-num> <div class="description-line" id="p-0090" num="0085">In one embodiment, immediate fields may be used to control whether each multiply operation is performed in the dot-product operations illustrated in <figref idrefs="DRAWINGS">FIG. 5<i>b</i> </figref>. For example, IMM<b>8</b>[<b>4</b>] may be used to indicate (by being set to a “0” or “1”, for example) whether the A<b>0</b> is to be multiplied by B<b>0</b> and the result stored into TEMP<b>1</b>. Similarly, IMM<b>8</b>[<b>5</b>] may be used to indicate (by being set to a “0” or “1”, for example) whether the A<b>1</b> is to be multiplied by B<b>1</b> and the result stored into TEMP<b>1</b>. In other embodiments, other control techniques for determining whether to perform the multiply operations of the dot-product may be used.</div>
</li> <li> <para-num num="[0086]"> </para-num> <div class="description-line" id="p-0091" num="0086"> <figref idrefs="DRAWINGS">FIG. 6A</figref> is a block diagram of a circuit <b>600</b> <i>a </i>for performing a dot-product operation on single-precision integer or floating point values in accordance with one embodiment. The circuit <b>600</b> <i>a </i>of this embodiment multiplies, via multipliers <b>610</b> <i>a</i>-<b>613</b> <i>a</i>, corresponding single-precision elements of two registers <b>601</b> <i>a </i>and <b>605</b> <i>a</i>, the results of which may be selected by multiplexers <b>615</b> <i>a</i>-<b>618</b> <i>a </i>using an immediate field, IMM<b>8</b>[7:4]. Alternatively, multiplexers <b>615</b> <i>a</i>-<b>618</b> <i>a </i>may select a zero value instead of the corresponding product of the multiplication operation for each element. The result of the selection by multiplexers <b>615</b> <i>a</i>-<b>618</b> <i>a </i>are then added together by adder <b>620</b> <i>a</i>, and the result is stored in any of the elements of result register <b>630</b> <i>a</i>, depending upon the value of immediate field, IMM<b>8</b>[3:0], which selects a corresponding sum result from adder <b>620</b> <i>a </i>using multiplexers <b>625</b> <i>a</i>-<b>628</b> <i>a</i>. In one embodiment, multiplexers <b>625</b> <i>a</i>-<b>628</b> <i>a </i>may select zeros to fill an element of result register <b>630</b> <i>a </i>if a sum result is not chosen to be stored in the result element. In other embodiments, more adders may be used to generate the sums of the various multiplication products. Furthermore, in some embodiments, intermediate storage elements may be used to store the product or sum results until they are further operated upon.</div>
</li> <li> <para-num num="[0087]"> </para-num> <div class="description-line" id="p-0092" num="0087"> <figref idrefs="DRAWINGS">FIG. 6B</figref> is a block diagram of a circuit <b>600</b> <i>b </i>for performing a dot-product operation on single-precision integer or floating point values in accordance with one embodiment. The circuit <b>600</b> <i>b </i>of this embodiment multiplies, via multipliers <b>610</b> <i>b</i>, <b>612</b> <i>b</i>, corresponding single-precision elements of two registers <b>601</b> <i>b </i>and <b>605</b> <i>b</i>, the results of which may be selected by multiplexers <b>615</b> <i>b</i>, <b>617</b> <i>b </i>using an immediate field, IMM<b>8</b>[7:4]. Alternatively, multiplexers <b>615</b> <i>b</i>, <b>618</b> <i>b </i>may select a zero value instead of the corresponding product of the multiplication operation for each element. The result of the selection by multiplexers <b>615</b> <i>b</i>, <b>618</b> <i>b </i>are then added together by adder <b>620</b> <i>b</i>, and the result is stored in any of the elements of result register <b>630</b> <i>b</i>, depending upon the value of immediate field, IMM<b>8</b>[3:0], which selects a corresponding sum result from adder <b>620</b> <i>b </i>using multiplexers <b>625</b> <i>b</i>, <b>627</b> <i>b</i>. In one embodiment, multiplexers <b>625</b> <i>b</i>-<b>627</b> <i>b </i>may select zeros to fill an element of result register <b>630</b> <i>b </i>if a sum result is not chosen to be stored stored in the result element. In other embodiments, more adders may be used to generate the sums of the various multiplication products. Furthermore, in some embodiments, intermediate storage elements may be used to store the product or sum results until they are further operated upon.</div>
</li> <li> <para-num num="[0088]"> </para-num> <div class="description-line" id="p-0093" num="0088"> <figref idrefs="DRAWINGS">FIG. 7A</figref> is a pseudo-code representation of operations to perform a DPPS instruction, according to one embodiment. The pseudo-code illustrated in <figref idrefs="DRAWINGS">FIG. 7A</figref> indicates that a single-precision floating point or integer value stored in a source register (“SRC”) in bits <b>31</b>-<b>0</b> is to be multiplied to a single-precision floating point or integer value stored in a destination register (“DEST”) in bits <b>31</b>-<b>0</b> and the result stored in bits <b>31</b>-<b>0</b> of a temporary register (“TEMP<b>1</b>”) only if an immediate value stored in an immediate field (“IMM<b>8</b>[<b>4</b>]”) is equal to “1”. Otherwise, bit storage locations <b>31</b>-<b>0</b> may contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0089]"> </para-num> <div class="description-line" id="p-0094" num="0089">Also illustrated in <figref idrefs="DRAWINGS">FIG. 7A</figref> is pseudo-code to indicate that a single-precision floating point or integer value stored in the SRC register in bits <b>63</b>-<b>32</b> is to be multiplied to a single-precision floating point or integer value stored in the DEST register in bits <b>63</b>-<b>32</b> and the result stored in bits <b>63</b>-<b>32</b> of a TEMP<b>1</b> register only if an immediate value stored in an immediate field (“IMM<b>8</b>[<b>5</b>]”) is equal to “1”. Otherwise, bit storage locations <b>63</b>-<b>32</b> may contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0090]"> </para-num> <div class="description-line" id="p-0095" num="0090">Similarly illustrated in <figref idrefs="DRAWINGS">FIG. 7A</figref> is pseudo-code to indicate that a single-precision floating point or integer value stored in the SRC register in bits <b>95</b>-<b>64</b> is to be multiplied to a single-precision floating point or integer value stored in the DEST register in bits <b>95</b>-<b>64</b> and the result stored in bits <b>95</b>-<b>64</b> of a TEMP<b>1</b> register only if an immediate value stored in an immediate field (“IMM<b>8</b>[<b>6</b>]”) is equal to “1”. Otherwise, bit storage locations <b>95</b>-<b>64</b> may contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0091]"> </para-num> <div class="description-line" id="p-0096" num="0091">Finally, illustrated in <figref idrefs="DRAWINGS">FIG. 7A</figref> is pseudo-code to indicate that a single-precision floating point or integer value stored in the SRC register in bits <b>127</b>-<b>96</b> is to be multiplied to a single-precision floating point or integer value stored in the DEST register in bits <b>127</b>-<b>96</b> and the result stored in bits <b>127</b>-<b>96</b> of a TEMP<b>1</b> register only if an immediate value stored in an immediate field (“IMM<b>8</b>[<b>7</b>]”) is equal to “1”. Otherwise, bit storage locations <b>127</b>-<b>96</b> may contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0092]"> </para-num> <div class="description-line" id="p-0097" num="0092">Next, <figref idrefs="DRAWINGS">FIG. 7A</figref> illustrates that bits <b>31</b>-<b>0</b> are added to bits <b>63</b>-<b>32</b> of TEMP<b>1</b> and the result stored into bit storage <b>31</b>-<b>0</b> of a second temporary register (“TEMP<b>2</b>”). Similarly, bits <b>95</b>-<b>64</b> are added to bits <b>127</b>-<b>96</b> of TEMP<b>1</b> and the result stored into bit storage <b>31</b>-<b>0</b> of a third temporary register (“TEMP<b>3</b>”). Finally, bits <b>31</b>-<b>0</b> of TEMP<b>2</b> are added to bits <b>31</b>-<b>0</b> of TEMP<b>3</b> and the result stored into bit storage <b>31</b>-<b>0</b> of a fourth temporary register (“TEMP<b>4</b>”).</div>
</li> <li> <para-num num="[0093]"> </para-num> <div class="description-line" id="p-0098" num="0093">The data stored in temporary registers may then be stored into the DEST register, in one embodiment. The particular location within the DEST register to store the data may depend upon other fields within the DPPS instruction, such as fields in IMM<b>8</b>[<i>x</i>]. Particularly, <figref idrefs="DRAWINGS">FIG. 7A</figref> illustrates that, in one embodiment, bits <b>31</b>-<b>0</b> of TEMP<b>4</b> are stored into DEST bit storage <b>31</b>-<b>0</b> if IMM<b>8</b>[<b>0</b>] is equal to “1”, DEST bit storage <b>63</b>-<b>32</b> if IMM<b>8</b>[<b>1</b>] is equal to “1”, DEST bit storage <b>95</b>-<b>64</b> if IMM<b>8</b>[<b>2</b>] is equal to “1”, or DEST bit storage <b>127</b>-<b>96</b> if IMM<b>8</b>[<b>3</b>] is equal to “1”. Otherwise, the corresponding DEST bit element will contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0094]"> </para-num> <div class="description-line" id="p-0099" num="0094"> <figref idrefs="DRAWINGS">FIG. 7B</figref> is a pseudo-code representation of operations to perform a DPPD instruction, according to one embodiment. The pseudo-code illustrated in <figref idrefs="DRAWINGS">FIG. 7B</figref> indicates that a single-precision floating point or integer value stored in a source register (“SRC”) in bits <b>63</b>-<b>0</b> is to be multiplied to a single-precision floating point or integer value stored in a destination register (“DEST”) in bits <b>63</b>-<b>0</b> and the result stored in bits <b>63</b>-<b>0</b> of a temporary register (“TEMP<b>1</b>”) only if an immediate value stored in an immediate field (“IMM<b>8</b>[<b>4</b>]”) is equal to “1”. Otherwise, bit storage locations <b>63</b>-<b>0</b> may contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0095]"> </para-num> <div class="description-line" id="p-0100" num="0095">Also illustrated in <figref idrefs="DRAWINGS">FIG. 7B</figref> is pseudo-code to indicate that a single-precision floating point or integer value stored in the SRC register in bits <b>127</b>-<b>64</b> is to be multiplied to a single-precision floating point or integer value stored in the DEST register in bits <b>127</b>-<b>64</b> and the result stored in bits <b>127</b>-<b>64</b> of a TEMP<b>1</b> register only if an immediate value stored in an immediate field (“IMM<b>8</b>[<b>5</b>]”) is equal to “1”. Otherwise, bit storage locations <b>127</b>-<b>64</b> may contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0096]"> </para-num> <div class="description-line" id="p-0101" num="0096">Next, <figref idrefs="DRAWINGS">FIG. 7B</figref> illustrates that bits <b>63</b>-<b>0</b> are added to bits <b>127</b>-<b>64</b> of TEMP<b>1</b> and the result stored into bit storage <b>63</b>-<b>0</b> of a second temporary register (“TEMP<b>2</b>”). The data stored in the temporary register may then be stored into the DEST register, in one embodiment. The particular location within the DEST register to store the data may depend upon other fields within the DPPS instruction, such as fields in IMM<b>8</b>[<i>x</i>]. Particularly, <figref idrefs="DRAWINGS">FIG. 7A</figref> illustrates that, in one embodiment, bits <b>63</b>-<b>0</b> of TEMP<b>2</b> are stored into DEST bit storage <b>63</b>-<b>0</b> if IMM<b>8</b>[<b>0</b>] is equal to “1”, or bits <b>63</b>-<b>0</b> of TEMP<b>2</b> are stored in DEST bit storage <b>127</b>-<b>64</b> if IMM<b>8</b>[<b>1</b>] is equal to “1”. Otherwise, the corresponding DEST bit element will contain a null value, such as all zeros.</div>
</li> <li> <para-num num="[0097]"> </para-num> <div class="description-line" id="p-0102" num="0097">The operations disclosed in <figref idrefs="DRAWINGS">FIGS. 7A and 7B</figref> are merely one representation of operations that may be used in one or more embodiments of the invention. Specifically, the pseudo-code illustrated in <figref idrefs="DRAWINGS">FIGS. 7A and 7B</figref> correspond to operations performed according to one or more processor architectures having 128 bit registers. Other embodiments may be performed in processor architectures having any size of registers, or other type of storage area. Furthermore, other embodiments may not use the registers exactly as illustrated in <figref idrefs="DRAWINGS">FIGS. 7A and 7B</figref>. For example, in some embodiments, a different number of temporary registers, or none at all, may be used to stored operands. Lastly, embodiments of the invention may be performed among numerous processors or processing cores using any number of registers or datatypes.</div>
</li> <li> <para-num num="[0098]"> </para-num> <div class="description-line" id="p-0103" num="0098">Thus, techniques for performing a dot-product operation are disclosed. While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure. In an area of technology such as this, where growth is fast and further advancements are not easily foreseen, the disclosed embodiments may be readily modifiable in arrangement and detail as facilitated by enabling technological advancements without departing from the principles of the present disclosure or the scope of the accompanying claims.</div>
</li> </ul>
</div>
</section><section itemprop="claims" itemscope="">
<h2>Claims (<span itemprop="count">9</span>)</h2>
<div html="" itemprop="content"><div class="claims" lang="EN" load-source="patent-office" mxw-id="PCLM117543311">
<claim-statement>What is claimed is:</claim-statement>
<div class="claim"> <div class="claim" id="CLM-00001" num="00001">
<div class="claim-text"> <b>1</b>. A processor comprising:
<div class="claim-text">a first source vector register to store a first plurality of packed single-precision floating point values;</div> <div class="claim-text">a second source vector register to store a second plurality of packed single-precision floating point values;</div> <div class="claim-text">instruction decode circuitry to decode instructions; and</div> <div class="claim-text">an execution circuit to execute the instructions, wherein, in response to the instruction, decode circuitry decoding a dot-product instruction, the execution circuit is to:
<div class="claim-text">multiply selected packed single-precision floating point values in the first plurality with selected packed single-precision floating point values in the second plurality to generate a plurality of temporary products,</div>
<div class="claim-text">store the temporary products in a first temporary storage location,</div>
<div class="claim-text">add a first pair of the temporary products to generate a first sum,</div>
<div class="claim-text">store the first sum in a second temporary storage location,</div>
<div class="claim-text">add a second pair of the temporary products to generate a second sum,</div>
<div class="claim-text">store the second sum in a third temporary storage location, and</div>
<div class="claim-text">add the first and second sums to generate a cumulative sum,</div>
</div> <div class="claim-text">a destination register into which the execution unit is to selectively write the cumulative sum.</div> </div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00002" num="00002">
<div class="claim-text"> <b>2</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the dot product instruction comprises an immediate having a first set of bits, a value of each bit in the first set of bits to cause the execution unit to either select or not select corresponding packed single precision floating point values from the first and second plurality to multiply.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00003" num="00003">
<div class="claim-text"> <b>3</b>. The processor of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the immediate comprises a second set of bits, wherein bits within the second set of bits set to 1 cause the execution unit to select a corresponding pair of packed single precision floating point values from the first and second plurality to multiply.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00004" num="00004">
<div class="claim-text"> <b>4</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the execution circuit comprises an out-of-order execution circuit.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00005" num="00005">
<div class="claim-text"> <b>5</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<div class="claim-text">instruction fetch circuitry to fetch the instructions from a memory.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00006" num="00006">
<div class="claim-text"> <b>6</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:
<div class="claim-text">scheduler circuitry to schedule execution of the instructions by the execution circuit.</div>
</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00007" num="00007">
<div class="claim-text"> <b>7</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the execution circuit comprises an out-of-order execution circuit.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00008" num="00008">
<div class="claim-text"> <b>8</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the instruction decode circuitry is to decode the dot-product instruction into a plurality of microoperations, the execution circuit to execute the microoperation.</div>
</div>
</div> <div class="claim-dependent"> <div class="claim" id="CLM-00009" num="00009">
<div class="claim-text"> <b>9</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the execution circuit is further to:
<div class="claim-text">store the cumulative sum in the destination register.</div> </div>
</div>
</div> </div>
</div>
</section>
                </article>
            </search-app>
        </body>
    </html>
    